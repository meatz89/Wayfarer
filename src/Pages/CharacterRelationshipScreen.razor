@page "/relationships"
@using Wayfarer.Pages.Components

@inherits MainGameplayViewBase

@inject ConnectionTokenManager TokenManager
@inject SpecialLetterGenerationService SpecialLetterService

<div class="character-relationship-container">
    <h2>Character Relationships</h2>
    
    @* Token Context Tabs *@
    <div class="token-context-tabs">
        <button class="context-tab @(activeTab == "All" ? "active" : "")" @onclick='() => SetActiveTab("All")'>
            All Relationships
        </button>
        @foreach (ConnectionType tokenType in Enum.GetValues<ConnectionType>())
        {
            <button class="context-tab @(activeTab == tokenType.ToString() ? "active" : "")" 
                    @onclick="@(() => SetActiveTab(tokenType.ToString()))">
                @GetTokenIcon(tokenType) @tokenType
                <span class="tab-count">(@GetNPCCountForContext(tokenType))</span>
            </button>
        }
    </div>
    
    @* Summary Stats for Active Tab *@
    <div class="relationship-summary">
        @if (activeTab == "All")
        {
            <p>Active Relationships: @GetFilteredNPCs().Count()</p>
            <p>Total Debts: @GetTotalDebts()</p>
            <p>Special Letters Available: @GetSpecialLetterCount()</p>
        }
        else
        {
            var tokenType = Enum.Parse<ConnectionType>(activeTab);
            <p>@activeTab Relationships: @GetFilteredNPCs().Count()</p>
            <p>Debts: @GetDebtsForContext(tokenType)</p>
            <p>Ready for Special Letters: @GetSpecialLetterReadyCount(tokenType)</p>
        }
        <div class="help-icon" title="@GetHelpTooltip()">?</div>
    </div>
    
    @* NPC Grid for Active Context *@
    <div class="npc-relationship-grid">
        @foreach (var npc in GetFilteredNPCs())
        {
            <NPCRelationshipCard NPC="@npc" GameWorld="@GameWorld" />
        }
    </div>
    
    @if (!GetFilteredNPCs().Any())
    {
        <div class="no-relationships">
            @if (activeTab == "All")
            {
                <p>No established relationships yet.</p>
                <p>Meet NPCs at locations and build connections!</p>
            }
            else
            {
                <p>No @activeTab relationships established.</p>
                <p>Build @activeTab connections through appropriate actions!</p>
            }
        </div>
    }
    
    @* Leverage & Debt Overview *@
    @if (GetAllDebts().Any())
    {
        <div class="debt-overview">
            <h3>‚ö†Ô∏è Active Debts & Leverage</h3>
            <div class="debt-list">
                @foreach (var debt in GetAllDebts())
                {
                    <div class="debt-item">
                        <span class="debt-npc">@debt.NPCName</span>
                        <span class="debt-amount">@debt.TokenType: @debt.Amount</span>
                        <span class="debt-effect">Letters enter at position @debt.LeveragePosition</span>
                    </div>
                }
            </div>
        </div>
    }
    
    @* Back Button *@
    <div class="navigation-buttons">
        <button class="btn btn-secondary" @onclick="() => OnNavigate?.Invoke(CurrentViews.LocationScreen)">Back to Main</button>
    </div>
</div>

@code {

@namespace Wayfarer.Pages
    private string activeTab = "All";
    private List<NPC> allNPCsWithRelationships = new List<NPC>();
    
    protected override void OnInitialized()
    {
        RefreshNPCList();
    }
    
    private void RefreshNPCList()
    {
        // Get all NPCs that have any token relationships
        allNPCsWithRelationships = NPCRepository.GetAllNPCs()
            .Where(npc => !string.IsNullOrEmpty(npc.ID) && HasAnyTokens(npc))
            .ToList();
    }
    
    private void SetActiveTab(string tab)
    {
        activeTab = tab;
        StateHasChanged();
    }
    
    private IEnumerable<NPC> GetFilteredNPCs()
    {
        if (activeTab == "All")
        {
            return allNPCsWithRelationships
                .OrderByDescending(npc => GetRelationshipPriority(npc))
                .ThenBy(npc => npc.Name);
        }
        
        var tokenType = Enum.Parse<ConnectionType>(activeTab);
        return allNPCsWithRelationships
            .Where(npc => GetNPCTokenCount(npc, tokenType) != 0)
            .OrderByDescending(npc => Math.Abs(GetNPCTokenCount(npc, tokenType)))
            .ThenBy(npc => npc.Name);
    }
    
    private int GetNPCCountForContext(ConnectionType tokenType)
    {
        return allNPCsWithRelationships
            .Count(npc => GetNPCTokenCount(npc, tokenType) != 0);
    }
    
    private bool HasAnyTokens(NPC npc)
    {
        var tokens = TokenManager.GetTokensWithNPC(npc.ID);
        return tokens.Any(kvp => kvp.Value != 0);
    }
    
    private int GetRelationshipPriority(NPC npc)
    {
        // Sort by: Debt first, then special letter ready, then positive tokens
        if (IsNPCInDebt(npc)) return 100;
        if (CanRequestSpecialLetter(npc)) return 50;
        
        var tokens = TokenManager.GetTokensWithNPC(npc.ID);
        return tokens.Sum(kvp => Math.Abs(kvp.Value));
    }
    
    private bool IsNPCInDebt(NPC npc)
    {
        var tokens = TokenManager.GetTokensWithNPC(npc.ID);
        return tokens.Any(kvp => kvp.Value < 0);
    }
    
    private bool CanRequestSpecialLetter(NPC npc)
    {
        return SpecialLetterService.GetAvailableSpecialLetters(npc.ID).Any();
    }
    
    private int GetNPCTokenCount(NPC npc, ConnectionType tokenType)
    {
        var npcTokens = TokenManager.GetTokensWithNPC(npc.ID);
        return npcTokens.GetValueOrDefault(tokenType, 0);
    }
    
    private int GetTotalDebts()
    {
        return allNPCsWithRelationships
            .SelectMany(npc => TokenManager.GetTokensWithNPC(npc.ID))
            .Where(kvp => kvp.Value < 0)
            .Count();
    }
    
    private int GetDebtsForContext(ConnectionType tokenType)
    {
        return allNPCsWithRelationships
            .Count(npc => GetNPCTokenCount(npc, tokenType) < 0);
    }
    
    private int GetSpecialLetterCount()
    {
        return allNPCsWithRelationships
            .Sum(npc => SpecialLetterService.GetAvailableSpecialLetters(npc.ID).Count());
    }
    
    private int GetSpecialLetterReadyCount(ConnectionType tokenType)
    {
        return allNPCsWithRelationships
            .Count(npc => SpecialLetterService.GetAvailableSpecialLetters(npc.ID)
                .Any(option => option.TokenType == tokenType));
    }
    
    private class DebtInfo
    {
        public string NPCName { get; set; }
        public ConnectionType TokenType { get; set; }
        public int Amount { get; set; }
        public int LeveragePosition { get; set; }
    }
    
    private List<DebtInfo> GetAllDebts()
    {
        var debts = new List<DebtInfo>();
        
        foreach (var npc in allNPCsWithRelationships)
        {
            var tokens = TokenManager.GetTokensWithNPC(npc.ID);
            foreach (var kvp in tokens.Where(t => t.Value < 0))
            {
                debts.Add(new DebtInfo
                {
                    NPCName = npc.Name,
                    TokenType = kvp.Key,
                    Amount = kvp.Value,
                    LeveragePosition = GetLeveragePosition(kvp.Key, kvp.Value)
                });
            }
        }
        
        return debts.OrderBy(d => d.LeveragePosition).ToList();
    }
    
    private string GetTokenIcon(ConnectionType type)
    {
        return type switch
        {
            ConnectionType.Trust => "‚ù§Ô∏è",
            ConnectionType.Commerce => "ü™ô",
            ConnectionType.Status => "üëë",
            ConnectionType.Shadow => "üåë",
            _ => "‚ùì"
        };
    }
    
    private string GetHelpTooltip()
    {
        return @"Token Contexts:
‚ù§Ô∏è Trust - Personal relationships, friendships
ü™ô Commerce - Business dealings, trade partnerships  
üëë Status - Social standing, noble connections
üåë Shadow - Underworld contacts, illicit dealings

Token Effects:
‚Ä¢ 5+ tokens: Request special letters
‚Ä¢ 3+ tokens: Better letter positions
‚Ä¢ Negative tokens: Creates leverage (priority queue position)

Special Letters:
‚Ä¢ Trust 5+ ‚Üí Introduction (unlocks new NPCs)
‚Ä¢ Commerce 5+ ‚Üí Access Permit (unlocks locations)
‚Ä¢ Status 5+ ‚Üí Endorsement (temporary bonuses)
‚Ä¢ Shadow 5+ ‚Üí Information (reveals secrets)";
    }
    
    private int GetLeveragePosition(ConnectionType tokenType, int tokenBalance)
    {
        int basePosition = tokenType switch
        {
            ConnectionType.Status => 3,
            ConnectionType.Commerce => 5,
            ConnectionType.Shadow => 5,
            ConnectionType.Trust => 7,
            _ => 8
        };
        
        int leveragePosition = basePosition;
        
        if (tokenBalance < 0)
        {
            leveragePosition += tokenBalance; // Subtracts since negative
        }
        else if (tokenBalance >= 4)
        {
            leveragePosition += 1;
        }
        
        return Math.Max(1, Math.Min(8, leveragePosition));
    }
}