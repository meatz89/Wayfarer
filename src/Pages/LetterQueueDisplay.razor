@* LetterQueueDisplay.razor - Pure presentation layer, no game logic *@
@using Wayfarer.Pages.Components
@inject IGameFacade GameFacade

<div class="letter-queue-container">
    <h3>Letter Queue</h3>

    @* Letter Queue Display *@
    <div class="letter-queue">
        @foreach (var slot in _viewModel.QueueSlots)
        {
            <div class="queue-slot @(slot.IsOccupied ? "occupied" : "empty") @(slot.Position == 1 ? "position-one" : "")">
                <div class="slot-number">[@slot.Position]</div>
                @if (slot.IsOccupied && slot.Letter != null)
                {
                    var letter = slot.Letter;
                    <div class="letter-card @(letter.IsPatronLetter ? "patron-letter" : "")">
                        <div class="letter-header">
                            @if (letter.IsPatronLetter)
                            {
                                <span class="patron-seal" title="Patron Letter">üèµÔ∏è</span>
                            }
                            <span class="token-icon">@letter.TokenIcon</span>
                            <span class="letter-type">@letter.TokenType</span>
                            @if (letter.IsSpecial)
                            {
                                <span class="special-letter-icon" title="@letter.SpecialDescription">@letter.SpecialIcon</span>
                            }
                            @if (!string.IsNullOrEmpty(letter.LeverageIndicator))
                            {
                                <span class="leverage-indicator" title="@letter.LeverageTooltip">@letter.LeverageIndicator</span>
                            }
                        </div>
                        <div class="letter-route">
                            <span class="sender @(letter.IsPatronLetter ? "patron-sender" : "")">@letter.SenderName</span>
                            <span class="arrow">‚Üí</span>
                            <span class="recipient">@letter.RecipientName</span>
                        </div>
                        <div class="letter-details">
                            <div class="deadline @letter.DeadlineClass">
                                @letter.DeadlineIcon @letter.DeadlineDescription
                            </div>
                            <div class="payment">@letter.Payment coins</div>
                            <div class="letter-size" title="@letter.Size letter - Requires @GetRequiredSlots(letter.Size) slot(s)">
                                @letter.SizeIcon @letter.Size
                            </div>
                            <div class="collection-status @(letter.IsCollected ? "collected" : "uncollected")"
                                 title="@(letter.IsCollected ? "Letter in inventory" : "Visit sender to collect physical letter")">
                                @(letter.IsCollected ? "üì¨" : "üì≠") @(letter.IsCollected ? "Collected" : "Not Collected")
                            </div>
                            @if (!string.IsNullOrEmpty(letter.PhysicalConstraints))
                            {
                                <div class="physical-properties" title="@letter.PhysicalConstraints">
                                    @letter.PhysicalIcon
                                </div>
                            }
                        </div>
                        @if (slot.Position == 1 && slot.CanDeliver)
                        {
                            <button class="btn btn-primary btn-sm deliver-btn" @onclick="() => DeliverLetter(slot.Position)">
                                Deliver
                            </button>
                            @if (letter != null)
                            {
                                var deliveryRewards = GetDeliveryRewards(letter);
                                if (deliveryRewards != null && deliveryRewards.Any())
                                {
                                    <TokenTransactionPreview TokenChanges="@deliveryRewards" ShowEffects="true" ShowNetEffect="false" />
                                }
                            }
                        }
                        else if (slot.CanSkip && slot.SkipAction != null)
                        {
                            <button class="btn btn-secondary btn-sm skip-btn"
                                    disabled="@(!slot.SkipAction.HasEnoughTokens)"
                                    @onclick="async () => await SkipLetter(slot.Position)"
                                    title="Skip to position 1">
                                Skip
                            </button>
                            <TokenCostPreview ActionName="Skip"
                                              TokenCost="slot.SkipAction.TotalCost"
                                              TokenType="@(Enum.TryParse<ConnectionType>(slot.SkipAction.TokenType, out var tokenType) ? tokenType : (ConnectionType?)null)"
                                              AvailableTokens="slot.SkipAction.AvailableTokens"
                                              AdditionalInfo="@slot.SkipAction.MultiplierReason" />
                        }
                    </div>
                }
                else
                {
                    <div class="empty-slot">
                        [Empty]
                    </div>
                }
            </div>
        }
    </div>

    @* Queue Status *@
    <div class="queue-status">
        <p>Letters in queue: @_viewModel.Status.LetterCount / @_viewModel.Status.MaxCapacity</p>
        @if (_viewModel.Status.ExpiredCount > 0)
        {
            <p class="deadline-expired">üíÄ @_viewModel.Status.ExpiredCount letter(s) EXPIRED!</p>
        }
        @if (_viewModel.Status.UrgentCount > 0)
        {
            <p class="deadline-urgent">üö® @_viewModel.Status.UrgentCount letter(s) due TODAY!</p>
        }
        @if (_viewModel.Status.WarningCount > 0)
        {
            <p class="deadline-warning">‚ö†Ô∏è @_viewModel.Status.WarningCount letter(s) due in 2 days or less!</p>
        }
    </div>

    @* Queue Management Actions *@
    <div class="queue-actions">
        <h4>Queue Actions</h4>

        <div class="actions-grid">
            @* Morning Swap (only available at dawn) *@
            @if (_viewModel.Actions.CanMorningSwap || _viewModel.CurrentTimeBlock == TimeBlocks.Dawn)
            {
                <div class="action-group">
                    <button class="btn btn-info btn-sm" @onclick="ShowMorningSwap" disabled="@(!_viewModel.Actions.CanMorningSwap)">
                        Morning Swap
                    </button>
                    <TokenCostPreview ActionName="Morning Swap"
                                      TokenCost="0"
                                      TokenType="null"
                                      ShowAvailability="false"
                                      AdditionalInfo="@_viewModel.Actions.MorningSwapReason" />
                    @if (showMorningSwap)
                    {
                        <div class="action-controls">
                            <input type="number" min="1" max="8" @bind="swapPos1" placeholder="From" />
                            <span>‚ÜîÔ∏è</span>
                            <input type="number" min="1" max="8" @bind="swapPos2" placeholder="To" />
                            <button class="btn btn-primary btn-sm" @onclick="PerformMorningSwap">Swap</button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => showMorningSwap = false">√ó</button>
                        </div>
                    }
                </div>
            }

            @* Priority Move *@
            <div class="action-group">
                <button class="btn btn-warning btn-sm" @onclick="ShowPriorityOptions">
                    Priority Move
                </button>
                @if (showPriorityOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="2" max="8" @bind="priorityFromPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformPriority">
                            ‚Üí Slot 1
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showPriorityOptions = false">√ó</button>
                    </div>
                }
            </div>

            @* Extend Deadline *@
            <div class="action-group">
                <button class="btn btn-success btn-sm" @onclick="ShowExtendOptions">
                    Extend Deadline
                </button>
                @if (showExtendOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="1" max="8" @bind="extendPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformExtend">
                            +2 Days
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showExtendOptions = false">√ó</button>
                    </div>
                }
            </div>

            @* Purge Bottom Letter *@
            @if (_viewModel.Actions.HasBottomLetter)
            {
                <div class="action-group">
                    <button class="btn btn-danger btn-sm" @onclick="ShowPurgeOptions">
                        Purge Bottom
                    </button>
                    <TokenCostPreview ActionName="Purge Bottom Letter"
                                      TokenCost="3"
                                      TokenType="null"
                                      AvailableTokens="@_viewModel.Actions.TotalAvailableTokens"
                                      AdditionalInfo="Any combination of tokens" />
                    @if (showPurgeOptions)
                    {
                        <div class="action-controls purge-controls">
                            <p class="purge-instructions">Select 3 tokens total:</p>
                            @foreach (var tokenOption in _viewModel.Actions.PurgeTokenOptions)
                            {
                                <div class="token-input">
                                    <span>@tokenOption.TokenIcon</span>
                                    <input type="number" min="0" max="@tokenOption.Available"
                                           value="@GetPurgeTokenCount(tokenOption.TokenType)"
                                           @onchange="@(e => SetPurgeTokenCount(tokenOption.TokenType, int.Parse(e.Value?.ToString() ?? "0")))" />
                                    <small>(@tokenOption.Available available)</small>
                                </div>
                            }
                            <div class="purge-total">Total selected: @GetTotalPurgeTokens() / 3</div>
                            <button class="btn btn-primary btn-sm" @onclick="async () => await PerformPurge()"
                                    disabled="@(GetTotalPurgeTokens() != 3)">
                                Purge
                            </button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => { showPurgeOptions = false; purgeTokenSelection.Clear(); }">√ó</button>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

</div>

@code {
    @namespace Wayfarer.Pages
    private LetterQueueViewModel _viewModel;

    // UI state for queue manipulation
    private bool showMorningSwap = false;
    private int swapPos1 = 1;
    private int swapPos2 = 2;

    private bool showPurgeOptions = false;
    private Dictionary<string, int> purgeTokenSelection = new Dictionary<string, int>();

    private bool showPriorityOptions = false;
    private int priorityFromPos = 2;

    private bool showExtendOptions = false;
    private int extendPos = 1;

    protected override void OnInitialized()
    {
        RefreshViewModel();
    }

    private void RefreshViewModel()
    {
        _viewModel = GameFacade.GetLetterQueue();
    }

    private async Task DeliverLetter(int position)
    {
        var letterQueue = GameFacade.GetLetterQueue();
        var letter = letterQueue.QueueSlots.FirstOrDefault(s => s.Position == position)?.Letter;
        if (letter != null)
        {
            await GameFacade.DeliverLetterAsync(letter.Id);
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task SkipLetter(int position)
    {
        await GameFacade.SkipLetterAsync(position);
        RefreshViewModel();
        StateHasChanged();
    }

    // Queue manipulation UI methods
    private void ShowMorningSwap() => showMorningSwap = true;
    private void ShowPurgeOptions() => showPurgeOptions = true;
    private void ShowPriorityOptions() => showPriorityOptions = true;
    private void ShowExtendOptions() => showExtendOptions = true;

    private async Task PerformMorningSwap()
    {
        if (await GameFacade.LetterQueueMorningSwapAsync(swapPos1, swapPos2))
        {
            showMorningSwap = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task PerformPriority()
    {
        if (await GameFacade.LetterQueuePriorityMoveAsync(priorityFromPos))
        {
            showPriorityOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task PerformExtend()
    {
        if (await GameFacade.LetterQueueExtendDeadlineAsync(extendPos))
        {
            showExtendOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task PerformPurge()
    {
        await GameFacade.LetterQueuePurgeAsync(purgeTokenSelection);
        showPurgeOptions = false;
        purgeTokenSelection.Clear();
        RefreshViewModel();
        StateHasChanged();
    }

    private int GetPurgeTokenCount(string tokenType)
    {
        return purgeTokenSelection.ContainsKey(tokenType) ? purgeTokenSelection[tokenType] : 0;
    }

    private void SetPurgeTokenCount(string tokenType, int count)
    {
        if (count > 0)
            purgeTokenSelection[tokenType] = count;
        else
            purgeTokenSelection.Remove(tokenType);
    }

    private int GetTotalPurgeTokens()
    {
        return purgeTokenSelection.Values.Sum();
    }

    private int GetRequiredSlots(string size)
    {
        return size switch
        {
            "Small" => 1,
            "Medium" => 2,
            "Large" => 3,
            _ => 1
        };
    }
    
    private List<TokenTransactionPreview.TokenChange> GetDeliveryRewards(LetterViewModel letter)
    {
        var rewards = new List<TokenTransactionPreview.TokenChange>();
        
        // 50% chance to earn a token (show as possible reward)
        rewards.Add(new TokenTransactionPreview.TokenChange
        {
            TokenType = Enum.Parse<ConnectionType>(letter.TokenType),
            Amount = 1,
            NpcName = letter.SenderName,
            Effect = "50% chance on delivery"
        });
        
        // Special letter effects
        if (letter.IsSpecial)
        {
            var specialEffect = GetSpecialDeliveryEffect(letter);
            if (!string.IsNullOrEmpty(specialEffect))
            {
                rewards.Add(new TokenTransactionPreview.TokenChange
                {
                    TokenType = ConnectionType.Trust, // Default, actual type doesn't matter for special effects
                    Amount = 0, // No token change, just effect
                    Effect = specialEffect
                });
            }
        }
        
        return rewards;
    }
    
    private string GetSpecialDeliveryEffect(LetterViewModel letter)
    {
        if (letter.SpecialDescription.Contains("Introduction"))
            return "ü§ù Unlocks new contact";
        if (letter.SpecialDescription.Contains("Access"))
            return "üîì Unlocks location access";
        if (letter.SpecialDescription.Contains("Endorsement"))
            return "‚≠ê Temporary status bonus";
        if (letter.SpecialDescription.Contains("Information"))
            return "üîç Reveals hidden content";
        return null;
    }
}