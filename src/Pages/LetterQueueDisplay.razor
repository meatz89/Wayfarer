@* LetterQueueDisplay.razor - Pure presentation layer, no game logic *@
@using Wayfarer.Pages.Components
@inject GameFacade GameFacade

<div class="letter-queue-container">
    <h3>Letter Queue</h3>
    
    @* Obligation Effects Panel *@
    <ObligationEffectsPanel 
        ActiveObligations="@_obligationSummaries"
        ApproachingThresholds="@_thresholdAlerts" />

    @* Letter Queue Display *@
    <div class="letter-queue">
        @foreach (var slot in _viewModel.QueueSlots)
        {
            <div class="queue-slot @(slot.IsOccupied ? "occupied" : "empty") @(slot.Position == 1 ? "position-one" : "")">
                <div class="slot-number">[@slot.Position]</div>
                @if (slot.IsOccupied && slot.Letter != null)
                {
                    var letter = slot.Letter;
                    <div class="letter-card @(letter.IsPatronLetter ? "patron-letter" : "") @(letter.HasLeverage ? "leveraged" : "") @(letter.ActiveObligationEffects.Any() ? "obligation-affected" : "") @(GetForbiddenClasses(letter))">
                        <div class="letter-header">
                            @if (letter.IsPatronLetter)
                            {
                                <span class="patron-seal" title="Patron Letter">üèµÔ∏è</span>
                            }
                            <span class="token-icon">@letter.TokenIcon</span>
                            <span class="letter-type">@letter.TokenType</span>
                            @if (letter.IsSpecial)
                            {
                                <span class="special-letter-icon" title="@letter.SpecialDescription">@letter.SpecialIcon</span>
                            }
                            @if (!string.IsNullOrEmpty(letter.LeverageIndicator))
                            {
                                <span class="leverage-indicator @letter.LeverageClass" title="@letter.LeverageTooltip">
                                    @letter.LeverageIndicator
                                    @if (letter.HasLeverage)
                                    {
                                        <span class="leverage-strength">√ó@letter.LeverageStrength</span>
                                    }
                                </span>
                            }
                        </div>
                        <div class="letter-route">
                            <span class="sender @(letter.IsPatronLetter ? "patron-sender" : "")">@letter.SenderName</span>
                            <span class="arrow">‚Üí</span>
                            <span class="recipient">@letter.RecipientName</span>
                            @if (letter.HasLeverage && letter.OriginalPosition > 0 && letter.CurrentPosition < letter.OriginalPosition)
                            {
                                <span class="queue-position-change">
                                    <span class="arrow">‚Üë</span>
                                    Jumped from #@letter.OriginalPosition
                                </span>
                            }
                        </div>
                        <div class="letter-details">
                            <div class="deadline @letter.DeadlineClass">
                                @letter.DeadlineIcon @letter.DeadlineDescription
                                @if (letter.HasDeadlineExtension)
                                {
                                    <span class="deadline-extension" title="@letter.DeadlineExtensionSource">
                                        (+@letter.DeadlineExtensionDays days)
                                    </span>
                                }
                            </div>
                            <div class="payment">
                                @letter.Payment coins
                                @if (letter.HasPaymentBonus)
                                {
                                    <span class="payment-bonus" title="@letter.PaymentBonusSource">
                                        (+@letter.PaymentBonusAmount bonus)
                                    </span>
                                }
                            </div>
                            <div class="letter-size" title="@letter.Size letter - Requires @GetRequiredSlots(letter.Size) slot(s)">
                                @letter.SizeIcon @letter.Size
                            </div>
                            <div class="collection-status @(letter.IsCollected ? "collected" : "uncollected")"
                                 title="@(letter.IsCollected ? "Letter in inventory" : "Visit sender to collect physical letter")">
                                @(letter.IsCollected ? "üì¨" : "üì≠") @(letter.IsCollected ? "Collected" : "Not Collected")
                            </div>
                            @if (!string.IsNullOrEmpty(letter.PhysicalConstraints))
                            {
                                <div class="physical-properties" title="@letter.PhysicalConstraints">
                                    @letter.PhysicalIcon
                                </div>
                            }
                        </div>
                        @if (letter.HasLeverage && letter.TokenBalance < 0)
                        {
                            <div class="leverage-details">
                                <div class="leverage-calculation">
                                    <span>Token Debt:</span>
                                    <span class="leverage-effect">@letter.TokenBalance @letter.TokenType tokens</span>
                                </div>
                                <div class="leverage-calculation">
                                    <span>Leverage Strength:</span>
                                    <span class="leverage-effect">√ó@letter.LeverageStrength queue priority</span>
                                </div>
                                @if (letter.OriginalPosition > 0 && letter.CurrentPosition < letter.OriginalPosition)
                                {
                                    <div class="leverage-calculation">
                                        <span>Queue Jump:</span>
                                        <span class="leverage-effect">Moved @(letter.OriginalPosition - letter.CurrentPosition) positions forward</span>
                                    </div>
                                }
                            </div>
                        }
                        @if (letter.ActiveObligationEffects.Any())
                        {
                            <div class="obligation-effects-summary">
                                <div class="effects-header">
                                    <span class="effects-icon">‚öñÔ∏è</span>
                                    <span class="effects-title">Active Obligation Effects:</span>
                                </div>
                                <ul class="effects-list">
                                    @foreach (var effect in letter.ActiveObligationEffects)
                                    {
                                        <li class="effect-item">@effect</li>
                                    }
                                </ul>
                            </div>
                        }
                        @if (slot.Position == 1 && slot.CanDeliver)
                        {
                            <button class="btn btn-primary btn-sm deliver-btn" @onclick="() => DeliverLetter(slot.Position)">
                                Deliver
                            </button>
                            @if (letter != null)
                            {
                                var deliveryRewards = GetDeliveryRewards(letter);
                                if (deliveryRewards != null && deliveryRewards.Any())
                                {
                                    <TokenTransactionPreview TokenChanges="@deliveryRewards" ShowEffects="true" ShowNetEffect="false" />
                                }
                            }
                        }
                        else if (slot.CanSkip && slot.SkipAction != null)
                        {
                            <button class="btn btn-secondary btn-sm skip-btn"
                                    disabled="@(!slot.SkipAction.HasEnoughTokens)"
                                    @onclick="async () => await SkipLetter(slot.Position)"
                                    title="Skip to position 1">
                                Skip
                            </button>
                            <TokenCostPreview ActionName="Skip"
                                              TokenCost="slot.SkipAction.TotalCost"
                                              TokenType="@(Enum.TryParse<ConnectionType>(slot.SkipAction.TokenType, out var tokenType) ? tokenType : (ConnectionType?)null)"
                                              AvailableTokens="slot.SkipAction.AvailableTokens"
                                              AdditionalInfo="@slot.SkipAction.MultiplierReason" />
                        }
                    </div>
                }
                else
                {
                    <div class="empty-slot">
                        [Empty]
                    </div>
                }
            </div>
        }
    </div>

    @* Queue Management Actions *@
    <div class="queue-actions">
        <h4>Queue Management</h4>
        <div class="actions-grid">
            @* Morning Swap (Dawn only) *@
            <div class="action-group">
                <h5>Morning Swap</h5>
                @if (GameFacade.GetTimeInfo().timeBlock == TimeBlocks.Dawn)
                {
                    @if (!_hasMorningSwapped)
                    {
                        <div class="action-controls">
                            <input type="number" min="1" max="8" @bind="_swapPosition1" placeholder="Pos 1" />
                            <span>‚Üî</span>
                            <input type="number" min="1" max="8" @bind="_swapPosition2" placeholder="Pos 2" />
                            <button class="btn btn-primary btn-sm" 
                                    disabled="@(_isProcessing || _swapPosition1 < 1 || _swapPosition1 > 8 || _swapPosition2 < 1 || _swapPosition2 > 8)"
                                    @onclick="PerformMorningSwap">
                                Swap
                            </button>
                        </div>
                        <small class="text-muted">Free swap (once per dawn)</small>
                    }
                    else
                    {
                        <p class="text-muted">Already used today</p>
                    }
                }
                else
                {
                    <p class="text-muted">Available at Dawn only</p>
                }
            </div>
            
            @* Priority Move *@
            <div class="action-group">
                <h5>Priority Move</h5>
                @if (_viewModel.QueueSlots[0].Letter == null)
                {
                    <div class="action-controls">
                        <input type="number" min="2" max="8" @bind="_priorityMovePosition" placeholder="Position" />
                        <button class="btn btn-secondary btn-sm"
                                disabled="@(_isProcessing || _priorityMovePosition < 2 || _priorityMovePosition > 8)"
                                @onclick="ShowPriorityMoveConfirm">
                            Move to #1
                        </button>
                    </div>
                    @if (_showPriorityConfirm && _selectedLetter != null)
                    {
                        <div class="cost-preview">
                            <TokenCostPreview ActionName="Priority Move"
                                              TokenCost="5"
                                              TokenType="@(Enum.TryParse<ConnectionType>(_selectedLetter.TokenType, out var pType) ? pType : (ConnectionType?)null)"
                                              AvailableTokens="@GetTokenCount(Enum.Parse<ConnectionType>(_selectedLetter.TokenType))"
                                              AdditionalInfo="Move to position 1" />
                            <button class="btn btn-primary btn-sm" @onclick="PerformPriorityMove">Confirm</button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => _showPriorityConfirm = false">Cancel</button>
                        </div>
                    }
                }
                else
                {
                    <p class="text-muted">Position 1 must be empty</p>
                }
            </div>
            
            @* Extend Deadline *@
            <div class="action-group">
                <h5>Extend Deadline</h5>
                <div class="action-controls">
                    <input type="number" min="1" max="8" @bind="_extendDeadlinePosition" placeholder="Position" />
                    <button class="btn btn-info btn-sm"
                            disabled="@(_isProcessing || _extendDeadlinePosition < 1 || _extendDeadlinePosition > 8)"
                            @onclick="ShowExtendDeadlineConfirm">
                        +2 Days
                    </button>
                </div>
                @if (_showExtendConfirm && _selectedLetter != null)
                {
                    <div class="cost-preview">
                        <TokenCostPreview ActionName="Extend Deadline"
                                          TokenCost="2"
                                          TokenType="@(Enum.TryParse<ConnectionType>(_selectedLetter.TokenType, out var eType) ? eType : (ConnectionType?)null)"
                                          AvailableTokens="@GetTokenCount(Enum.Parse<ConnectionType>(_selectedLetter.TokenType))"
                                          AdditionalInfo="+2 days to deadline" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformExtendDeadline">Confirm</button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => _showExtendConfirm = false">Cancel</button>
                    </div>
                }
            </div>
            
            @* Purge Bottom Letter *@
            <div class="action-group">
                <h5>Purge Bottom Letter</h5>
                @if (_viewModel.QueueSlots[7].Letter != null)
                {
                    <p class="text-warning">Remove: @_viewModel.QueueSlots[7].Letter.SenderName ‚Üí @_viewModel.QueueSlots[7].Letter.RecipientName</p>
                    <div class="action-controls purge-controls">
                        @foreach (var tokenType in Enum.GetValues<ConnectionType>())
                        {
                            <div class="token-input">
                                <span class="token-icon">@GetTokenIcon(tokenType)</span>
                                <span>@tokenType</span>
                                <input type="number" min="0" max="3" value="0"
                                       @onchange="(e) => UpdatePurgeTokens(tokenType, e)" />
                                <span class="available">(@GetTokenCount(tokenType) available)</span>
                            </div>
                        }
                        <button class="btn btn-danger btn-sm"
                                disabled="@(_isProcessing || _purgeTokenTotal != 3)"
                                @onclick="ShowPurgeConfirm">
                            Purge (Cost: 3 tokens)
                        </button>
                        @if (_showPurgeConfirm)
                        {
                            <div class="confirm-dialog">
                                <p class="text-danger">This will trigger a difficult conversation!</p>
                                <button class="btn btn-danger btn-sm" @onclick="PerformPurge">Confirm Purge</button>
                                <button class="btn btn-secondary btn-sm" @onclick="() => _showPurgeConfirm = false">Cancel</button>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <p class="text-muted">No letter at position 8</p>
                }
            </div>
        </div>
    </div>

    @* Queue Status *@
    <div class="queue-status">
        <p>Letters in queue: @_viewModel.Status.LetterCount / @_viewModel.Status.MaxCapacity</p>
        @if (_viewModel.Status.ExpiredCount > 0)
        {
            <p class="deadline-expired">üíÄ @_viewModel.Status.ExpiredCount letter(s) EXPIRED!</p>
        }
        @if (_viewModel.Status.UrgentCount > 0)
        {
            <p class="deadline-urgent">üö® @_viewModel.Status.UrgentCount letter(s) due TODAY!</p>
        }
        @if (_viewModel.Status.WarningCount > 0)
        {
            <p class="deadline-warning">‚ö†Ô∏è @_viewModel.Status.WarningCount letter(s) due in 2 days or less!</p>
        }
    </div>

    @* Queue Management Actions *@
    <div class="queue-actions">
        <h4>Queue Actions</h4>

        <div class="actions-grid">
            @* Morning Swap (only available at dawn) *@
            @if (_viewModel.Actions.CanMorningSwap || _viewModel.CurrentTimeBlock == TimeBlocks.Dawn)
            {
                <div class="action-group">
                    <button class="btn btn-info btn-sm" @onclick="ShowMorningSwap" disabled="@(!_viewModel.Actions.CanMorningSwap)">
                        Morning Swap
                    </button>
                    <TokenCostPreview ActionName="Morning Swap"
                                      TokenCost="0"
                                      TokenType="null"
                                      ShowAvailability="false"
                                      AdditionalInfo="@_viewModel.Actions.MorningSwapReason" />
                    @if (showMorningSwap)
                    {
                        <div class="action-controls">
                            <input type="number" min="1" max="8" @bind="swapPos1" placeholder="From" />
                            <span>‚ÜîÔ∏è</span>
                            <input type="number" min="1" max="8" @bind="swapPos2" placeholder="To" />
                            <button class="btn btn-primary btn-sm" @onclick="PerformMorningSwap">Swap</button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => showMorningSwap = false">√ó</button>
                        </div>
                    }
                </div>
            }

            @* Priority Move *@
            <div class="action-group">
                <button class="btn btn-warning btn-sm" @onclick="ShowPriorityOptions">
                    Priority Move
                </button>
                @if (showPriorityOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="2" max="8" @bind="priorityFromPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformPriority">
                            ‚Üí Slot 1
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showPriorityOptions = false">√ó</button>
                    </div>
                }
            </div>

            @* Extend Deadline *@
            <div class="action-group">
                <button class="btn btn-success btn-sm" @onclick="ShowExtendOptions">
                    Extend Deadline
                </button>
                @if (showExtendOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="1" max="8" @bind="extendPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformExtend">
                            +2 Days
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showExtendOptions = false">√ó</button>
                    </div>
                }
            </div>

            @* Purge Bottom Letter *@
            @if (_viewModel.Actions.HasBottomLetter)
            {
                <div class="action-group">
                    <button class="btn btn-danger btn-sm" @onclick="ShowPurgeOptions">
                        Purge Bottom
                    </button>
                    <TokenCostPreview ActionName="Purge Bottom Letter"
                                      TokenCost="3"
                                      TokenType="null"
                                      AvailableTokens="@_viewModel.Actions.TotalAvailableTokens"
                                      AdditionalInfo="Any combination of tokens" />
                    @if (showPurgeOptions)
                    {
                        <div class="action-controls purge-controls">
                            <p class="purge-instructions">Select 3 tokens total:</p>
                            @foreach (var tokenOption in _viewModel.Actions.PurgeTokenOptions)
                            {
                                <div class="token-input">
                                    <span>@tokenOption.TokenIcon</span>
                                    <input type="number" min="0" max="@tokenOption.Available"
                                           value="@GetPurgeTokenCount(tokenOption.TokenType)"
                                           @onchange="@(e => SetPurgeTokenCount(tokenOption.TokenType, int.Parse(e.Value?.ToString() ?? "0")))" />
                                    <small>(@tokenOption.Available available)</small>
                                </div>
                            }
                            <div class="purge-total">Total selected: @GetTotalPurgeTokens() / 3</div>
                            <button class="btn btn-primary btn-sm" @onclick="async () => await PerformPurge()"
                                    disabled="@(GetTotalPurgeTokens() != 3)">
                                Purge
                            </button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => { showPurgeOptions = false; purgeTokenSelection.Clear(); }">√ó</button>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

</div>

@code {
    @namespace Wayfarer.Pages
    private LetterQueueViewModel _viewModel;
    private List<ObligationEffectsPanel.ObligationSummary> _obligationSummaries = new();
    private List<ObligationEffectsPanel.ThresholdAlert> _thresholdAlerts = new();

    // UI state for queue manipulation
    private bool showMorningSwap = false;
    private int swapPos1 = 1;
    private int swapPos2 = 2;

    private bool showPurgeOptions = false;
    private Dictionary<string, int> purgeTokenSelection = new Dictionary<string, int>();

    private bool showPriorityOptions = false;
    private int priorityFromPos = 2;

    private bool showExtendOptions = false;
    private int extendPos = 1;
    
    // New state for improved UI
    private bool _isProcessing = false;
    private int _swapPosition1 = 1;
    private int _swapPosition2 = 2;
    private int _priorityMovePosition = 2;
    private int _extendDeadlinePosition = 1;
    private bool _hasMorningSwapped = false;
    private bool _showPriorityConfirm = false;
    private bool _showExtendConfirm = false;
    private bool _showPurgeConfirm = false;
    private LetterViewModel _selectedLetter;
    private Dictionary<ConnectionType, int> _purgeTokens = new();
    private int _purgeTokenTotal = 0;

    protected override void OnInitialized()
    {
        RefreshViewModel();
        var player = GameFacade.GetPlayer();
        var timeInfo = GameFacade.GetTimeInfo();
        _hasMorningSwapped = player.LastMorningSwapDay == timeInfo.currentDay;
    }

    private void RefreshViewModel()
    {
        _viewModel = GameFacade.GetLetterQueue();
        LoadObligationData();
    }

    private async Task DeliverLetter(int position)
    {
        var letterQueue = GameFacade.GetLetterQueue();
        var letter = letterQueue.QueueSlots.FirstOrDefault(s => s.Position == position)?.Letter;
        if (letter != null)
        {
            await GameFacade.DeliverLetterAsync(letter.Id);
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task SkipLetter(int position)
    {
        await GameFacade.SkipLetterAsync(position);
        RefreshViewModel();
        StateHasChanged();
    }

    // Queue manipulation UI methods
    private void ShowMorningSwap() => showMorningSwap = true;
    private void ShowPurgeOptions() => showPurgeOptions = true;
    private void ShowPriorityOptions() => showPriorityOptions = true;
    private void ShowExtendOptions() => showExtendOptions = true;

    private async Task PerformMorningSwap()
    {
        _isProcessing = true;
        if (await GameFacade.LetterQueueMorningSwapAsync(_swapPosition1, _swapPosition2))
        {
            _hasMorningSwapped = true;
            showMorningSwap = false;
            RefreshViewModel();
            StateHasChanged();
        }
        _isProcessing = false;
    }

    private async Task PerformPriority()
    {
        if (await GameFacade.LetterQueuePriorityMoveAsync(priorityFromPos))
        {
            showPriorityOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task PerformExtend()
    {
        if (await GameFacade.LetterQueueExtendDeadlineAsync(extendPos))
        {
            showExtendOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }

    private async Task PerformPurge()
    {
        _isProcessing = true;
        _showPurgeConfirm = false;
        
        // Convert token dictionary to list of TokenSelection
        var tokenSelections = new List<TokenSelection>();
        foreach (var kvp in _purgeTokens)
        {
            tokenSelections.Add(new TokenSelection
            {
                TokenType = kvp.Key,
                Count = kvp.Value
            });
        }
            
        await GameFacade.LetterQueuePurgeAsync(tokenSelections);
        showPurgeOptions = false;
        purgeTokenSelection.Clear();
        _purgeTokens.Clear();
        _purgeTokenTotal = 0;
        RefreshViewModel();
        _isProcessing = false;
        StateHasChanged();
    }

    private int GetPurgeTokenCount(string tokenType)
    {
        return purgeTokenSelection.ContainsKey(tokenType) ? purgeTokenSelection[tokenType] : 0;
    }

    private void SetPurgeTokenCount(string tokenType, int count)
    {
        if (count > 0)
            purgeTokenSelection[tokenType] = count;
        else
            purgeTokenSelection.Remove(tokenType);
    }

    private int GetTotalPurgeTokens()
    {
        return purgeTokenSelection.Values.Sum();
    }

    private int GetRequiredSlots(string size)
    {
        return size switch
        {
            "Small" => 1,
            "Medium" => 2,
            "Large" => 3,
            _ => 1
        };
    }
    
    private List<Wayfarer.Models.TokenChange> GetDeliveryRewards(LetterViewModel letter)
    {
        var rewards = new List<Wayfarer.Models.TokenChange>();
        
        // 50% chance to earn a token (show as possible reward)
        rewards.Add(new Wayfarer.Models.TokenChange
        {
            TokenType = Enum.Parse<ConnectionType>(letter.TokenType),
            Amount = 1,
            NpcName = letter.SenderName,
            Effect = "50% chance on delivery"
        });
        
        // Special letter effects
        if (letter.IsSpecial)
        {
            var specialEffect = GetSpecialDeliveryEffect(letter);
            if (!string.IsNullOrEmpty(specialEffect))
            {
                rewards.Add(new Wayfarer.Models.TokenChange
                {
                    TokenType = ConnectionType.Trust, // Default, actual type doesn't matter for special effects
                    Amount = 0, // No token change, just effect
                    Effect = specialEffect
                });
            }
        }
        
        return rewards;
    }
    
    private string GetSpecialDeliveryEffect(LetterViewModel letter)
    {
        if (letter.SpecialDescription.Contains("Introduction"))
            return "ü§ù Unlocks new contact";
        if (letter.SpecialDescription.Contains("Access"))
            return "üîì Unlocks location access";
        if (letter.SpecialDescription.Contains("Endorsement"))
            return "‚≠ê Temporary status bonus";
        if (letter.SpecialDescription.Contains("Information"))
            return "üîç Reveals hidden content";
        return null;
    }
    
    // New methods for improved queue management UI
    
    private void ShowPriorityMoveConfirm()
    {
        if (_priorityMovePosition >= 2 && _priorityMovePosition <= 8)
        {
            _selectedLetter = _viewModel.QueueSlots[_priorityMovePosition - 1].Letter;
            _showPriorityConfirm = true;
        }
    }
    
    private async Task PerformPriorityMove()
    {
        _isProcessing = true;
        _showPriorityConfirm = false;
        await GameFacade.LetterQueuePriorityMoveAsync(_priorityMovePosition);
        RefreshViewModel();
        _isProcessing = false;
        StateHasChanged();
    }
    
    private void ShowExtendDeadlineConfirm()
    {
        if (_extendDeadlinePosition >= 1 && _extendDeadlinePosition <= 8)
        {
            _selectedLetter = _viewModel.QueueSlots[_extendDeadlinePosition - 1].Letter;
            if (_selectedLetter != null)
            {
                _showExtendConfirm = true;
            }
        }
    }
    
    private async Task PerformExtendDeadline()
    {
        _isProcessing = true;
        _showExtendConfirm = false;
        await GameFacade.LetterQueueExtendDeadlineAsync(_extendDeadlinePosition);
        RefreshViewModel();
        _isProcessing = false;
        StateHasChanged();
    }
    
    private void UpdatePurgeTokens(ConnectionType tokenType, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int count))
        {
            if (count > 0)
                _purgeTokens[tokenType] = count;
            else
                _purgeTokens.Remove(tokenType);
            
            _purgeTokenTotal = _purgeTokens.Values.Sum();
        }
    }
    
    private void ShowPurgeConfirm()
    {
        if (_purgeTokenTotal == 3)
        {
            _showPurgeConfirm = true;
        }
    }
    
    
    private int GetTokenCount(ConnectionType tokenType)
    {
        var tokens = GameFacade.GetPlayer().ConnectionTokens;
        return tokens.TryGetValue(tokenType, out var count) ? count : 0;
    }
    
    private string GetTokenIcon(ConnectionType tokenType)
    {
        return tokenType switch
        {
            ConnectionType.Trust => "üíù",
            ConnectionType.Commerce => "üí∞",
            ConnectionType.Status => "üëë",
            ConnectionType.Shadow => "üåô",
            _ => "ü™ô"
        };
    }
    
    private string GetTokenIcon(string tokenType)
    {
        if (Enum.TryParse<ConnectionType>(tokenType, out var type))
        {
            return GetTokenIcon(type);
        }
        return "ü™ô";
    }
    
    private void LoadObligationData()
    {
        _obligationSummaries.Clear();
        _thresholdAlerts.Clear();
        
        var obligationsData = GameFacade.GetDetailedObligations();
        
        // Convert active obligations to summaries
        foreach (var obligation in obligationsData.ActiveObligations)
        {
            var summary = new ObligationEffectsPanel.ObligationSummary
            {
                Name = obligation.Name,
                Effects = new List<string>(),
                AffectedLetterTypes = new List<string>(),
                ForcedLetterCountdown = obligation.DaysUntilForcedLetter
            };
            
            // Add benefit effects
            summary.Effects.AddRange(obligation.BenefitDescriptions);
            
            // Add constraint effects  
            summary.Effects.AddRange(obligation.ConstraintDescriptions);
            
            // Add affected letter types
            if (obligation.RelatedTokenType.HasValue)
            {
                summary.AffectedLetterTypes.Add(obligation.RelatedTokenType.Value.ToString());
            }
            
            _obligationSummaries.Add(summary);
        }
        
        // Convert threshold warnings to alerts
        foreach (var warning in obligationsData.ThresholdWarnings)
        {
            _thresholdAlerts.Add(new ObligationEffectsPanel.ThresholdAlert
            {
                NPCName = warning.NPCName,
                TokenType = warning.TokenType?.ToString() ?? "",
                CurrentTokens = warning.CurrentValue,
                ThresholdValue = warning.ThresholdValue,
                TriggerDescription = warning.Message,
                IsPositive = warning.WarningType == "HighTokens"
            });
        }
    }
    
    private string GetForbiddenClasses(LetterViewModel letter)
    {
        var classes = new List<string>();
        
        if (letter.ActiveObligationEffects.Any(e => e.Contains("Cannot refuse")))
            classes.Add("cannot-refuse");
            
        if (letter.ActiveObligationEffects.Any(e => e.Contains("Cannot purge")))
            classes.Add("cannot-purge");
            
        return string.Join(" ", classes);
    }
}