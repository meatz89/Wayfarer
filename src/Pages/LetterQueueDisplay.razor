@using Wayfarer.GameState
@using Wayfarer.Content

@inject GameWorld GameWorld
@inject LetterQueueManager LetterQueueManager
@inject ConnectionTokenManager TokenManager
@inject MessageSystem MessageSystem
@inject StandingObligationRepository ObligationRepository
@inject StandingObligationManager ObligationManager

<div class="letter-queue-container">
    <h3>Letter Queue</h3>
    
    @* Token Display *@
    <div class="token-display">
        <h4>Connection Tokens</h4>
        <div class="token-list">
            @foreach (var tokenType in Enum.GetValues<ConnectionType>())
            {
                var count = TokenManager.GetTokenCount(tokenType);
                <div class="token-item">
                    <span class="token-icon">@GetTokenIcon(tokenType)</span>
                    <span class="token-type">@tokenType</span>
                    <span class="token-count">@count</span>
                </div>
            }
        </div>
    </div>
    
    @* Letter Queue Display *@
    <div class="letter-queue">
        @for (int position = 1; position <= 8; position++)
        {
            var letter = LetterQueueManager.GetLetterAt(position);
            <div class="queue-slot @(letter != null ? "occupied" : "empty") @(position == 1 ? "position-one" : "")">
                <div class="slot-number">[@position]</div>
                @if (letter != null)
                {
                    <div class="letter-card">
                        <div class="letter-header">
                            <span class="token-icon">@letter.GetTokenTypeIcon()</span>
                            <span class="letter-type">@letter.TokenType</span>
                        </div>
                        <div class="letter-route">
                            <span class="sender">@letter.SenderName</span>
                            <span class="arrow">‚Üí</span>
                            <span class="recipient">@letter.RecipientName</span>
                        </div>
                        <div class="letter-details">
                            <div class="deadline @GetDeadlineWarningClass(letter.Deadline)">
                                @GetDeadlineWarningIcon(letter.Deadline) @GetDeadlineDescription(letter.Deadline)
                            </div>
                            <div class="payment">@letter.Payment coins</div>
                        </div>
                        @if (position == 1)
                        {
                            <button class="btn btn-primary btn-sm deliver-btn" @onclick="() => DeliverLetter(letter)">
                                Deliver
                            </button>
                        }
                        else if (position > 1 && LetterQueueManager.GetLetterAt(1) == null)
                        {
                            var baseCost = position - 1;
                            var multiplier = ObligationManager.CalculateSkipCostMultiplier(letter);
                            var tokenCost = baseCost * multiplier;
                            var hasEnoughTokens = TokenManager.HasTokens(letter.TokenType, tokenCost);
                            
                            <button class="btn btn-secondary btn-sm skip-btn" 
                                    disabled="@(!hasEnoughTokens)" 
                                    @onclick="() => SkipLetter(letter)">
                                Skip (@tokenCost @letter.TokenType)
                                @if (multiplier > 1)
                                {
                                    <small class="obligation-cost-note">(x@multiplier from obligations)</small>
                                }
                            </button>
                        }
                    </div>
                }
                else
                {
                    <div class="empty-slot">
                        [Empty]
                    </div>
                }
            </div>
        }
    </div>
    
    @* Queue Status *@
    <div class="queue-status">
        <p>Letters in queue: @LetterQueueManager.GetLetterCount() / 8</p>
        @{
            var expiredLetters = LetterQueueManager.GetExpiringLetters(0);
            var urgentLetters = LetterQueueManager.GetExpiringLetters(1);
            var warningLetters = LetterQueueManager.GetExpiringLetters(2);
            
            if (expiredLetters.Any())
            {
                <p class="deadline-expired">üíÄ @expiredLetters.Length letter(s) EXPIRED!</p>
            }
            if (urgentLetters.Any())
            {
                <p class="deadline-urgent">üö® @urgentLetters.Length letter(s) due TODAY!</p>
            }
            if (warningLetters.Any())
            {
                <p class="deadline-warning">‚ö†Ô∏è @warningLetters.Length letter(s) due in 2 days or less!</p>
            }
        }
    </div>
    
    @* Queue Manipulation Actions *@
    <div class="queue-actions">
        <h4>Queue Management</h4>
        
        @* Morning Swap (only available at dawn) *@
        @if (GameWorld.TimeManager.GetCurrentTimeBlock() == TimeBlocks.Dawn)
        {
            <div class="action-section">
                <button class="btn btn-info" @onclick="ShowMorningSwap" disabled="@(GameWorld.GetPlayer().LastMorningSwapDay == GameWorld.CurrentDay)">
                    Morning Swap (Free)
                    @if (GameWorld.GetPlayer().LastMorningSwapDay == GameWorld.CurrentDay)
                    {
                        <span class="disabled-reason">- Already used today</span>
                    }
                </button>
                @if (showMorningSwap)
                {
                    <div class="swap-controls">
                        <label>Swap positions:</label>
                        <input type="number" min="1" max="8" @bind="swapPos1" />
                        <span>‚ÜîÔ∏è</span>
                        <input type="number" min="1" max="8" @bind="swapPos2" />
                        <button class="btn btn-sm btn-primary" @onclick="PerformMorningSwap">Swap</button>
                        <button class="btn btn-sm btn-secondary" @onclick="() => showMorningSwap = false">Cancel</button>
                    </div>
                }
            </div>
        }
        
        @* Purge Bottom Letter *@
        @if (LetterQueueManager.GetLetterAt(8) != null)
        {
            <div class="action-section">
                <button class="btn btn-danger" @onclick="ShowPurgeOptions">
                    Purge Bottom Letter (3 any tokens)
                </button>
                @if (showPurgeOptions)
                {
                    <div class="purge-controls">
                        <p>Select 3 tokens to spend:</p>
                        @foreach (var tokenType in Enum.GetValues<ConnectionType>())
                        {
                            var available = TokenManager.GetTokenCount(tokenType);
                            if (available > 0)
                            {
                                <div class="token-selector">
                                    <span>@GetTokenIcon(tokenType) @tokenType:</span>
                                    <input type="number" min="0" max="@available" value="@GetPurgeTokenCount(tokenType)" 
                                           @onchange="@(e => SetPurgeTokenCount(tokenType, int.Parse(e.Value?.ToString() ?? "0")))" />
                                    <span>(Have @available)</span>
                                </div>
                            }
                        }
                        <button class="btn btn-sm btn-primary" @onclick="PerformPurge" disabled="@(GetTotalPurgeTokens() != 3)">
                            Purge (@GetTotalPurgeTokens()/3 selected)
                        </button>
                        <button class="btn btn-sm btn-secondary" @onclick="() => { showPurgeOptions = false; purgeTokenSelection.Clear(); }">Cancel</button>
                    </div>
                }
            </div>
        }
        
        @* Priority Move *@
        <div class="action-section">
            <button class="btn btn-warning" @onclick="ShowPriorityOptions">
                Priority Move (5 matching tokens)
            </button>
            @if (showPriorityOptions)
            {
                <div class="priority-controls">
                    <label>Move letter from position:</label>
                    <input type="number" min="2" max="8" @bind="priorityFromPos" />
                    <button class="btn btn-sm btn-primary" @onclick="PerformPriority" disabled="@(!CanPerformPriority())">
                        Move to Position 1
                    </button>
                    <button class="btn btn-sm btn-secondary" @onclick="() => showPriorityOptions = false">Cancel</button>
                    @if (priorityFromPos >= 2 && priorityFromPos <= 8)
                    {
                        var letter = LetterQueueManager.GetLetterAt(priorityFromPos);
                        if (letter != null)
                        {
                            <p class="cost-info">Cost: 5 @GetTokenIcon(letter.TokenType) @letter.TokenType tokens (Have @TokenManager.GetTokenCount(letter.TokenType))</p>
                        }
                    }
                </div>
            }
        </div>
        
        @* Extend Deadline *@
        <div class="action-section">
            <button class="btn btn-success" @onclick="ShowExtendOptions">
                Extend Deadline (2 matching tokens)
            </button>
            @if (showExtendOptions)
            {
                <div class="extend-controls">
                    <label>Extend deadline for position:</label>
                    <input type="number" min="1" max="8" @bind="extendPos" />
                    <button class="btn btn-sm btn-primary" @onclick="PerformExtend" disabled="@(!CanPerformExtend())">
                        +2 Days
                    </button>
                    <button class="btn btn-sm btn-secondary" @onclick="() => showExtendOptions = false">Cancel</button>
                    @if (extendPos >= 1 && extendPos <= 8)
                    {
                        var letter = LetterQueueManager.GetLetterAt(extendPos);
                        if (letter != null)
                        {
                            <p class="cost-info">Cost: 2 @GetTokenIcon(letter.TokenType) @letter.TokenType tokens (Have @TokenManager.GetTokenCount(letter.TokenType))</p>
                        }
                    }
                </div>
            }
        </div>
    </div>
    
    @* Standing Obligations Panel *@
    <div class="obligations-panel">
        <h4>Active Obligations</h4>
        @{
            var activeObligations = ObligationRepository.GetPlayerObligations();
        }
        @if (!activeObligations.Any())
        {
            <div class="no-obligations-message">
                <p>No active standing obligations</p>
                <small>Visit the Obligations screen to see available commitments</small>
            </div>
        }
        else
        {
            <div class="obligations-list">
                @foreach (var obligation in activeObligations.Take(3))
                {
                    <div class="obligation-summary @GetObligationSummaryClass(obligation)">
                        <div class="obligation-name">@obligation.Name</div>
                        <div class="obligation-effect">
                            @if (obligation.BenefitEffects.Any())
                            {
                                <span class="benefit">‚úì @GetPrimaryBenefit(obligation)</span>
                            }
                            @if (obligation.ConstraintEffects.Any())
                            {
                                <span class="constraint">‚ö†Ô∏è @GetPrimaryConstraint(obligation)</span>
                            }
                        </div>
                        @if (ShouldShowForcedWarning(obligation))
                        {
                            <div class="forced-warning">
                                <span class="warning-icon">‚è∞</span>
                                <span class="warning-text">Forced letter in @GetDaysUntilForced(obligation) days</span>
                            </div>
                        }
                    </div>
                }
                @if (activeObligations.Count > 3)
                {
                    <div class="more-obligations">
                        <small>+@(activeObligations.Count - 3) more obligations</small>
                    </div>
                }
            </div>
        }
    </div>
</div>

@code {
    // UI state for queue manipulation
    private bool showMorningSwap = false;
    private int swapPos1 = 1;
    private int swapPos2 = 2;
    
    private bool showPurgeOptions = false;
    private Dictionary<ConnectionType, int> purgeTokenSelection = new Dictionary<ConnectionType, int>();
    
    private bool showPriorityOptions = false;
    private int priorityFromPos = 2;
    
    private bool showExtendOptions = false;
    private int extendPos = 1;
    
    protected override void OnInitialized()
    {
        // Add test letters for minimal POC demonstration
        if (LetterQueueManager.GetLetterCount() == 0)
        {
            AddTestLetters();
        }
    }
    
    private void AddTestLetters()
    {
        // Create a few test letters to show in the queue
        var testLetters = new[]
        {
            new Letter 
            { 
                SenderName = "Elena", 
                RecipientName = "Marcus", 
                Deadline = 3, 
                Payment = 5, 
                TokenType = ConnectionType.Trust 
            },
            new Letter 
            { 
                SenderName = "Lord Ashford", 
                RecipientName = "Lady Winters", 
                Deadline = 1, 
                Payment = 12, 
                TokenType = ConnectionType.Noble 
            },
            new Letter 
            { 
                SenderName = "Merchant Guild", 
                RecipientName = "Dock Master", 
                Deadline = 5, 
                Payment = 8, 
                TokenType = ConnectionType.Trade 
            },
            new Letter 
            { 
                SenderName = "Anonymous", 
                RecipientName = "The Fence", 
                Deadline = 2, 
                Payment = 15, 
                TokenType = ConnectionType.Shadow 
            }
        };
        
        foreach (var letter in testLetters)
        {
            LetterQueueManager.AddLetterToFirstEmpty(letter);
        }
        
        // Add some test tokens
        TokenManager.AddTokens(ConnectionType.Trust, 3);
        TokenManager.AddTokens(ConnectionType.Trade, 2);
        TokenManager.AddTokens(ConnectionType.Noble, 1);
    }
    
    private string GetTokenIcon(ConnectionType type)
    {
        return type switch
        {
            ConnectionType.Trust => "‚ù§Ô∏è",
            ConnectionType.Trade => "ü™ô",
            ConnectionType.Noble => "üëë",
            ConnectionType.Common => "üç∫",
            ConnectionType.Shadow => "üåë",
            _ => "‚ùì"
        };
    }
    
    private void DeliverLetter(Letter letter)
    {
        if (letter == null) return;
        
        // Calculate payment with obligation bonuses
        var player = GameWorld.GetPlayer();
        int basePayment = letter.Payment;
        int bonusPayment = ObligationManager.CalculateTotalCoinBonus(letter);
        int totalPayment = basePayment + bonusPayment;
        
        player.ModifyCoins(totalPayment);
        
        // 50% chance to earn a token
        var random = new Random();
        bool earnedToken = random.Next(2) == 0;
        if (earnedToken)
        {
            TokenManager.AddTokens(letter.TokenType, 1);
        }
        
        // Track delivery in letter history
        LetterQueueManager.RecordLetterDelivery(letter);
        
        // Remove from queue
        LetterQueueManager.RemoveLetterFromQueue(1);
        
        // Show feedback using MessageSystem
        string message = $"Delivered letter! Earned {totalPayment} coins";
        if (bonusPayment > 0)
        {
            message += $" (base {basePayment} + {bonusPayment} bonus)";
        }
        if (earnedToken)
        {
            message += $" and 1 {letter.TokenType} token!";
        }
        MessageSystem.AddSystemMessage(message, SystemMessageTypes.Success);
        
        StateHasChanged();
    }
    
    private void SkipLetter(Letter letter)
    {
        if (letter == null) return;
        
        int tokenCost = letter.QueuePosition - 1;
        
        // Attempt to skip the letter
        bool success = LetterQueueManager.TrySkipDeliver(letter.QueuePosition);
        
        if (success)
        {
            // Track skip in letter history
            LetterQueueManager.RecordLetterSkip(letter);
            
            // Show success message
            string message = $"Skipped letter to position 1! Spent {tokenCost} {letter.TokenType} tokens";
            MessageSystem.AddSystemMessage(message, SystemMessageTypes.Success);
        }
        else
        {
            // Show failure message
            string message = $"Cannot skip letter: insufficient {letter.TokenType} tokens or position 1 occupied";
            MessageSystem.AddSystemMessage(message, SystemMessageTypes.Danger);
        }
        
        StateHasChanged();
    }
    
    private string GetDeadlineWarningClass(int deadline)
    {
        return deadline switch
        {
            <= 0 => "deadline-expired",
            1 => "deadline-urgent",
            2 => "deadline-warning",
            _ => "deadline-normal"
        };
    }
    
    private string GetDeadlineWarningIcon(int deadline)
    {
        return deadline switch
        {
            <= 0 => "üíÄ",
            1 => "üö®",
            2 => "‚ö†Ô∏è",
            _ => "‚è∞"
        };
    }
    
    private string GetDeadlineDescription(int deadline)
    {
        return deadline switch
        {
            <= 0 => "EXPIRED",
            1 => "Due TODAY",
            2 => "Due in 2 days",
            _ => $"Due in {deadline} days"
        };
    }
    
    // Queue manipulation UI methods
    private void ShowMorningSwap() => showMorningSwap = true;
    private void ShowPurgeOptions() => showPurgeOptions = true;
    private void ShowPriorityOptions() => showPriorityOptions = true;
    private void ShowExtendOptions() => showExtendOptions = true;
    
    private void PerformMorningSwap()
    {
        if (LetterQueueManager.TryMorningSwap(swapPos1, swapPos2))
        {
            MessageSystem.AddSystemMessage($"Swapped letters in positions {swapPos1} and {swapPos2}!", SystemMessageTypes.Success);
            showMorningSwap = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Cannot swap: positions must be adjacent and contain at least one letter", SystemMessageTypes.Warning);
        }
        StateHasChanged();
    }
    
    private int GetPurgeTokenCount(ConnectionType type)
    {
        return purgeTokenSelection.ContainsKey(type) ? purgeTokenSelection[type] : 0;
    }
    
    private void SetPurgeTokenCount(ConnectionType type, int count)
    {
        if (count > 0)
            purgeTokenSelection[type] = count;
        else
            purgeTokenSelection.Remove(type);
    }
    
    private int GetTotalPurgeTokens()
    {
        return purgeTokenSelection.Values.Sum();
    }
    
    private void PerformPurge()
    {
        if (LetterQueueManager.TryPurgeLetter(purgeTokenSelection))
        {
            string tokenDetails = string.Join(", ", purgeTokenSelection.Select(kvp => $"{kvp.Value} {kvp.Key}"));
            MessageSystem.AddSystemMessage($"Purged bottom letter! Spent {tokenDetails} tokens", SystemMessageTypes.Success);
            showPurgeOptions = false;
            purgeTokenSelection.Clear();
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to purge letter", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    private bool CanPerformPriority()
    {
        if (priorityFromPos < 2 || priorityFromPos > 8) return false;
        if (LetterQueueManager.GetLetterAt(1) != null) return false; // Position 1 must be empty
        
        var letter = LetterQueueManager.GetLetterAt(priorityFromPos);
        if (letter == null) return false;
        
        return TokenManager.GetTokenCount(letter.TokenType) >= 5;
    }
    
    private void PerformPriority()
    {
        if (LetterQueueManager.TryPriorityMove(priorityFromPos))
        {
            var letter = LetterQueueManager.GetLetterAt(1); // It's now in position 1
            MessageSystem.AddSystemMessage($"Moved letter to position 1! Spent 5 {letter.TokenType} tokens", SystemMessageTypes.Success);
            showPriorityOptions = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to perform priority move", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    private bool CanPerformExtend()
    {
        if (extendPos < 1 || extendPos > 8) return false;
        
        var letter = LetterQueueManager.GetLetterAt(extendPos);
        if (letter == null) return false;
        
        return TokenManager.GetTokenCount(letter.TokenType) >= 2;
    }
    
    private void PerformExtend()
    {
        var letter = LetterQueueManager.GetLetterAt(extendPos);
        if (LetterQueueManager.TryExtendDeadline(extendPos))
        {
            MessageSystem.AddSystemMessage($"Extended deadline by 2 days! Spent 2 {letter.TokenType} tokens", SystemMessageTypes.Success);
            showExtendOptions = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to extend deadline", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    // Obligations panel helper methods
    private string GetObligationSummaryClass(StandingObligation obligation)
    {
        var classes = new List<string> { "obligation-summary" };
        
        if (ShouldShowForcedWarning(obligation))
            classes.Add("forced-pending");
            
        return string.Join(" ", classes);
    }
    
    private string GetPrimaryBenefit(StandingObligation obligation)
    {
        if (!obligation.BenefitEffects.Any()) return "No benefits";
        
        var primary = obligation.BenefitEffects.First();
        return primary switch
        {
            ObligationEffect.NoblesPriority => "Noble letters ‚Üí slot 5",
            ObligationEffect.CommonFolksPriority => "Common letters ‚Üí slot 6",
            ObligationEffect.PatronJumpToTop => "Patron letters ‚Üí top",
            ObligationEffect.TradeBonus => "Trade +10 coins",
            ObligationEffect.ShadowTriplePay => "Shadow triple pay",
            ObligationEffect.TrustFreeExtend => "Free trust extensions",
            ObligationEffect.ShadowForced => "Shadow letters forced",
            ObligationEffect.PatronMonthly => "Monthly resources",
            _ => primary.ToString()
        };
    }
    
    private string GetPrimaryConstraint(StandingObligation obligation)
    {
        if (!obligation.ConstraintEffects.Any()) return "No constraints";
        
        var primary = obligation.ConstraintEffects.First();
        return primary switch
        {
            ObligationEffect.NoNobleRefusal => "Must accept nobles",
            ObligationEffect.NoTradePurge => "Cannot purge trade",
            ObligationEffect.TrustSkipDoubleCost => "Trust skip 2x cost",
            ObligationEffect.NoCommonRefusal => "Must accept common",
            ObligationEffect.ShadowForced => "Every 3 days",
            ObligationEffect.PatronJumpToTop => "Patron priority",
            _ => primary.ToString()
        };
    }
    
    private bool ShouldShowForcedWarning(StandingObligation obligation)
    {
        if (obligation.HasEffect(ObligationEffect.ShadowForced))
            return obligation.DaysSinceLastForcedLetter >= 2;
            
        if (obligation.HasEffect(ObligationEffect.PatronMonthly))
            return obligation.DaysSinceLastForcedLetter >= 28;
            
        return false;
    }
    
    private int GetDaysUntilForced(StandingObligation obligation)
    {
        if (obligation.HasEffect(ObligationEffect.ShadowForced))
            return Math.Max(0, 3 - obligation.DaysSinceLastForcedLetter);
            
        if (obligation.HasEffect(ObligationEffect.PatronMonthly))
            return Math.Max(0, 30 - obligation.DaysSinceLastForcedLetter);
            
        return 0;
    }
}