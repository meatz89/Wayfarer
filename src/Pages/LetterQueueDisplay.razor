@using Wayfarer.Pages.Components

@inject GameWorld GameWorld
@inject LetterQueueManager LetterQueueManager
@inject ConnectionTokenManager TokenManager
@inject MessageSystem MessageSystem
@inject StandingObligationRepository ObligationRepository
@inject StandingObligationManager ObligationManager

<div class="letter-queue-container">
    <h3>Letter Queue</h3>
    
    
    @* Letter Queue Display *@
    <div class="letter-queue">
        @for (int position = 1; position <= 8; position++)
        {
            var letter = LetterQueueManager.GetLetterAt(position);
            <div class="queue-slot @(letter != null ? "occupied" : "empty") @(position == 1 ? "position-one" : "")">
                <div class="slot-number">[@position]</div>
                @if (letter != null)
                {
                    <div class="letter-card @(letter.IsPatronLetter ? "patron-letter" : "")">
                        <div class="letter-header">
                            @if (letter.IsPatronLetter)
                            {
                                <span class="patron-seal" title="Patron Letter">üèµÔ∏è</span>
                            }
                            <span class="token-icon">@letter.GetTokenTypeIcon()</span>
                            <span class="letter-type">@letter.TokenType</span>
                        </div>
                        <div class="letter-route">
                            <span class="sender @(letter.IsPatronLetter ? "patron-sender" : "")">@letter.SenderName</span>
                            <span class="arrow">‚Üí</span>
                            <span class="recipient">@letter.RecipientName</span>
                        </div>
                        <div class="letter-details">
                            <div class="deadline @GetDeadlineWarningClass(letter.Deadline)">
                                @GetDeadlineWarningIcon(letter.Deadline) @GetDeadlineDescription(letter.Deadline)
                            </div>
                            <div class="payment">@letter.Payment coins</div>
                            <div class="letter-size" title="@GetLetterSizeTooltip(letter)">
                                @GetLetterSizeIcon(letter.Size) @letter.Size
                            </div>
                            @if (letter.PhysicalProperties != LetterPhysicalProperties.None)
                            {
                                <div class="physical-properties" title="@letter.GetPhysicalConstraintsDescription()">
                                    @GetPhysicalPropertiesIcon(letter.PhysicalProperties)
                                </div>
                            }
                        </div>
                        @if (position == 1)
                        {
                            <button class="btn btn-primary btn-sm deliver-btn" @onclick="() => DeliverLetter(letter)">
                                Deliver
                            </button>
                        }
                        else if (position > 1 && LetterQueueManager.GetLetterAt(1) == null)
                        {
                            var baseCost = position - 1;
                            var multiplier = ObligationManager.CalculateSkipCostMultiplier(letter);
                            var tokenCost = baseCost * multiplier;
                            var hasEnoughTokens = TokenManager.HasTokens(letter.TokenType, tokenCost);
                            var availableTokens = TokenManager.GetTokenCount(letter.TokenType);
                            
                            <button class="btn btn-secondary btn-sm skip-btn" 
                                    disabled="@(!hasEnoughTokens)" 
                                    @onclick="() => SkipLetter(letter)"
                                    title="Skip to position 1">
                                Skip
                            </button>
                            <TokenCostPreview ActionName="Skip" 
                                            TokenCost="tokenCost" 
                                            TokenType="letter.TokenType" 
                                            AvailableTokens="availableTokens"
                                            AdditionalInfo="@(multiplier > 1 ? $"x{multiplier} cost from obligations" : null)" />
                        }
                    </div>
                }
                else
                {
                    <div class="empty-slot">
                        [Empty]
                    </div>
                }
            </div>
        }
    </div>
    
    @* Queue Status *@
    <div class="queue-status">
        <p>Letters in queue: @LetterQueueManager.GetLetterCount() / 8</p>
        @{
            var expiredLetters = LetterQueueManager.GetExpiringLetters(0);
            var urgentLetters = LetterQueueManager.GetExpiringLetters(1);
            var warningLetters = LetterQueueManager.GetExpiringLetters(2);
            
            if (expiredLetters.Any())
            {
                <p class="deadline-expired">üíÄ @expiredLetters.Length letter(s) EXPIRED!</p>
            }
            if (urgentLetters.Any())
            {
                <p class="deadline-urgent">üö® @urgentLetters.Length letter(s) due TODAY!</p>
            }
            if (warningLetters.Any())
            {
                <p class="deadline-warning">‚ö†Ô∏è @warningLetters.Length letter(s) due in 2 days or less!</p>
            }
        }
    </div>
    
    @* Queue Management Actions *@
    <div class="queue-actions">
        <h4>Queue Actions</h4>
        
        <div class="actions-grid">
            @* Morning Swap (only available at dawn) *@
            @if (GameWorld.TimeManager.GetCurrentTimeBlock() == TimeBlocks.Dawn)
            {
                <div class="action-group">
                    <button class="btn btn-info btn-sm" @onclick="ShowMorningSwap" disabled="@(GameWorld.GetPlayer().LastMorningSwapDay == GameWorld.CurrentDay)">
                        Morning Swap
                    </button>
                    <TokenCostPreview ActionName="Morning Swap" 
                                    TokenCost="0" 
                                    TokenType="null"
                                    ShowAvailability="false"
                                    AdditionalInfo="@(GameWorld.GetPlayer().LastMorningSwapDay == GameWorld.CurrentDay ? "Already used today" : "Once per day at dawn")" />
                    @if (showMorningSwap)
                    {
                        <div class="action-controls">
                            <input type="number" min="1" max="8" @bind="swapPos1" placeholder="From" />
                            <span>‚ÜîÔ∏è</span>
                            <input type="number" min="1" max="8" @bind="swapPos2" placeholder="To" />
                            <button class="btn btn-primary btn-sm" @onclick="PerformMorningSwap">Swap</button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => showMorningSwap = false">√ó</button>
                        </div>
                    }
                </div>
            }
            
            @* Priority Move *@
            <div class="action-group">
                <button class="btn btn-warning btn-sm" @onclick="ShowPriorityOptions">
                    Priority Move
                </button>
                @if (showPriorityOptions && priorityFromPos >= 2 && priorityFromPos <= 8)
                {
                    var letter = LetterQueueManager.GetLetterAt(priorityFromPos);
                    if (letter != null)
                    {
                        <TokenCostPreview ActionName="Priority Move" 
                                        TokenCost="5" 
                                        TokenType="letter.TokenType"
                                        AvailableTokens="TokenManager.GetTokenCount(letter.TokenType)"
                                        AdditionalInfo="Move to position 1 (must be empty)" />
                    }
                }
                @if (showPriorityOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="2" max="8" @bind="priorityFromPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformPriority" disabled="@(!CanPerformPriority())">
                            ‚Üí Slot 1
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showPriorityOptions = false">√ó</button>
                    </div>
                }
            </div>
            
            @* Extend Deadline *@
            <div class="action-group">
                <button class="btn btn-success btn-sm" @onclick="ShowExtendOptions">
                    Extend Deadline
                </button>
                @if (showExtendOptions && extendPos >= 1 && extendPos <= 8)
                {
                    var letter = LetterQueueManager.GetLetterAt(extendPos);
                    if (letter != null)
                    {
                        <TokenCostPreview ActionName="Extend Deadline" 
                                        TokenCost="2" 
                                        TokenType="letter.TokenType"
                                        AvailableTokens="TokenManager.GetTokenCount(letter.TokenType)"
                                        AdditionalInfo="Adds 2 days to deadline" />
                    }
                }
                @if (showExtendOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="1" max="8" @bind="extendPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformExtend" disabled="@(!CanPerformExtend())">
                            +2 Days
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showExtendOptions = false">√ó</button>
                    </div>
                }
            </div>
            
            @* Purge Bottom Letter *@
            @if (LetterQueueManager.GetLetterAt(8) != null)
            {
                <div class="action-group">
                    <button class="btn btn-danger btn-sm" @onclick="ShowPurgeOptions">
                        Purge Bottom
                    </button>
                    <TokenCostPreview ActionName="Purge Bottom Letter" 
                                    TokenCost="3" 
                                    TokenType="null"
                                    AvailableTokens="GetTotalAvailableTokens()"
                                    AdditionalInfo="Any combination of tokens" />
                    @if (showPurgeOptions)
                    {
                        <div class="action-controls purge-controls">
                            <p class="purge-instructions">Select 3 tokens total:</p>
                            @foreach (var tokenType in Enum.GetValues<ConnectionType>())
                            {
                                var available = TokenManager.GetTokenCount(tokenType);
                                if (available > 0)
                                {
                                    <div class="token-input">
                                        <span>@GetTokenIcon(tokenType)</span>
                                        <input type="number" min="0" max="@available" value="@GetPurgeTokenCount(tokenType)" 
                                               @onchange="@(e => SetPurgeTokenCount(tokenType, int.Parse(e.Value?.ToString() ?? "0")))" />
                                        <small>(@available available)</small>
                                    </div>
                                }
                            }
                            <div class="purge-total">Total selected: @GetTotalPurgeTokens() / 3</div>
                            <button class="btn btn-primary btn-sm" @onclick="PerformPurge" disabled="@(GetTotalPurgeTokens() != 3)">
                                Purge
                            </button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => { showPurgeOptions = false; purgeTokenSelection.Clear(); }">√ó</button>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
    
    @* Standing Obligations Panel *@
    <div class="obligations-panel">
        <h4>Active Obligations</h4>
        @{
            var activeObligations = ObligationRepository.GetPlayerObligations();
        }
        @if (!activeObligations.Any())
        {
            <div class="no-obligations-message">
                <p>No active standing obligations</p>
                <small>Visit the Obligations screen to see available commitments</small>
            </div>
        }
        else
        {
            <div class="obligations-list">
                @foreach (var obligation in activeObligations.Take(3))
                {
                    <div class="obligation-summary @GetObligationSummaryClass(obligation)">
                        <div class="obligation-name">@obligation.Name</div>
                        <div class="obligation-effect">
                            @if (obligation.BenefitEffects.Any())
                            {
                                <span class="benefit">‚úì @GetPrimaryBenefit(obligation)</span>
                            }
                            @if (obligation.ConstraintEffects.Any())
                            {
                                <span class="constraint">‚ö†Ô∏è @GetPrimaryConstraint(obligation)</span>
                            }
                        </div>
                        @if (ShouldShowForcedWarning(obligation))
                        {
                            <div class="forced-warning">
                                <span class="warning-icon">‚è∞</span>
                                <span class="warning-text">Forced letter in @GetDaysUntilForced(obligation) days</span>
                            </div>
                        }
                    </div>
                }
                @if (activeObligations.Count > 3)
                {
                    <div class="more-obligations">
                        <small>+@(activeObligations.Count - 3) more obligations</small>
                    </div>
                }
            </div>
        }
    </div>
</div>

@code {

@namespace Wayfarer.Pages
    // UI state for queue manipulation
    private bool showMorningSwap = false;
    private int swapPos1 = 1;
    private int swapPos2 = 2;
    
    private bool showPurgeOptions = false;
    private Dictionary<ConnectionType, int> purgeTokenSelection = new Dictionary<ConnectionType, int>();
    
    private bool showPriorityOptions = false;
    private int priorityFromPos = 2;
    
    private bool showExtendOptions = false;
    private int extendPos = 1;
    
    protected override void OnInitialized()
    {
        // Add test letters for minimal POC demonstration
        if (LetterQueueManager.GetLetterCount() == 0)
        {
            AddTestLetters();
        }
    }
    
    private void AddTestLetters()
    {
        // Create a few test letters to show in the queue
        var testLetters = new[]
        {
            new Letter 
            { 
                SenderName = "Elena", 
                RecipientName = "Marcus", 
                Deadline = 3, 
                Payment = 5, 
                TokenType = ConnectionType.Trust 
            },
            new Letter 
            { 
                SenderName = "Lord Ashford", 
                RecipientName = "Lady Winters", 
                Deadline = 1, 
                Payment = 12, 
                TokenType = ConnectionType.Noble 
            },
            new Letter 
            { 
                SenderName = "Merchant Guild", 
                RecipientName = "Dock Master", 
                Deadline = 5, 
                Payment = 8, 
                TokenType = ConnectionType.Trade 
            },
            new Letter 
            { 
                SenderName = "Anonymous", 
                RecipientName = "The Fence", 
                Deadline = 2, 
                Payment = 15, 
                TokenType = ConnectionType.Shadow 
            }
        };
        
        foreach (var letter in testLetters)
        {
            LetterQueueManager.AddLetter(letter);
        }
        
        // Add some test tokens
        TokenManager.AddTokens(ConnectionType.Trust, 3);
        TokenManager.AddTokens(ConnectionType.Trade, 2);
        TokenManager.AddTokens(ConnectionType.Noble, 1);
    }
    
    private string GetTokenIcon(ConnectionType type)
    {
        return type switch
        {
            ConnectionType.Trust => "‚ù§Ô∏è",
            ConnectionType.Trade => "ü™ô",
            ConnectionType.Noble => "üëë",
            ConnectionType.Common => "üç∫",
            ConnectionType.Shadow => "üåë",
            _ => "‚ùì"
        };
    }
    
    private void DeliverLetter(Letter letter)
    {
        if (letter == null) return;
        
        // Calculate payment with obligation bonuses
        var player = GameWorld.GetPlayer();
        int basePayment = letter.Payment;
        int bonusPayment = ObligationManager.CalculateTotalCoinBonus(letter);
        int totalPayment = basePayment + bonusPayment;
        
        player.ModifyCoins(totalPayment);
        
        // 50% chance to earn a token
        var random = new Random();
        bool earnedToken = random.Next(2) == 0;
        if (earnedToken)
        {
            TokenManager.AddTokens(letter.TokenType, 1);
        }
        
        // Track delivery in letter history
        LetterQueueManager.RecordLetterDelivery(letter);
        
        // Remove from queue
        LetterQueueManager.RemoveLetterFromQueue(1);
        
        // Show feedback using MessageSystem
        string message = $"Delivered letter! Earned {totalPayment} coins";
        if (bonusPayment > 0)
        {
            message += $" (base {basePayment} + {bonusPayment} bonus)";
        }
        if (earnedToken)
        {
            message += $" and 1 {letter.TokenType} token!";
        }
        MessageSystem.AddSystemMessage(message, SystemMessageTypes.Success);
        
        StateHasChanged();
    }
    
    private void SkipLetter(Letter letter)
    {
        if (letter == null) return;
        
        int tokenCost = letter.QueuePosition - 1;
        
        // Attempt to skip the letter
        bool success = LetterQueueManager.TrySkipDeliver(letter.QueuePosition);
        
        if (success)
        {
            // Track skip in letter history
            LetterQueueManager.RecordLetterSkip(letter);
            
            // Show success message
            string message = $"Skipped letter to position 1! Spent {tokenCost} {letter.TokenType} tokens";
            MessageSystem.AddSystemMessage(message, SystemMessageTypes.Success);
        }
        else
        {
            // Show failure message
            string message = $"Cannot skip letter: insufficient {letter.TokenType} tokens or position 1 occupied";
            MessageSystem.AddSystemMessage(message, SystemMessageTypes.Danger);
        }
        
        StateHasChanged();
    }
    
    private string GetDeadlineWarningClass(int deadline)
    {
        return deadline switch
        {
            <= 0 => "deadline-expired",
            1 => "deadline-urgent",
            2 => "deadline-warning",
            _ => "deadline-normal"
        };
    }
    
    private string GetDeadlineWarningIcon(int deadline)
    {
        return deadline switch
        {
            <= 0 => "üíÄ",
            1 => "üö®",
            2 => "‚ö†Ô∏è",
            _ => "‚è∞"
        };
    }
    
    private string GetDeadlineDescription(int deadline)
    {
        return deadline switch
        {
            <= 0 => "EXPIRED",
            1 => "Due TODAY",
            2 => "Due in 2 days",
            _ => $"Due in {deadline} days"
        };
    }
    
    private string GetLetterSizeIcon(LetterSize size)
    {
        return size switch
        {
            LetterSize.Small => "üìÑ",
            LetterSize.Medium => "üì¶",
            LetterSize.Large => "üì¶",
            _ => "üì¶"
        };
    }
    
    private string GetLetterSizeTooltip(Letter letter)
    {
        var slots = letter.GetRequiredSlots();
        return $"{letter.Size} letter - Requires {slots} inventory slot{(slots > 1 ? "s" : "")}";
    }
    
    private string GetPhysicalPropertiesIcon(LetterPhysicalProperties properties)
    {
        // Show the most important property icon
        if (properties.HasFlag(LetterPhysicalProperties.Fragile)) return "üîÆ";
        if (properties.HasFlag(LetterPhysicalProperties.Heavy)) return "‚öñÔ∏è";
        if (properties.HasFlag(LetterPhysicalProperties.Perishable)) return "üçÉ";
        if (properties.HasFlag(LetterPhysicalProperties.Valuable)) return "üíé";
        if (properties.HasFlag(LetterPhysicalProperties.RequiresProtection)) return "‚òî";
        if (properties.HasFlag(LetterPhysicalProperties.Bulky)) return "üìè";
        return "üìã";
    }
    
    // Queue manipulation UI methods
    private void ShowMorningSwap() => showMorningSwap = true;
    private void ShowPurgeOptions() => showPurgeOptions = true;
    private void ShowPriorityOptions() => showPriorityOptions = true;
    private void ShowExtendOptions() => showExtendOptions = true;
    
    private void PerformMorningSwap()
    {
        if (LetterQueueManager.TryMorningSwap(swapPos1, swapPos2))
        {
            MessageSystem.AddSystemMessage($"Swapped letters in positions {swapPos1} and {swapPos2}!", SystemMessageTypes.Success);
            showMorningSwap = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Cannot swap: positions must be adjacent and contain at least one letter", SystemMessageTypes.Warning);
        }
        StateHasChanged();
    }
    
    private int GetPurgeTokenCount(ConnectionType type)
    {
        return purgeTokenSelection.ContainsKey(type) ? purgeTokenSelection[type] : 0;
    }
    
    private void SetPurgeTokenCount(ConnectionType type, int count)
    {
        if (count > 0)
            purgeTokenSelection[type] = count;
        else
            purgeTokenSelection.Remove(type);
    }
    
    private int GetTotalPurgeTokens()
    {
        return purgeTokenSelection.Values.Sum();
    }
    
    private void PerformPurge()
    {
        if (LetterQueueManager.TryPurgeLetter(purgeTokenSelection))
        {
            string tokenDetails = string.Join(", ", purgeTokenSelection.Select(kvp => $"{kvp.Value} {kvp.Key}"));
            MessageSystem.AddSystemMessage($"Purged bottom letter! Spent {tokenDetails} tokens", SystemMessageTypes.Success);
            showPurgeOptions = false;
            purgeTokenSelection.Clear();
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to purge letter", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    private bool CanPerformPriority()
    {
        if (priorityFromPos < 2 || priorityFromPos > 8) return false;
        if (LetterQueueManager.GetLetterAt(1) != null) return false; // Position 1 must be empty
        
        var letter = LetterQueueManager.GetLetterAt(priorityFromPos);
        if (letter == null) return false;
        
        return TokenManager.GetTokenCount(letter.TokenType) >= 5;
    }
    
    private void PerformPriority()
    {
        if (LetterQueueManager.TryPriorityMove(priorityFromPos))
        {
            var letter = LetterQueueManager.GetLetterAt(1); // It's now in position 1
            MessageSystem.AddSystemMessage($"Moved letter to position 1! Spent 5 {letter.TokenType} tokens", SystemMessageTypes.Success);
            showPriorityOptions = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to perform priority move", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    private bool CanPerformExtend()
    {
        if (extendPos < 1 || extendPos > 8) return false;
        
        var letter = LetterQueueManager.GetLetterAt(extendPos);
        if (letter == null) return false;
        
        return TokenManager.GetTokenCount(letter.TokenType) >= 2;
    }
    
    private void PerformExtend()
    {
        var letter = LetterQueueManager.GetLetterAt(extendPos);
        if (LetterQueueManager.TryExtendDeadline(extendPos))
        {
            MessageSystem.AddSystemMessage($"Extended deadline by 2 days! Spent 2 {letter.TokenType} tokens", SystemMessageTypes.Success);
            showExtendOptions = false;
        }
        else
        {
            MessageSystem.AddSystemMessage("Failed to extend deadline", SystemMessageTypes.Danger);
        }
        StateHasChanged();
    }
    
    // Obligations panel helper methods
    private string GetObligationSummaryClass(StandingObligation obligation)
    {
        var classes = new List<string> { "obligation-summary" };
        
        if (ShouldShowForcedWarning(obligation))
            classes.Add("forced-pending");
            
        return string.Join(" ", classes);
    }
    
    private string GetPrimaryBenefit(StandingObligation obligation)
    {
        if (!obligation.BenefitEffects.Any()) return "No benefits";
        
        var primary = obligation.BenefitEffects.First();
        return primary switch
        {
            ObligationEffect.NoblesPriority => "Noble letters ‚Üí slot 5",
            ObligationEffect.CommonFolksPriority => "Common letters ‚Üí slot 6",
            ObligationEffect.PatronJumpToTop => "Patron letters ‚Üí top",
            ObligationEffect.TradeBonus => "Trade +10 coins",
            ObligationEffect.ShadowTriplePay => "Shadow triple pay",
            ObligationEffect.TrustFreeExtend => "Free trust extensions",
            ObligationEffect.ShadowForced => "Shadow letters forced",
            ObligationEffect.PatronMonthly => "Monthly resources",
            _ => primary.ToString()
        };
    }
    
    private string GetPrimaryConstraint(StandingObligation obligation)
    {
        if (!obligation.ConstraintEffects.Any()) return "No constraints";
        
        var primary = obligation.ConstraintEffects.First();
        return primary switch
        {
            ObligationEffect.NoNobleRefusal => "Must accept nobles",
            ObligationEffect.NoTradePurge => "Cannot purge trade",
            ObligationEffect.TrustSkipDoubleCost => "Trust skip 2x cost",
            ObligationEffect.NoCommonRefusal => "Must accept common",
            ObligationEffect.ShadowForced => "Every 3 days",
            ObligationEffect.PatronJumpToTop => "Patron priority",
            _ => primary.ToString()
        };
    }
    
    private bool ShouldShowForcedWarning(StandingObligation obligation)
    {
        if (obligation.HasEffect(ObligationEffect.ShadowForced))
            return obligation.DaysSinceLastForcedLetter >= 2;
            
        if (obligation.HasEffect(ObligationEffect.PatronMonthly))
            return obligation.DaysSinceLastForcedLetter >= 28;
            
        return false;
    }
    
    private int GetDaysUntilForced(StandingObligation obligation)
    {
        if (obligation.HasEffect(ObligationEffect.ShadowForced))
            return Math.Max(0, 3 - obligation.DaysSinceLastForcedLetter);
            
        if (obligation.HasEffect(ObligationEffect.PatronMonthly))
            return Math.Max(0, 30 - obligation.DaysSinceLastForcedLetter);
            
        return 0;
    }
    
    private int GetTotalAvailableTokens()
    {
        int total = 0;
        foreach (var tokenType in Enum.GetValues<ConnectionType>())
        {
            total += TokenManager.GetTokenCount(tokenType);
        }
        return total;
    }
}