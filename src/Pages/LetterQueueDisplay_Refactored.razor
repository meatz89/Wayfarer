@* LetterQueueDisplay.razor - Pure presentation layer, no game logic *@
@using Wayfarer.Pages.Components
@inject LetterQueueUIService QueueUIService

<div class="letter-queue-container">
    <h3>Letter Queue</h3>
    
    @* Letter Queue Display *@
    <div class="letter-queue">
        @foreach (var slot in _viewModel.QueueSlots)
        {
            <div class="queue-slot @(slot.IsOccupied ? "occupied" : "empty") @(slot.Position == 1 ? "position-one" : "")">
                <div class="slot-number">[@slot.Position]</div>
                @if (slot.IsOccupied && slot.Letter != null)
                {
                    var letter = slot.Letter;
                    <div class="letter-card @(letter.IsPatronLetter ? "patron-letter" : "")">
                        <div class="letter-header">
                            @if (letter.IsPatronLetter)
                            {
                                <span class="patron-seal" title="Patron Letter">üèµÔ∏è</span>
                            }
                            <span class="token-icon">@letter.TokenIcon</span>
                            <span class="letter-type">@letter.TokenType</span>
                            @if (!string.IsNullOrEmpty(letter.LeverageIndicator))
                            {
                                <span class="leverage-indicator" title="@letter.LeverageTooltip">@letter.LeverageIndicator</span>
                            }
                        </div>
                        <div class="letter-route">
                            <span class="sender @(letter.IsPatronLetter ? "patron-sender" : "")">@letter.SenderName</span>
                            <span class="arrow">‚Üí</span>
                            <span class="recipient">@letter.RecipientName</span>
                        </div>
                        <div class="letter-details">
                            <div class="deadline @letter.DeadlineClass">
                                @letter.DeadlineIcon @letter.DeadlineDescription
                            </div>
                            <div class="payment">@letter.Payment coins</div>
                            <div class="letter-size" title="@letter.Size letter - Requires @GetRequiredSlots(letter.Size) slot(s)">
                                @letter.SizeIcon @letter.Size
                            </div>
                            <div class="collection-status @(letter.IsCollected ? "collected" : "uncollected")" 
                                 title="@(letter.IsCollected ? "Letter in inventory" : "Visit sender to collect physical letter")">
                                @(letter.IsCollected ? "üì¨" : "üì≠") @(letter.IsCollected ? "Collected" : "Not Collected")
                            </div>
                            @if (!string.IsNullOrEmpty(letter.PhysicalConstraints))
                            {
                                <div class="physical-properties" title="@letter.PhysicalConstraints">
                                    @letter.PhysicalIcon
                                </div>
                            }
                        </div>
                        @if (slot.Position == 1 && slot.CanDeliver)
                        {
                            <button class="btn btn-primary btn-sm deliver-btn" @onclick="() => DeliverLetter(slot.Position)">
                                Deliver
                            </button>
                        }
                        else if (slot.CanSkip && slot.SkipAction != null)
                        {
                            <button class="btn btn-secondary btn-sm skip-btn" 
                                    disabled="@(!slot.SkipAction.HasEnoughTokens)" 
                                    @onclick="async () => await SkipLetter(slot.Position)"
                                    title="Skip to position 1">
                                Skip
                            </button>
                            <TokenCostPreview ActionName="Skip" 
                                            TokenCost="slot.SkipAction.TotalCost" 
                                            TokenType="@(Enum.TryParse<ConnectionType>(slot.SkipAction.TokenType, out var tokenType) ? tokenType : (ConnectionType?)null)"
                                            AvailableTokens="slot.SkipAction.AvailableTokens"
                                            AdditionalInfo="@slot.SkipAction.MultiplierReason" />
                        }
                    </div>
                }
                else
                {
                    <div class="empty-slot">
                        [Empty]
                    </div>
                }
            </div>
        }
    </div>
    
    @* Queue Status *@
    <div class="queue-status">
        <p>Letters in queue: @_viewModel.Status.LetterCount / @_viewModel.Status.MaxCapacity</p>
        @if (_viewModel.Status.ExpiredCount > 0)
        {
            <p class="deadline-expired">üíÄ @_viewModel.Status.ExpiredCount letter(s) EXPIRED!</p>
        }
        @if (_viewModel.Status.UrgentCount > 0)
        {
            <p class="deadline-urgent">üö® @_viewModel.Status.UrgentCount letter(s) due TODAY!</p>
        }
        @if (_viewModel.Status.WarningCount > 0)
        {
            <p class="deadline-warning">‚ö†Ô∏è @_viewModel.Status.WarningCount letter(s) due in 2 days or less!</p>
        }
    </div>
    
    @* Queue Management Actions *@
    <div class="queue-actions">
        <h4>Queue Actions</h4>
        
        <div class="actions-grid">
            @* Morning Swap (only available at dawn) *@
            @if (_viewModel.Actions.CanMorningSwap || _viewModel.CurrentTimeBlock == TimeBlocks.Dawn)
            {
                <div class="action-group">
                    <button class="btn btn-info btn-sm" @onclick="ShowMorningSwap" disabled="@(!_viewModel.Actions.CanMorningSwap)">
                        Morning Swap
                    </button>
                    <TokenCostPreview ActionName="Morning Swap" 
                                    TokenCost="0" 
                                    TokenType="null"
                                    ShowAvailability="false"
                                    AdditionalInfo="@_viewModel.Actions.MorningSwapReason" />
                    @if (showMorningSwap)
                    {
                        <div class="action-controls">
                            <input type="number" min="1" max="8" @bind="swapPos1" placeholder="From" />
                            <span>‚ÜîÔ∏è</span>
                            <input type="number" min="1" max="8" @bind="swapPos2" placeholder="To" />
                            <button class="btn btn-primary btn-sm" @onclick="PerformMorningSwap">Swap</button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => showMorningSwap = false">√ó</button>
                        </div>
                    }
                </div>
            }
            
            @* Priority Move *@
            <div class="action-group">
                <button class="btn btn-warning btn-sm" @onclick="ShowPriorityOptions">
                    Priority Move
                </button>
                @if (showPriorityOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="2" max="8" @bind="priorityFromPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformPriority">
                            ‚Üí Slot 1
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showPriorityOptions = false">√ó</button>
                    </div>
                }
            </div>
            
            @* Extend Deadline *@
            <div class="action-group">
                <button class="btn btn-success btn-sm" @onclick="ShowExtendOptions">
                    Extend Deadline
                </button>
                @if (showExtendOptions)
                {
                    <div class="action-controls">
                        <input type="number" min="1" max="8" @bind="extendPos" placeholder="Position" />
                        <button class="btn btn-primary btn-sm" @onclick="PerformExtend">
                            +2 Days
                        </button>
                        <button class="btn btn-secondary btn-sm" @onclick="() => showExtendOptions = false">√ó</button>
                    </div>
                }
            </div>
            
            @* Purge Bottom Letter *@
            @if (_viewModel.Actions.HasBottomLetter)
            {
                <div class="action-group">
                    <button class="btn btn-danger btn-sm" @onclick="ShowPurgeOptions">
                        Purge Bottom
                    </button>
                    <TokenCostPreview ActionName="Purge Bottom Letter" 
                                    TokenCost="3" 
                                    TokenType="null"
                                    AvailableTokens="@_viewModel.Actions.TotalAvailableTokens"
                                    AdditionalInfo="Any combination of tokens" />
                    @if (showPurgeOptions)
                    {
                        <div class="action-controls purge-controls">
                            <p class="purge-instructions">Select 3 tokens total:</p>
                            @foreach (var tokenOption in _viewModel.Actions.PurgeTokenOptions)
                            {
                                <div class="token-input">
                                    <span>@tokenOption.TokenIcon</span>
                                    <input type="number" min="0" max="@tokenOption.Available" 
                                           value="@GetPurgeTokenCount(tokenOption.TokenType)" 
                                           @onchange="@(e => SetPurgeTokenCount(tokenOption.TokenType, int.Parse(e.Value?.ToString() ?? "0")))" />
                                    <small>(@tokenOption.Available available)</small>
                                </div>
                            }
                            <div class="purge-total">Total selected: @GetTotalPurgeTokens() / 3</div>
                            <button class="btn btn-primary btn-sm" @onclick="async () => await PerformPurge()" 
                                    disabled="@(GetTotalPurgeTokens() != 3)">
                                Purge
                            </button>
                            <button class="btn btn-secondary btn-sm" @onclick="() => { showPurgeOptions = false; purgeTokenSelection.Clear(); }">√ó</button>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
    
</div>

@code {
@namespace Wayfarer.Pages
    private LetterQueueViewModel _viewModel;
    
    // UI state for queue manipulation
    private bool showMorningSwap = false;
    private int swapPos1 = 1;
    private int swapPos2 = 2;
    
    private bool showPurgeOptions = false;
    private Dictionary<string, int> purgeTokenSelection = new Dictionary<string, int>();
    
    private bool showPriorityOptions = false;
    private int priorityFromPos = 2;
    
    private bool showExtendOptions = false;
    private int extendPos = 1;
    
    protected override void OnInitialized()
    {
        RefreshViewModel();
    }
    
    private void RefreshViewModel()
    {
        _viewModel = QueueUIService.GetQueueViewModel();
    }
    
    private async Task DeliverLetter(int position)
    {
        await QueueUIService.DeliverLetterAsync(position);
        RefreshViewModel();
        StateHasChanged();
    }
    
    private async Task SkipLetter(int position)
    {
        await QueueUIService.TriggerSkipConversationAsync(position);
        RefreshViewModel();
        StateHasChanged();
    }
    
    // Queue manipulation UI methods
    private void ShowMorningSwap() => showMorningSwap = true;
    private void ShowPurgeOptions() => showPurgeOptions = true;
    private void ShowPriorityOptions() => showPriorityOptions = true;
    private void ShowExtendOptions() => showExtendOptions = true;
    
    private async Task PerformMorningSwap()
    {
        if (await QueueUIService.MorningSwapAsync(swapPos1, swapPos2))
        {
            showMorningSwap = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }
    
    private async Task PerformPriority()
    {
        if (await QueueUIService.PriorityMoveAsync(priorityFromPos))
        {
            showPriorityOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }
    
    private async Task PerformExtend()
    {
        if (await QueueUIService.ExtendDeadlineAsync(extendPos))
        {
            showExtendOptions = false;
            RefreshViewModel();
            StateHasChanged();
        }
    }
    
    private async Task PerformPurge()
    {
        await QueueUIService.InitiatePurgeAsync(purgeTokenSelection);
        showPurgeOptions = false;
        purgeTokenSelection.Clear();
        RefreshViewModel();
        StateHasChanged();
    }
    
    private int GetPurgeTokenCount(string tokenType)
    {
        return purgeTokenSelection.ContainsKey(tokenType) ? purgeTokenSelection[tokenType] : 0;
    }
    
    private void SetPurgeTokenCount(string tokenType, int count)
    {
        if (count > 0)
            purgeTokenSelection[tokenType] = count;
        else
            purgeTokenSelection.Remove(tokenType);
    }
    
    private int GetTotalPurgeTokens()
    {
        return purgeTokenSelection.Values.Sum();
    }
    
    private int GetRequiredSlots(string size)
    {
        return size switch
        {
            "Small" => 1,
            "Medium" => 2,
            "Large" => 3,
            _ => 1
        };
    }
}