

@inject GameFacade GameFacade

<div class="bottom-status-bar">
    <div class="status-section">
        <span class="status-icon icon icon-location"></span>
        <span class="status-text">@GetCurrentLocation()</span>
    </div>
    
    <div class="status-section queue-section" @onclick="NavigateToQueue" style="cursor: pointer; background: rgba(218, 165, 32, 0.1); border: 1px solid rgba(218, 165, 32, 0.3); border-radius: 4px; padding: 4px 8px;">
        <span class="status-icon icon icon-queue"></span>
        <span class="status-text" style="font-weight: bold;">Queue: @GetQueueStatus()</span>
    </div>
    
    <div class="status-section">
        <span class="status-icon icon icon-coins"></span>
        <span class="status-text">@GetCoinDisplay()</span>
    </div>
    
    <div class="status-section">
        <span class="status-icon icon icon-time"></span>
        <span class="status-text">@GetCurrentTime()</span>
    </div>
    
    @{
        var deadline = GetMostUrgentDeadline();
        if (deadline != null)
        {
            <div class="status-section deadline-warning">
                <span class="status-icon icon @GetDeadlineIconClass(deadline.Severity)"></span>
                <span class="status-text">@deadline.Text</span>
            </div>
        }
    }
</div>

@code {
    [Parameter] public EventCallback<CurrentViews> OnNavigate { get; set; }

    private async Task NavigateToQueue()
    {
        if (OnNavigate.HasDelegate)
        {
            await OnNavigate.InvokeAsync(CurrentViews.ObligationQueueScreen);
        }
    }

    private string GetCurrentLocation()
    {
        try
        {
            var location = GameFacade.GetCurrentLocation();
            var spot = GameFacade.GetCurrentLocationSpot();
            if (spot != null && !string.IsNullOrEmpty(spot.Name))
            {
                return spot.Name;
            }
            else if (location != null && !string.IsNullOrEmpty(location.Name))
            {
                return location.Name;
            }
            return "Market Square";
        }
        catch
        {
            return "Market Square";
        }
    }
    
    private string GetQueueStatus()
    {
        try
        {
            var queueVM = GameFacade.GetLetterQueue();
            if (queueVM?.Status != null)
            {
                // Show both count and weight: "3/8 [7/12w]"
                return $"{queueVM.Status.LetterCount}/8 [{queueVM.Status.TotalSize}/{queueVM.Status.MaxSize}s]";
            }
            
            // Fallback to simple count
            int count = GameFacade.GetLetterQueueCount();
            return $"{count}/8";
        }
        catch
        {
            return "0/8";
        }
    }
    
    private string GetCoinDisplay()
    {
        try
        {
            var inventory = GameFacade.GetInventory();
            if (inventory != null)
            {
                var coins = inventory.Coins;
                if (coins >= 100)
                {
                    return $"{coins / 100}g {coins % 100}s";
                }
                return $"{coins}s";
            }
            return "0s";
        }
        catch
        {
            return "0s";
        }
    }
    
    private string GetCurrentTime()
    {
        return GameFacade.GetFormattedTimeDisplay();
    }
    
    private enum DeadlineSeverity
    {
        Expired,
        Critical,
        Urgent,
        Normal
    }
    
    private class DeadlineInfo
    {
        public DeadlineSeverity Severity { get; set; }
        public string Text { get; set; }
    }
    
    private DeadlineInfo GetMostUrgentDeadline()
    {
        try
        {
            var queueVM = GameFacade.GetLetterQueue();
            if (queueVM?.QueueSlots == null) return null;
            
            // Find the most urgent letter
            LetterViewModel mostUrgent = null;
            foreach (var slot in queueVM.QueueSlots)
            {
                if (slot.IsOccupied && slot.DeliveryObligation != null)
                {
                    if (mostUrgent == null || slot.DeliveryObligation.DeadlineInHours < mostUrgent.DeadlineInHours)
                    {
                        mostUrgent = slot.DeliveryObligation;
                    }
                }
            }
            
            if (mostUrgent == null) return null;
            
            // Format deadline display
            if (mostUrgent.DeadlineInHours <= 0)
            {
                return new DeadlineInfo { Severity = DeadlineSeverity.Expired, Text = "EXPIRED!" };
            }
            else if (mostUrgent.DeadlineInHours <= 2)
            {
                return new DeadlineInfo { Severity = DeadlineSeverity.Critical, Text = $"{mostUrgent.DeadlineInHours}h CRITICAL" };
            }
            else if (mostUrgent.DeadlineInHours <= 6)
            {
                return new DeadlineInfo { Severity = DeadlineSeverity.Urgent, Text = $"{mostUrgent.DeadlineInHours}h urgent" };
            }
            else if (mostUrgent.DeadlineInHours <= 24)
            {
                return new DeadlineInfo { Severity = DeadlineSeverity.Normal, Text = $"{mostUrgent.DeadlineInHours}h" };
            }
            
            return null; // Don't show deadline if > 24 hours
        }
        catch
        {
            return null;
        }
    }
    
    private string GetDeadlineIconClass(DeadlineSeverity severity)
    {
        return severity switch
        {
            DeadlineSeverity.Expired => "icon-deadline-expired",
            DeadlineSeverity.Critical => "icon-deadline-fire", 
            DeadlineSeverity.Urgent => "icon-warning",
            DeadlineSeverity.Normal => "icon-deadline-calendar",
            _ => "icon-deadline-calendar"
        };
    }
}