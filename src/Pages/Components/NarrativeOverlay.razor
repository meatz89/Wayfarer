@using Wayfarer.ViewModels
@inject NarrativeManager NarrativeManager
@inject NarrativeItemService NarrativeItemService
@implements IDisposable

@if (_viewModel.IsVisible)
{
    <div class="narrative-overlay @(_viewModel.IsMinimized ? "minimized" : "expanded") @GetNarrativeTypeClass() @(_isAnimating ? "animating" : "")">
        <div class="narrative-header" @onclick="ToggleMinimize">
            <div class="narrative-title-section">
                <span class="narrative-icon">@GetNarrativeIcon()</span>
                <span class="narrative-type-badge @GetNarrativeTypeClass()">@GetNarrativeType()</span>
                <h3 class="narrative-title">@_viewModel.NarrativeTitle</h3>
                @if (_viewModel.TotalSteps > 0)
                {
                    <div class="narrative-progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: @GetProgressPercentage()%"></div>
                        </div>
                        <span class="progress-text">@(_viewModel.CurrentStep + 1) / @_viewModel.TotalSteps</span>
                    </div>
                }
            </div>
            <button class="minimize-toggle" aria-label="@(_viewModel.IsMinimized ? "Expand" : "Minimize")" @onclick:stopPropagation="true" @onclick="ToggleMinimize">
                <span class="toggle-icon">@(_viewModel.IsMinimized ? "â–¶" : "â–¼")</span>
            </button>
        </div>
        
        <div class="narrative-content-wrapper @(_viewModel.IsMinimized ? "collapsed" : "expanded")">
            <div class="narrative-content">
                @if (!string.IsNullOrEmpty(_viewModel.StepName))
                {
                    <div class="step-info">
                        <div class="step-header">
                            <h4 class="step-name">@_viewModel.StepName</h4>
                            @if (_hasTimeLimit)
                            {
                                <span class="time-limit-badge @GetTimeLimitClass()">@GetTimeLimitText()</span>
                            }
                        </div>
                        @if (!string.IsNullOrEmpty(_viewModel.StepDescription))
                        {
                            <p class="step-description">@_viewModel.StepDescription</p>
                        }
                    </div>
                }
                
                @if (!string.IsNullOrEmpty(_viewModel.GuidanceText))
                {
                    <div class="guidance-section">
                        <div class="guidance-header">
                            <span class="guidance-icon">âœ¦</span>
                            <span class="guidance-label">Guidance</span>
                        </div>
                        <p class="guidance-text">@_viewModel.GuidanceText</p>
                    </div>
                }
                
                @if (_viewModel.AllowedActions.Any())
                {
                    <div class="allowed-actions">
                        <div class="actions-header">
                            <span class="actions-icon">âš¡</span>
                            <span class="actions-label">Available Actions</span>
                        </div>
                        <div class="action-tags">
                            @foreach (var action in _viewModel.AllowedActions)
                            {
                                <span class="action-tag @GetActionTagClass(action)">@FormatActionName(action)</span>
                            }
                        </div>
                    </div>
                }
                
                @if (_showCompletionHint)
                {
                    <div class="completion-hint">
                        <span class="hint-icon">âœ“</span>
                        <span class="hint-text">Ready to complete this step</span>
                    </div>
                }
            </div>
        </div>
    </div>
}

@code {
    private NarrativeOverlayViewModel _viewModel = new();
    private System.Threading.Timer _updateTimer;
    private readonly string MinimizedStateKey = "narrative_overlay_minimized";
    private bool _isAnimating = false;
    private bool _hasTimeLimit = false;
    private int _timeRemaining = 0;
    private bool _showCompletionHint = false;
    private string _previousNarrativeId = "";

    protected override async Task OnInitializedAsync()
    {
        // Start update timer to check narrative state
        _updateTimer = new System.Threading.Timer(
            callback: _ => InvokeAsync(UpdateNarrativeState),
            state: null,
            dueTime: TimeSpan.Zero,
            period: TimeSpan.FromSeconds(1)
        );

        // Load minimized state from local storage
        await LoadMinimizedState();
    }

    private async Task UpdateNarrativeState()
    {
        try
        {
            // Check for narrative items to give
            await NarrativeItemService.CheckAndGiveNarrativeItems();

            var activeNarratives = NarrativeManager.GetActiveNarratives();

            if (!activeNarratives.Any())
            {
                if (_viewModel.IsVisible)
                {
                    // Animate out
                    _isAnimating = true;
                    await InvokeAsync(StateHasChanged);
                    await Task.Delay(300);
                    _viewModel.IsVisible = false;
                    _isAnimating = false;
                }
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Show the first active narrative
            var narrativeId = activeNarratives.First();

            // Check if narrative changed
            if (narrativeId != _previousNarrativeId)
            {
                _isAnimating = true;
                _previousNarrativeId = narrativeId;

                // Auto-expand on new narrative
                if (_viewModel.IsMinimized)
                {
                    _viewModel.IsMinimized = false;
                    await SaveMinimizedState();
                }
            }

            var currentStep = NarrativeManager.GetCurrentStep(narrativeId);
            var currentStepIndex = NarrativeManager.GetCurrentStepIndex(narrativeId);
            var totalSteps = NarrativeManager.GetTotalSteps(narrativeId);

            // Get narrative definition for title
            var narrativeDef = NarrativeManager.GetNarrativeDefinition(narrativeId);
            var narrativeTitle = narrativeDef?.Title ?? FormatNarrativeTitle(narrativeId);

            _viewModel.IsVisible = true;
            _viewModel.NarrativeId = narrativeId;
            _viewModel.NarrativeTitle = narrativeTitle;
            _viewModel.CurrentStep = currentStepIndex;
            _viewModel.TotalSteps = totalSteps;

            if (currentStep != null)
            {
                _viewModel.StepName = currentStep.Name;
                _viewModel.StepDescription = currentStep.Description;
                _viewModel.GuidanceText = currentStep.GuidanceText;
                _viewModel.AllowedActions = currentStep.AllowedActions ?? new List<string>();

                // Check for time limits (would need to be added to step definition)
                UpdateTimeLimit(currentStep);

                // Check if ready for completion
                UpdateCompletionHint(currentStep);
            }

            await InvokeAsync(StateHasChanged);

            // Remove animation class after delay
            if (_isAnimating)
            {
                await Task.Delay(300);
                _isAnimating = false;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[NarrativeOverlay] Error updating narrative state: {ex.Message}");
        }
    }

    private string FormatNarrativeTitle(string narrativeId)
    {
        // Format narrative ID for display
        return narrativeId
            .Replace("_", " ")
            .Replace("tutorial", "Tutorial", StringComparison.OrdinalIgnoreCase)
            .Replace("quest", "Quest", StringComparison.OrdinalIgnoreCase)
            .Replace("story", "Story", StringComparison.OrdinalIgnoreCase);
    }

    private string GetNarrativeType()
    {
        if (_viewModel.NarrativeId == null) return "Narrative";

        if (_viewModel.NarrativeId.ToLower().Contains("tutorial")) return "Tutorial";
        if (_viewModel.NarrativeId.ToLower().Contains("quest")) return "Quest";
        if (_viewModel.NarrativeId.ToLower().Contains("story")) return "Story";

        return "Narrative";
    }

    private string GetNarrativeIcon()
    {
        var type = GetNarrativeType();
        return type switch
        {
            "Tutorial" => "ðŸ“š",
            "Quest" => "âš”",
            "Story" => "ðŸ“œ",
            _ => "ðŸ“‹"
        };
    }

    private string GetNarrativeTypeClass()
    {
        return GetNarrativeType().ToLower();
    }

    private double GetProgressPercentage()
    {
        if (_viewModel.TotalSteps == 0) return 0;
        return (_viewModel.CurrentStep + 1) * 100.0 / _viewModel.TotalSteps;
    }

    private string GetActionTagClass(string action)
    {
        // Add specific classes based on action type
        if (action.ToLower().Contains("talk") || action.ToLower().Contains("conversation")) return "action-social";
        if (action.ToLower().Contains("deliver") || action.ToLower().Contains("pickup")) return "action-delivery";
        if (action.ToLower().Contains("trade") || action.ToLower().Contains("buy")) return "action-trade";
        if (action.ToLower().Contains("explore") || action.ToLower().Contains("travel")) return "action-explore";

        return "action-default";
    }

    private string FormatActionName(string action)
    {
        // Clean up action names for display
        return action.Replace("_", " ");
    }

    private void UpdateTimeLimit(NarrativeStep step)
    {
        // This would check if the step has a time limit
        // For now, simulate based on step name
        _hasTimeLimit = step.Name?.ToLower().Contains("urgent") == true ||
                       step.Description?.ToLower().Contains("before") == true;

        if (_hasTimeLimit)
        {
            // Simulate time remaining (would be from actual game state)
            _timeRemaining = 3; // time blocks
        }
    }

    private void UpdateCompletionHint(NarrativeStep step)
    {
        // Check if conditions are met to complete the step
        // This would check actual game state
        _showCompletionHint = step.AllowedActions?.Any() == true && 
                             _viewModel.CurrentStep == _viewModel.TotalSteps - 1;
    }

    private string GetTimeLimitClass()
    {
        if (_timeRemaining <= 1) return "urgent";
        if (_timeRemaining <= 3) return "warning";
        return "normal";
    }

    private string GetTimeLimitText()
    {
        if (_timeRemaining == 1) return "1 time block left";
        return $"{_timeRemaining} time blocks left";
    }

    private async void ToggleMinimize()
    {
        _viewModel.IsMinimized = !_viewModel.IsMinimized;
        await SaveMinimizedState();
    }

    private async Task LoadMinimizedState()
    {
        try
        {
            _viewModel.IsMinimized = false;
        }
        catch
        {
            _viewModel.IsMinimized = false;
        }
    }
    
    private async Task SaveMinimizedState()
    {
        try
        {
        }
        catch
        {
            // Silently fail if localStorage is not available
        }
    }

    public void Dispose()
    {
        _updateTimer?.Dispose();
    }
}