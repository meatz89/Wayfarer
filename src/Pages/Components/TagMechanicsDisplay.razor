@using Wayfarer.GameState

<div class="tag-mechanics-display">
    <!-- Primary Mechanical State -->
    <div class="mechanical-primary">
        <h4 class="mechanics-header">Active Mechanics</h4>
        
        <!-- Tag Matrix showing combinations -->
        <div class="tag-matrix">
            @foreach (var combo in GetActiveTagCombinations())
            {
                <div class="tag-combination @(combo.IsActive ? "active" : "potential")">
                    <div class="combo-inputs">
                        <span class="tag-badge @combo.Tag1Category">@combo.Tag1</span>
                        <span class="combo-operator">Ã—</span>
                        <span class="tag-badge @combo.Tag2Category">@combo.Tag2</span>
                    </div>
                    <div class="combo-arrow">â†’</div>
                    <div class="combo-output">
                        <span class="effect-name">@combo.EffectName</span>
                        @if (!string.IsNullOrEmpty(combo.Magnitude))
                        {
                            <span class="effect-magnitude">@combo.Magnitude</span>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
    
    <!-- Tag State Visualization -->
    <div class="tag-state-grid">
        @foreach (var category in TagCategories)
        {
            <div class="tag-category-block">
                <h5 class="category-name">@category.Name</h5>
                <div class="tag-state-bar">
                    <div class="state-indicator" style="left: @(category.StatePosition)%">
                        <span class="state-label">@category.CurrentState</span>
                    </div>
                    <div class="state-spectrum">
                        @foreach (var state in category.States)
                        {
                            <div class="spectrum-segment @(state == category.CurrentState ? "active" : "")"
                                 title="@state">
                                @if (state == category.CurrentState)
                                {
                                    <span class="state-pip"></span>
                                }
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    </div>
    
    <!-- Attention Economy Display -->
    <div class="attention-economy">
        <h5 class="economy-header">Attention Economy</h5>
        <div class="attention-flows">
            @foreach (var flow in GetAttentionFlows())
            {
                <div class="attention-flow @flow.Type">
                    <span class="flow-source">@flow.Source</span>
                    <div class="flow-arrow">
                        @for (int i = 0; i < flow.Cost; i++)
                        {
                            <span class="attention-dot">â—‹</span>
                        }
                    </div>
                    <span class="flow-target">@flow.Target</span>
                    <span class="flow-value">@flow.Value</span>
                </div>
            }
        </div>
    </div>
    
    <!-- Mechanical Feedback -->
    @if (ActiveEffects.Any())
    {
        <div class="mechanical-feedback">
            <h5>Current Effects</h5>
            <div class="effect-list">
                @foreach (var effect in ActiveEffects)
                {
                    <div class="effect-item @effect.Severity">
                        <span class="effect-icon">@effect.Icon</span>
                        <span class="effect-text">@effect.Description</span>
                        <span class="effect-source">(@effect.Source)</span>
                    </div>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public SceneContext? Scene { get; set; }
    [Parameter] public int CurrentAttention { get; set; }
    
    private List<TagCategory> TagCategories = new();
    private List<MechanicalEffect> ActiveEffects = new();
    
    private class TagCombo
    {
        public string Tag1 { get; set; }
        public string Tag1Category { get; set; }
        public string Tag2 { get; set; }
        public string Tag2Category { get; set; }
        public string EffectName { get; set; }
        public string Magnitude { get; set; }
        public bool IsActive { get; set; }
    }
    
    private class TagCategory
    {
        public string Name { get; set; }
        public List<string> States { get; set; }
        public string CurrentState { get; set; }
        public int StatePosition { get; set; }
    }
    
    private class AttentionFlow
    {
        public string Type { get; set; }
        public string Source { get; set; }
        public string Target { get; set; }
        public int Cost { get; set; }
        public string Value { get; set; }
    }
    
    private class MechanicalEffect
    {
        public string Icon { get; set; }
        public string Description { get; set; }
        public string Source { get; set; }
        public string Severity { get; set; }
    }
    
    protected override void OnParametersSet()
    {
        UpdateTagCategories();
        UpdateActiveEffects();
    }
    
    private List<TagCombo> GetActiveTagCombinations()
    {
        var combos = new List<TagCombo>();
        
        if (Scene == null) return combos;
        
        // Pressure + Resource combinations
        if (Scene.PressureTags?.Any() == true && Scene.ResourceTags?.Any() == true)
        {
            if (Scene.PressureTags.Contains(PressureTag.DEADLINE_IMMINENT) &&
                Scene.ResourceTags.Contains(ResourceTag.STAMINA_EXHAUSTED))
            {
                combos.Add(new TagCombo
                {
                    Tag1 = "DEADLINE",
                    Tag1Category = "pressure",
                    Tag2 = "EXHAUSTED",
                    Tag2Category = "resource",
                    EffectName = "Desperation",
                    Magnitude = "+2 Attention Cost",
                    IsActive = true
                });
            }
        }
        
        // Relationship + Discovery combinations
        if (Scene.RelationshipTags?.Any() == true && Scene.DiscoveryTags?.Any() == true)
        {
            if (Scene.RelationshipTags.Contains(RelationshipTag.TRUST_HIGH) &&
                Scene.DiscoveryTags.Contains(DiscoveryTag.RUMOR_AVAILABLE))
            {
                combos.Add(new TagCombo
                {
                    Tag1 = "TRUST",
                    Tag1Category = "relationship",
                    Tag2 = "RUMORS",
                    Tag2Category = "discovery",
                    EffectName = "Information Access",
                    Magnitude = "Unlock Secrets",
                    IsActive = true
                });
            }
        }
        
        // Add potential combinations (not yet active)
        combos.Add(new TagCombo
        {
            Tag1 = "DEBT",
            Tag1Category = "pressure",
            Tag2 = "SHADOW",
            Tag2Category = "relationship",
            EffectName = "Leverage",
            Magnitude = "Force Actions",
            IsActive = false
        });
        
        return combos;
    }
    
    private void UpdateTagCategories()
    {
        TagCategories.Clear();
        
        if (Scene == null) return;
        
        // Pressure category
        var pressureStates = new List<string> { "Clear", "Present", "High", "Critical" };
        var currentPressure = "Clear";
        var pressurePos = 0;
        
        if (Scene.PressureTags?.Any() == true)
        {
            if (Scene.PressureTags.Contains(PressureTag.DEBT_CRITICAL))
            {
                currentPressure = "Critical";
                pressurePos = 100;
            }
            else if (Scene.PressureTags.Contains(PressureTag.DEADLINE_IMMINENT))
            {
                currentPressure = "High";
                pressurePos = 75;
            }
            else if (Scene.PressureTags.Contains(PressureTag.DEBT_PRESENT))
            {
                currentPressure = "Present";
                pressurePos = 50;
            }
        }
        
        TagCategories.Add(new TagCategory
        {
            Name = "Pressure",
            States = pressureStates,
            CurrentState = currentPressure,
            StatePosition = pressurePos
        });
        
        // Resource category
        var resourceStates = new List<string> { "Exhausted", "Low", "Stable", "Abundant" };
        var currentResource = "Stable";
        var resourcePos = 50;
        
        if (Scene.ResourceTags?.Any() == true)
        {
            if (Scene.ResourceTags.Contains(ResourceTag.STAMINA_EXHAUSTED))
            {
                currentResource = "Exhausted";
                resourcePos = 0;
            }
            else if (Scene.ResourceTags.Contains(ResourceTag.STAMINA_TIRED))
            {
                currentResource = "Low";
                resourcePos = 33;
            }
            else if (Scene.ResourceTags.Contains(ResourceTag.STAMINA_FULL))
            {
                currentResource = "Abundant";
                resourcePos = 100;
            }
        }
        
        TagCategories.Add(new TagCategory
        {
            Name = "Resources",
            States = resourceStates,
            CurrentState = currentResource,
            StatePosition = resourcePos
        });
    }
    
    private List<AttentionFlow> GetAttentionFlows()
    {
        var flows = new List<AttentionFlow>();
        
        // Show how attention is being used
        if (CurrentAttention < 3)
        {
            flows.Add(new AttentionFlow
            {
                Type = "spent",
                Source = "Focus Pool",
                Target = "Active Choice",
                Cost = 3 - CurrentAttention,
                Value = "Committed"
            });
        }
        
        // Show potential attention costs
        flows.Add(new AttentionFlow
        {
            Type = "potential",
            Source = "Deep Inquiry",
            Target = "Information",
            Cost = 2,
            Value = "Available"
        });
        
        return flows;
    }
    
    private void UpdateActiveEffects()
    {
        ActiveEffects.Clear();
        
        if (Scene == null) return;
        
        // Convert active tags to visible effects
        if (Scene.PressureTags?.Contains(PressureTag.DEADLINE_IMMINENT) == true)
        {
            ActiveEffects.Add(new MechanicalEffect
            {
                Icon = "â°",
                Description = "Time pressure increasing attention costs",
                Source = "Deadline",
                Severity = "warning"
            });
        }
        
        if (Scene.RelationshipTags?.Contains(RelationshipTag.TRUST_NEGATIVE) == true)
        {
            ActiveEffects.Add(new MechanicalEffect
            {
                Icon = "ðŸ’”",
                Description = "Distrust limiting conversation options",
                Source = "Relationship",
                Severity = "danger"
            });
        }
    }
}