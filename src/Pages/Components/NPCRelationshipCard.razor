@using Wayfarer.Pages.Components

@inject ConnectionTokenManager TokenManager
@inject LetterQueueManager LetterQueueManager
@inject NPCRepository NPCRepository
@inject LocationRepository LocationRepository
@inject NPCLetterOfferService LetterOfferService
@inject TokenFavorManager TokenFavorManager
@inject LetterCategoryService CategoryService

<div class="npc-relationship-card @GetRelationshipStatusClass()">
    <div class="npc-header">
        <h3>@NPC.Name</h3>
        <span class="npc-profession">@NPC.Profession.ToString().Replace("_", " ")</span>
    </div>
    
    <div class="token-display">
        <h4>Connection Tokens</h4>
        <div class="token-list">
            @foreach (var tokenType in NPC.LetterTokenTypes ?? new List<ConnectionType>())
            {
                var tokenCount = GetNPCTokenCount(tokenType);
                <div class="token-item @(tokenCount < 0 ? "debt" : tokenCount > 0 ? "positive" : "neutral")">
                    <span class="token-icon">@GetTokenIcon(tokenType)</span>
                    <span class="token-type">@tokenType</span>
                    <span class="token-count">@tokenCount</span>
                    @if (tokenCount < 0)
                    {
                        <span class="debt-label">(debt)</span>
                        <span class="leverage-warning" title="Letters from @NPC.Name will enter at position @GetLeveragePosition(tokenType, tokenCount)">‚ö†Ô∏è Leverage</span>
                    }
                    else if (tokenCount >= 4)
                    {
                        <span class="respect-indicator" title="Strong relationship reduces leverage">‚≠ê</span>
                    }
                </div>
            }
            @if (!(NPC.LetterTokenTypes?.Any() ?? false))
            {
                <div class="no-tokens">This NPC doesn't offer letters</div>
            }
        </div>
        
        @* Token progress and letter categories per type *@
        @if (NPC.LetterTokenTypes?.Any() ?? false)
        {
            <div class="letter-categories">
                <h4>Letter Categories by Type</h4>
                @foreach (var tokenType in NPC.LetterTokenTypes)
                {
                    var tokensOfType = GetNPCTokenCount(tokenType);
                    var currentCategory = CategoryService.GetAvailableCategory(NPC.ID, tokenType);
                    <div class="token-type-categories">
                        <h5>@GetTokenIcon(tokenType) @tokenType Letters</h5>
                        <div class="category-list">
                            @* Basic Category *@
                            @if (tokensOfType >= GameRules.TOKENS_BASIC_THRESHOLD)
                            {
                                var (minPay, maxPay) = CategoryService.GetCategoryPaymentRange(LetterCategory.Basic);
                                <div class="category-item unlocked">
                                    <span class="category-icon">üìÑ</span>
                                    <span class="category-name">Basic</span>
                                    <span class="category-pay">@minPay-@maxPay coins</span>
                                </div>
                            }
                            else if (tokensOfType >= 0)
                            {
                                var tokensNeeded = CategoryService.GetTokensToNextCategory(NPC.ID, tokenType);
                                <div class="category-item locked">
                                    <span class="category-icon">üîí</span>
                                    <span class="category-name">Basic</span>
                                    <span class="category-requirement">Need @tokensNeeded more</span>
                                </div>
                            }
                            
                            @* Quality Category *@
                            @if (tokensOfType >= GameRules.TOKENS_QUALITY_THRESHOLD)
                            {
                                var (minPay, maxPay) = CategoryService.GetCategoryPaymentRange(LetterCategory.Quality);
                                <div class="category-item unlocked">
                                    <span class="category-icon">üìú</span>
                                    <span class="category-name">Quality</span>
                                    <span class="category-pay">@minPay-@maxPay coins</span>
                                </div>
                            }
                            else
                            {
                                var tokensNeeded = Math.Max(0, GameRules.TOKENS_QUALITY_THRESHOLD - tokensOfType);
                                <div class="category-item locked">
                                    <span class="category-icon">üîí</span>
                                    <span class="category-name">Quality</span>
                                    <span class="category-requirement">Need @tokensNeeded more</span>
                                </div>
                            }
                            
                            @* Premium Category *@
                            @if (tokensOfType >= GameRules.TOKENS_PREMIUM_THRESHOLD)
                            {
                                var (minPay, maxPay) = CategoryService.GetCategoryPaymentRange(LetterCategory.Premium);
                                <div class="category-item unlocked">
                                    <span class="category-icon">üìã</span>
                                    <span class="category-name">Premium</span>
                                    <span class="category-pay">@minPay-@maxPay coins</span>
                                </div>
                            }
                            else
                            {
                                var tokensNeeded = Math.Max(0, GameRules.TOKENS_PREMIUM_THRESHOLD - tokensOfType);
                                <div class="category-item locked">
                                    <span class="category-icon">üîí</span>
                                    <span class="category-name">Premium</span>
                                    <span class="category-requirement">Need @tokensNeeded more</span>
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        }
    </div>
    
    <div class="npc-location">
        <h4>Location</h4>
        <div class="location-info">
            @if (GetNPCLocation() != null)
            {
                <span class="location-name">@GetNPCLocation().Name</span>
                @if (IsPlayerAtSameLocation())
                {
                    <span class="same-location">‚úì You are here</span>
                }
            }
            else
            {
                <span class="unknown-location">Location unknown</span>
            }
        </div>
    </div>
    
    <div class="npc-availability">
        <h4>Availability</h4>
        <div class="availability-info">
            <span class="schedule">Always available</span>
            @if (IsNPCCurrentlyAvailable())
            {
                <span class="available-now">‚úì Available now</span>
            }
        </div>
    </div>
    
    <div class="letter-history">
        <h4>Letter History</h4>
        <div class="history-stats">
            <span class="delivered">Delivered: @GetDeliveredLetterCount()</span>
            <span class="skipped">Skipped: @GetSkippedLetterCount()</span>
            <span class="expired">Expired: @GetExpiredLetterCount()</span>
        </div>
    </div>
    
    @* Recent Interactions *@
    @if (RecentInteractions.Any())
    {
        <div class="recent-interactions">
            <h4>Recent Activity</h4>
            <div class="interaction-list">
                @foreach (var interaction in RecentInteractions.Take(3))
                {
                    <div class="interaction-item @GetInteractionClass(interaction.Type)">
                        <span class="interaction-icon">@GetInteractionIcon(interaction.Type)</span>
                        <span class="interaction-text">@interaction.Description</span>
                        <span class="interaction-time">@interaction.DaysAgo days ago</span>
                    </div>
                }
            </div>
        </div>
    }
    
    @* Current Letters in Queue *@
    @{
        var currentLetters = GetNPCLettersInQueue();
        if (currentLetters.Any())
        {
            <div class="current-letters">
                <h4>In Queue</h4>
                @foreach (var letter in currentLetters)
                {
                    <div class="queue-letter">
                        <span class="position">[Pos @letter.QueuePosition]</span>
                        <span class="route">@(letter.SenderName == NPC.Name ? $"‚Üí {letter.RecipientName}" : $"‚Üê {letter.SenderName}")</span>
                        <span class="deadline @(letter.Deadline <= 1 ? "urgent" : "")">@letter.Deadline days</span>
                    </div>
                }
            </div>
        }
    }
    
    @* Token Favors *@
    <TokenFavorDisplay CurrentNPC="@NPC" />
    
    <div class="relationship-status">
        <div class="status-indicator @GetRelationshipStatusClass()">
            @GetRelationshipStatusText()
        </div>
    </div>
</div>

@code {

@namespace Wayfarer.Pages.Components
    [Parameter] public NPC NPC { get; set; }
    [Parameter] public GameWorld GameWorld { get; set; }
    
    private class RecentInteraction
    {
        public string Type { get; set; }
        public string Description { get; set; }
        public int DaysAgo { get; set; }
    }
    
    private List<RecentInteraction> RecentInteractions = new List<RecentInteraction>();
    
    protected override void OnInitialized()
    {
        // Simulate recent interactions based on letter history
        var player = GameWorld.GetPlayer();
        if (player.NPCLetterHistory.ContainsKey(NPC.ID))
        {
            var history = player.NPCLetterHistory[NPC.ID];
            if (history.DeliveredCount > 0)
            {
                RecentInteractions.Add(new RecentInteraction 
                { 
                    Type = "success", 
                    Description = "Letter delivered successfully", 
                    DaysAgo = 1 
                });
            }
            if (history.SkippedCount > 0)
            {
                RecentInteractions.Add(new RecentInteraction 
                { 
                    Type = "warning", 
                    Description = "Letter delivery skipped", 
                    DaysAgo = 2 
                });
            }
            if (history.ExpiredCount > 0)
            {
                RecentInteractions.Add(new RecentInteraction 
                { 
                    Type = "danger", 
                    Description = "Letter expired - relationship damaged", 
                    DaysAgo = 3 
                });
            }
        }
    }
    
    private int GetNPCTokenCount(ConnectionType tokenType)
    {
        var npcTokens = TokenManager.GetTokensWithNPC(NPC.ID);
        return npcTokens.GetValueOrDefault(tokenType, 0);
    }
    
    private bool HasAnyTokens()
    {
        var npcTokens = TokenManager.GetTokensWithNPC(NPC.ID);
        return npcTokens.Any(kvp => kvp.Value != 0);
    }
    
    private int GetTotalTokens()
    {
        var npcTokens = TokenManager.GetTokensWithNPC(NPC.ID);
        return npcTokens.Sum(kvp => kvp.Value);
    }
    
    private string GetTokenIcon(ConnectionType type)
    {
        return type switch
        {
            ConnectionType.Trust => "‚ù§Ô∏è",
            ConnectionType.Trade => "ü™ô",
            ConnectionType.Noble => "üëë",
            ConnectionType.Common => "üç∫",
            ConnectionType.Shadow => "üåë",
            _ => "‚ùì"
        };
    }
    
    private Location GetNPCLocation()
    {
        if (!string.IsNullOrEmpty(NPC.Location))
        {
            return LocationRepository.GetLocation(NPC.Location);
        }
        return null;
    }
    
    private bool IsPlayerAtSameLocation()
    {
        var player = GameWorld.GetPlayer();
        return player.CurrentLocation?.Id == NPC.Location;
    }
    
    
    private bool IsNPCCurrentlyAvailable()
    {
        var currentTime = GameWorld.TimeManager.GetCurrentTimeBlock();
        return NPC.IsAvailable(currentTime);
    }
    
    private int GetDeliveredLetterCount()
    {
        var player = GameWorld.GetPlayer();
        if (player.NPCLetterHistory.ContainsKey(NPC.ID))
        {
            return player.NPCLetterHistory[NPC.ID].DeliveredCount;
        }
        return 0;
    }
    
    private int GetSkippedLetterCount()
    {
        var player = GameWorld.GetPlayer();
        if (player.NPCLetterHistory.ContainsKey(NPC.ID))
        {
            return player.NPCLetterHistory[NPC.ID].SkippedCount;
        }
        return 0;
    }
    
    private int GetExpiredLetterCount()
    {
        var player = GameWorld.GetPlayer();
        if (player.NPCLetterHistory.ContainsKey(NPC.ID))
        {
            return player.NPCLetterHistory[NPC.ID].ExpiredCount;
        }
        return 0;
    }
    
    private string GetRelationshipStatusClass()
    {
        var tokens = TokenManager.GetTokensWithNPC(NPC.ID);
        var totalTokens = tokens.Sum(kvp => kvp.Value);
        
        if (tokens.Any(kvp => kvp.Value < 0))
            return "relationship-debt";
        else if (totalTokens >= 5)
            return "relationship-strong";
        else if (totalTokens > 0)
            return "relationship-positive";
        else
            return "relationship-neutral";
    }
    
    private string GetRelationshipStatusText()
    {
        var tokens = TokenManager.GetTokensWithNPC(NPC.ID);
        var totalTokens = tokens.Sum(kvp => kvp.Value);
        
        if (tokens.Any(kvp => kvp.Value < 0))
            return "In Debt";
        else if (totalTokens >= 5)
            return "Strong Bond";
        else if (totalTokens > 0)
            return "Friendly";
        else
            return "Neutral";
    }
    
    private List<Letter> GetNPCLettersInQueue()
    {
        var queue = LetterQueueManager.GetPlayerQueue();
        return queue.Where(l => l != null && (l.SenderName == NPC.Name || l.RecipientName == NPC.Name))
                   .OrderBy(l => l.QueuePosition)
                   .ToList();
    }
    
    private string GetInteractionClass(string type)
    {
        return type switch
        {
            "success" => "interaction-success",
            "warning" => "interaction-warning",
            "danger" => "interaction-danger",
            _ => "interaction-info"
        };
    }
    
    private string GetInteractionIcon(string type)
    {
        return type switch
        {
            "success" => "‚úì",
            "warning" => "‚ö†Ô∏è",
            "danger" => "‚ùå",
            _ => "‚ÑπÔ∏è"
        };
    }
    
    private int GetLeveragePosition(ConnectionType tokenType, int tokenBalance)
    {
        // Calculate the leverage position based on token debt
        // This mirrors the logic in LetterQueueManager.CalculateLeveragePosition
        
        // Get base position for token type
        int basePosition = tokenType switch
        {
            ConnectionType.Noble => 3,     // High social status
            ConnectionType.Trade => 5,     // Middle class
            ConnectionType.Shadow => 5,    // Underworld
            ConnectionType.Common => 7,    // Lower class
            ConnectionType.Trust => 7,     // Personal relationships
            _ => 8
        };
        
        // Apply leverage modifiers based on token balance
        int leveragePosition = basePosition;
        
        if (tokenBalance < 0)
        {
            // Negative tokens create leverage - each -1 token = -1 position
            leveragePosition += tokenBalance; // Subtracts since negative
        }
        else if (tokenBalance >= 4)
        {
            // High positive tokens reduce leverage slightly
            leveragePosition += 1;
        }
        
        // Clamp to valid queue positions
        return Math.Max(1, Math.Min(8, leveragePosition));
    }
}