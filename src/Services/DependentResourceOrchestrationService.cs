/// <summary>
/// Orchestrates loading of dependent resources generated by self-contained scenes.
///
/// HIGHLANDER: Uses PackageLoadResult with direct object references.
/// NOTE: This service is currently unused. Orchestration happens directly in:
///   - SceneInstanceFacade.PostLoadOrchestration (immediate spawn path)
///   - LocationFacade.ConfigureDependentResources (deferred activation path)
/// </summary>
public class DependentResourceOrchestrationService
{
    private readonly ContentGenerationFacade _contentGenerationFacade;
    private readonly PackageLoaderFacade _packageLoaderFacade;
    private readonly HexRouteGenerator _hexRouteGenerator;
    private readonly TimeManager _timeManager;

    public DependentResourceOrchestrationService(
        GameWorld gameWorld,
        ContentGenerationFacade contentGenerationFacade,
        PackageLoaderFacade packageLoaderFacade,
        HexRouteGenerator hexRouteGenerator,
        SceneInstantiator sceneInstantiator,
        TimeManager timeManager)
    {
        _contentGenerationFacade = contentGenerationFacade;
        _packageLoaderFacade = packageLoaderFacade;
        _hexRouteGenerator = hexRouteGenerator;
        _timeManager = timeManager;
    }

    /// <summary>
    /// Orchestrate complete dependent resource loading pipeline.
    /// HIGHLANDER: Uses PackageLoadResult with direct object references - no GameWorld searching.
    /// </summary>
    public async Task<PackageLoadResult> LoadDependentResources(Scene scene, string packageJson, string packageId, Player player, SceneTemplate template)
    {
        await _contentGenerationFacade.CreateDynamicPackageFile(packageJson, packageId);
        Console.WriteLine($"[DependentResources] Created dynamic package file: {packageId}");

        // HIGHLANDER: Get direct object references from PackageLoader
        PackageLoadResult loadResult = await _packageLoaderFacade.LoadDynamicPackage(packageJson, packageId);
        Console.WriteLine($"[DependentResources] Loaded {loadResult.LocationsAdded.Count} locations, {loadResult.ItemsAdded.Count} items");

        // Build provenance for tracking
        SceneProvenance provenance = new SceneProvenance
        {
            Scene = scene,
            CreatedDay = _timeManager.CurrentDay,
            CreatedTimeBlock = _timeManager.CurrentTimeBlock,
            CreatedSegment = _timeManager.CurrentSegment
        };

        // Configure locations (direct object references)
        foreach (Location location in loadResult.LocationsAdded)
        {
            location.Origin = LocationOrigin.SceneCreated;
            location.Provenance = provenance;

            Console.WriteLine($"[DependentResources] Configured location '{location.Name}' with Origin=SceneCreated");

            if (location.HexPosition.HasValue)
            {
                List<RouteOption> routes = _hexRouteGenerator.GenerateRoutesForNewLocation(location);
                foreach (RouteOption route in routes)
                {
                    // Routes added directly to result for caller to add to GameWorld
                    loadResult.RoutesAdded.Add(route);
                }
                Console.WriteLine($"[DependentResources] Generated {routes.Count} hex routes");
            }
        }

        // Configure items (direct object references)
        foreach (Item item in loadResult.ItemsAdded)
        {
            item.Provenance = provenance;

            // Check if this item should be added to inventory
            DependentItemSpec itemSpec = template?.DependentItems?.FirstOrDefault(s => s.Name == item.Name);
            if (itemSpec != null && itemSpec.AddToInventoryOnCreation)
            {
                player.Inventory.Add(item);
                Console.WriteLine($"[DependentResources] Added item '{item.Name}' to player inventory");
            }
        }

        // Bind situations to dependent locations (direct object references)
        // NEW ARCHITECTURE: Use Template.DependentLocationSpec (object reference) instead of string matching
        // Multiple situations with SAME spec INSTANCE share the same created location
        Dictionary<DependentLocationSpec, Location> specToLocationMap = new Dictionary<DependentLocationSpec, Location>();

        foreach (Situation situation in scene.Situations)
        {
            DependentLocationSpec spec = situation.Template?.DependentLocationSpec;
            if (spec != null)
            {
                // Check if we've already bound a location for this spec instance
                if (specToLocationMap.TryGetValue(spec, out Location existingLocation))
                {
                    // Shared spec instance = shared location (direct binding by reference equality)
                    situation.Location = existingLocation;
                    Console.WriteLine($"[DependentResources] Bound situation '{situation.Name}' to shared location '{existingLocation.Name}'");
                }
                else
                {
                    // Find location matching this spec's name in loadResult
                    Location dependentLocation = loadResult.LocationsAdded
                        .FirstOrDefault(l => l.Name == spec.Name);

                    if (dependentLocation != null)
                    {
                        situation.Location = dependentLocation;
                        specToLocationMap[spec] = dependentLocation;
                        Console.WriteLine($"[DependentResources] Bound situation '{situation.Name}' to dependent location '{dependentLocation.Name}'");
                    }
                }
            }
        }

        return loadResult;
    }
}
