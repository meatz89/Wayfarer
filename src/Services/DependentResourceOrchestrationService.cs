/// <summary>
/// Orchestrates loading of dependent resources generated by self-contained scenes.
///
/// HIGHLANDER: Creates locations PER-SITUATION via CreateSingleLocation - no JSON, no matching
/// NOTE: This service is currently unused. Orchestration happens directly in:
///   - SceneInstanceFacade.PostLoadOrchestration (immediate spawn path)
///   - LocationFacade.ConfigureDependentResources (deferred activation path)
/// </summary>
public class DependentResourceOrchestrationService
{
    private readonly ContentGenerationFacade _contentGenerationFacade;
    private readonly PackageLoaderFacade _packageLoaderFacade;
    private readonly HexRouteGenerator _hexRouteGenerator;
    private readonly TimeManager _timeManager;

    public DependentResourceOrchestrationService(
        GameWorld gameWorld,
        ContentGenerationFacade contentGenerationFacade,
        PackageLoaderFacade packageLoaderFacade,
        HexRouteGenerator hexRouteGenerator,
        SceneInstantiator sceneInstantiator,
        TimeManager timeManager)
    {
        _contentGenerationFacade = contentGenerationFacade;
        _packageLoaderFacade = packageLoaderFacade;
        _hexRouteGenerator = hexRouteGenerator;
        _timeManager = timeManager;
    }

    /// <summary>
    /// Orchestrate complete dependent resource loading pipeline.
    /// HIGHLANDER: Creates locations PER-SITUATION via CreateSingleLocation - no JSON for locations, no matching
    /// Items still use JSON path (loadResult.ItemsAdded)
    /// </summary>
    public async Task<PackageLoadResult> LoadDependentResources(Scene scene, string packageJson, string packageId, Player player, SceneTemplate template, Venue contextVenue)
    {
        await _contentGenerationFacade.CreateDynamicPackageFile(packageJson, packageId);
        Console.WriteLine($"[DependentResources] Created dynamic package file: {packageId}");

        // HIGHLANDER: Load items from package (locations now created directly below)
        PackageLoadResult loadResult = await _packageLoaderFacade.LoadDynamicPackage(packageJson, packageId);
        Console.WriteLine($"[DependentResources] Loaded {loadResult.ItemsAdded.Count} items from package");

        // Build provenance for tracking
        SceneProvenance provenance = new SceneProvenance
        {
            Scene = scene,
            CreatedDay = _timeManager.CurrentDay,
            CreatedTimeBlock = _timeManager.CurrentTimeBlock,
            CreatedSegment = _timeManager.CurrentSegment
        };

        // Configure items (still from loadResult - items use JSON path)
        foreach (Item item in loadResult.ItemsAdded)
        {
            item.Provenance = provenance;

            // Check if this item should be added to inventory
            DependentItemSpec itemSpec = template?.DependentItems?.FirstOrDefault(s => s.Name == item.Name);
            if (itemSpec != null && itemSpec.AddToInventoryOnCreation)
            {
                player.Inventory.Add(item);
                Console.WriteLine($"[DependentResources] Added item '{item.Name}' to player inventory");
            }
        }

        // Create and bind locations PER-SITUATION via direct CreateSingleLocation
        // NO JSON serialization - creates Location directly from spec
        // Shared spec instance = shared location (tracked by Dictionary for reference equality)
        Dictionary<DependentLocationSpec, Location> specToLocationMap = new Dictionary<DependentLocationSpec, Location>();

        foreach (Situation situation in scene.Situations)
        {
            DependentLocationSpec spec = situation.Template?.DependentLocationSpec;
            if (spec != null)
            {
                // Check if we've already created a location for this spec instance
                if (specToLocationMap.TryGetValue(spec, out Location existingLocation))
                {
                    // Shared spec instance = shared location (reference equality)
                    situation.Location = existingLocation;
                    Console.WriteLine($"[DependentResources] Bound situation '{situation.Name}' to SHARED location '{existingLocation.Name}'");
                }
                else
                {
                    // CREATE location directly from spec (NO JSON, NO matching)
                    // Returns ONE Location reference - direct binding
                    Location createdLocation = _packageLoaderFacade.CreateSingleLocation(spec, contextVenue);

                    // Set Origin and Provenance
                    createdLocation.Origin = LocationOrigin.SceneCreated;
                    createdLocation.Provenance = provenance;

                    // Generate hex routes if location has hex position
                    if (createdLocation.HexPosition.HasValue)
                    {
                        List<RouteOption> routes = _hexRouteGenerator.GenerateRoutesForNewLocation(createdLocation);
                        foreach (RouteOption route in routes)
                        {
                            loadResult.RoutesAdded.Add(route);
                        }
                        Console.WriteLine($"[DependentResources] Generated {routes.Count} hex routes for location '{createdLocation.Name}'");
                    }

                    // DIRECT BINDING: situation.Location = createdLocation (NO matching)
                    situation.Location = createdLocation;
                    specToLocationMap[spec] = createdLocation;
                    loadResult.LocationsAdded.Add(createdLocation);

                    Console.WriteLine($"[DependentResources] CREATED and bound location '{createdLocation.Name}' for situation '{situation.Name}'");
                }
            }
        }

        return loadResult;
    }
}
