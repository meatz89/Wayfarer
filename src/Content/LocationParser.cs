using System.Text.Json;
/// <summary>
/// Parser for deserializing Venue location data from JSON.
/// </summary>
public static class LocationParser
{
/// <summary>
/// Convert a LocationDTO to a Location domain model
/// </summary>
public static Location ConvertDTOToLocation(LocationDTO dto, GameWorld gameWorld)
{
    Location location = new Location(dto.Id, dto.Name)
    {
        InitialState = dto.InitialState ?? "", // Optional - defaults to empty if missing
        VenueId = dto.VenueId ?? "" // Optional - defaults to empty if missing
    };

    // CATALOGUE PATTERN: Translate InitialState categorical value to concrete IsLocked boolean
    // Parse-time translation from DTO string to domain property
    if (!string.IsNullOrEmpty(location.InitialState) && location.InitialState == "Locked")
    {
        location.IsLocked = true;
    }

    // HIGHLANDER Pattern A: Resolve Venue object reference from VenueId
    // Location.VenueId (string) from JSON, Location.Venue (object) resolved here via GameWorld lookup
    // Runtime code uses ONLY Location.Venue, never VenueId lookups
    if (!string.IsNullOrEmpty(location.VenueId))
    {
        location.Venue = gameWorld.Venues.FirstOrDefault(v => v.Id == location.VenueId);
        if (location.Venue == null)
        {
            throw new InvalidOperationException($"Location '{dto.Id}' references non-existent Venue '{location.VenueId}'");
        }
    }

    // Parse hex position from DTO (for dependent locations generated by scenes)
    // Normal locations get HexPosition from hex grid sync in HexParser
    // Scene-generated locations have hex position directly in DTO
    if (dto.Q.HasValue && dto.R.HasValue)
    {
        location.HexPosition = new AxialCoordinates(dto.Q.Value, dto.R.Value);
        Console.WriteLine($"[LocationParser] Set HexPosition for '{dto.Id}' from DTO: ({dto.Q.Value}, {dto.R.Value})");
    }

    // Parse time windows
    if (dto.CurrentTimeBlocks != null && dto.CurrentTimeBlocks.Count > 0)
    {
        foreach (string windowString in dto.CurrentTimeBlocks)
        {
            if (EnumParser.TryParse<TimeBlocks>(windowString, out TimeBlocks window))
            {
                location.CurrentTimeBlocks.Add(window);
            }
        }
    }
    else
    {
        // Add all time windows as default
        location.CurrentTimeBlocks.Add(TimeBlocks.Morning);
        location.CurrentTimeBlocks.Add(TimeBlocks.Midday);
        location.CurrentTimeBlocks.Add(TimeBlocks.Afternoon);
        location.CurrentTimeBlocks.Add(TimeBlocks.Evening);
    }

    // Parse location properties from the new structure
    if (dto.Properties != null)
    {// Parse base properties (always active)
        Console.WriteLine($"[LocationParser] Parsing properties for location '{dto.Id}'");

        if (dto.Properties.Base != null)
        {
            Console.WriteLine($"[LocationParser] Base properties: {string.Join(", ", dto.Properties.Base)}");
            foreach (string propString in dto.Properties.Base)
            {
                if (EnumParser.TryParse<LocationPropertyType>(propString, out LocationPropertyType prop))
                {
                    location.LocationProperties.Add(prop);
                    Console.WriteLine($"[LocationParser] ✅ Parsed base property: {propString} → {prop}");
                }
                else
                {
                    Console.WriteLine($"[LocationParser] ⚠️ WARNING: Failed to parse base property '{propString}' for location '{dto.Id}'");
                }
            }
        }

        Console.WriteLine($"[LocationParser] Final LocationProperties for '{dto.Id}': {string.Join(", ", location.LocationProperties)}");

        // Parse time-specific properties
        Dictionary<TimeBlocks, List<LocationPropertyType>> timeProperties = new Dictionary<TimeBlocks, List<LocationPropertyType>>();

        // Morning properties
        ParseTimeProperties(dto.Properties.Morning, TimeBlocks.Morning, timeProperties);
        // Midday properties
        ParseTimeProperties(dto.Properties.Midday, TimeBlocks.Midday, timeProperties);
        // Afternoon properties
        ParseTimeProperties(dto.Properties.Afternoon, TimeBlocks.Afternoon, timeProperties);
        // Evening properties
        ParseTimeProperties(dto.Properties.Evening, TimeBlocks.Evening, timeProperties);
        // Night and Dawn removed from 4-block system

        // Assign to location
        foreach (KeyValuePair<TimeBlocks, List<LocationPropertyType>> kvp in timeProperties)
        {
            if (kvp.Value.Count > 0)
            {
                location.TimeSpecificProperties.Add(new TimeSpecificProperty
                {
                    TimeBlock = kvp.Key,
                    Properties = kvp.Value
                });
            }
        }
    }

    // AccessRequirement system eliminated - PRINCIPLE 4: Economic affordability determines access

    // Parse gameplay properties moved from Location
    location.DomainTags = dto.DomainTags ?? new List<string>(); // Optional - defaults to empty list if missing

    if (!string.IsNullOrEmpty(dto.LocationType) && Enum.TryParse(dto.LocationType, out LocationTypes locationType))
    {
        location.LocationType = locationType;
    }

    location.IsStartingLocation = dto.IsStartingLocation;

    if (!string.IsNullOrEmpty(dto.ObligationProfile))
    {
        if (System.Enum.TryParse<ObligationDiscipline>(dto.ObligationProfile, out ObligationDiscipline obligationProfile))
        {
            location.ObligationProfile = obligationProfile;
        }
    }

    // Parse available professions by time
    if (dto.AvailableProfessionsByTime != null)
    {
        foreach (KeyValuePair<string, List<string>> kvp in dto.AvailableProfessionsByTime)
        {
            if (EnumParser.TryParse<TimeBlocks>(kvp.Key, out TimeBlocks timeBlock))
            {
                List<Professions> professions = new List<Professions>();
                foreach (string professionStr in kvp.Value)
                {
                    if (EnumParser.TryParse<Professions>(professionStr, out Professions profession))
                    {
                        professions.Add(profession);
                    }
                }
                location.AvailableProfessionsByTime[timeBlock] = professions;
            }
        }
    }

    // Parse available work actions
    if (dto.AvailableWork != null)
    {
        foreach (WorkActionDTO workDto in dto.AvailableWork)
        {
            WorkAction workAction = new WorkAction
            {
                Id = workDto.Id,
                Name = workDto.Name,
                Description = workDto.Description,
                Type = Enum.TryParse<WorkType>(workDto.Type, out WorkType workType) ? workType : WorkType.Standard,
                BaseCoins = workDto.BaseCoins,
                VenueId = workDto.VenueId,
                LocationId = workDto.LocationId,
                RequiredTokens = workDto.RequiredTokens,
                RequiredTokenType = workDto.RequiredTokenType != null && Enum.TryParse<ConnectionType>(workDto.RequiredTokenType, out ConnectionType tokenType) ? tokenType : null,
                RequiredPermit = workDto.RequiredPermit,
                HungerReduction = workDto.HungerReduction,
                HealthRestore = workDto.HealthRestore,
                GrantedItem = workDto.GrantedItem
            };
            location.AvailableWork.Add(workAction);
        }
    }

    // NOTE: Old SceneDTO parsing removed - equipment-based Scene system deleted
    // ObservationScene (Mental) and TravelScene (Physical) are separate valid systems
    // NEW Scene-Situation architecture spawns Scenes via SceneTemplates (not embedded in location JSON)

    return location;
}

/// <summary>
/// Helper method to parse time-specific properties
/// </summary>
private static void ParseTimeProperties(List<string> propertyStrings, TimeBlocks timeBlock, Dictionary<TimeBlocks, List<LocationPropertyType>> timeProperties)
{
    if (propertyStrings == null || propertyStrings.Count == 0)
        return;

    List<LocationPropertyType> properties = new List<LocationPropertyType>();
    foreach (string propString in propertyStrings)
    {
        if (!string.IsNullOrEmpty(propString) &&
            EnumParser.TryParse<LocationPropertyType>(propString, out LocationPropertyType prop))
        {
            properties.Add(prop);
        }
    }

    if (properties.Count > 0)
    {
        timeProperties[timeBlock] = properties;
    }
}

private static List<string> GetStringArrayFromProperty(JsonElement element, string propertyName)
{
    List<string> results = new List<string>();

    if (element.TryGetProperty(propertyName, out JsonElement arrayElement) &&
        arrayElement.ValueKind == JsonValueKind.Array)
    {
        foreach (JsonElement item in arrayElement.EnumerateArray())
        {
            if (item.ValueKind == JsonValueKind.String)
            {
                string value = item.GetString();
                if (!string.IsNullOrWhiteSpace(value))
                {
                    results.Add(value);
                }
            }
        }
    }

    return results;
}

}
