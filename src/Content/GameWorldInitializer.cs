/// <summary>
/// Result of game initialization containing all explicitly-created objects.
/// These objects have state and primitive constructor parameters - they cannot be DI-resolved.
/// </summary>
public class GameInitializationResult
{
    public GameWorld GameWorld { get; }
    public TimeManager TimeManager { get; }

    public GameInitializationResult(GameWorld gameWorld, TimeManager timeManager)
    {
        GameWorld = gameWorld;
        TimeManager = timeManager;
    }
}

/// <summary>
/// Static factory for creating and initializing GameWorld instances.
/// Uses the new package-based loading system.
/// This is static to ensure clean initialization during startup without DI dependencies.
/// </summary>
public static class GameWorldInitializer
{
    /// <summary>
    /// Creates a new GameWorld and TimeManager using the Content/Core directory.
    /// This method must be static to avoid circular dependencies during startup.
    /// Object references are resolved during parsing (HIGHLANDER Pattern A).
    /// HIGHLANDER: One way to create GameWorld - always from Content/Core.
    /// </summary>
    public static GameInitializationResult CreateInitializationResult()
    {
        // Create new GameWorld instance
        GameWorld gameWorld = new GameWorld();

        // CRITICAL: Clear Content/Dynamic folder at game start for clean state
        // Dependent resources from previous sessions (scene-generated locations/items) must not persist
        // Must happen BEFORE any package loading to prevent stale JSON files from interfering
        ClearDynamicContentFolder();

        // Create SceneGenerationFacade for parse-time scene generation
        SceneGenerationFacade sceneGenerationFacade = new SceneGenerationFacade(gameWorld);

        // Create validation services required by PackageLoader
        LocationPlayabilityValidator locationValidator = new LocationPlayabilityValidator(gameWorld);

        // Load content from Content/Core directory (HIGHLANDER: one content source)
        // Parsers resolve object references during parsing
        // AI-generated content goes in Content/Generated
        LocationPlacementService locationPlacementService = new LocationPlacementService(gameWorld);
        PackageLoader packageLoader = new PackageLoader(gameWorld, sceneGenerationFacade, locationValidator, locationPlacementService);
        packageLoader.LoadPackagesFromDirectory("Content/Core");

        // NOTE: Procedural routes are generated by PackageLoader (NOT here - avoid duplication)
        // PackageLoader.GenerateProceduralRoutes() is called after hex grid + locations loaded

        // Spawn initial starter Scenes to populate tutorial content
        SpawnInitialScenes(gameWorld);

        // Create TimeManager with TimeModel - domain model with state, created explicitly
        MessageSystem messageSystem = new MessageSystem(gameWorld);
        TimeModel timeModel = new TimeModel(gameWorld.CurrentDay);
        timeModel.SetInitialState(gameWorld.CurrentDay, gameWorld.CurrentTimeBlock, 1);
        TimeManager timeManager = new TimeManager(timeModel, messageSystem);

        return new GameInitializationResult(gameWorld, timeManager);
    }

    /// <summary>
    /// Log all SceneTemplates marked as starter content for verification.
    /// Actual spawning happens in GameOrchestrator.StartGameAsync() after initialization completes.
    /// </summary>
    private static void SpawnInitialScenes(GameWorld gameWorld)
    {
        // Log scene templates with LocationActivationFilter (location-only activation)
        List<SceneTemplate> activatableTemplates = gameWorld.SceneTemplates
            .Where(t => t.LocationActivationFilter != null)
            .ToList();

        Console.WriteLine($"[Init] Found {activatableTemplates.Count} scene templates with LocationActivationFilter");
        foreach (SceneTemplate t in activatableTemplates)
        {
            Console.WriteLine($"  - {t.Id} (Location activation)");
        }
    }

    /// <summary>
    /// Clear Content/Dynamic folder at game initialization for clean state
    /// Removes stale scene-generated JSON files from previous sessions
    /// Called before any package loading to prevent interference
    /// </summary>
    private static void ClearDynamicContentFolder()
    {
        string dynamicPath = Path.Combine("Content", "Dynamic");

        if (!Directory.Exists(dynamicPath))
        {
            Console.WriteLine($"[Init] Dynamic folder does not exist, skipping cleanup");
            return;
        }

        string[] jsonFiles = Directory.GetFiles(dynamicPath, "*.json");

        if (jsonFiles.Length == 0)
        {
            Console.WriteLine($"[Init] Dynamic folder is already empty");
            return;
        }

        Console.WriteLine($"[Init] Clearing {jsonFiles.Length} stale files from Content/Dynamic");

        foreach (string file in jsonFiles)
        {
            File.Delete(file);
            Console.WriteLine($"[Init]   âœ… Deleted {Path.GetFileName(file)}");
        }

        Console.WriteLine($"[Init] Content/Dynamic cleared - clean state achieved");
    }
}