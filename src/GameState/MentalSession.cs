/// <summary>
/// V4 Mental Session - runtime state for active obligation
/// Unified architecture with ConversationSession
/// DOMAIN COLLECTION PRINCIPLE: List<T> instead of Dictionary
/// </summary>
public class MentalSession
{
    public string SessionId { get; init; } = Guid.NewGuid().ToString();
    // HIGHLANDER: Store Obligation object, not string ID
    public Obligation Obligation { get; set; }
    public Location Location { get; set; } // PHASE 6D: Track Location object (not ID) for familiarity bonuses
    public MentalSessionDeck Deck { get; set; }
    public int CurrentPhaseIndex { get; set; } = 0; // Which phase (0-based)

    // Session Resources
    public int CurrentAttention { get; set; } = 0;
    public int MaxAttention { get; set; } = 10;
    public int CurrentUnderstanding { get; set; } = 0;
    public int CurrentLeads { get; set; } = 0; // Generated by ACT, consumed by OBSERVE (determines draw count)
    public List<int> UnlockedTiers { get; set; } = new List<int> { 1 };
    // DOMAIN COLLECTION PRINCIPLE: List<T> instead of Dictionary
    public List<MentalCategoryCountEntry> CategoryCounts { get; set; } = new List<MentalCategoryCountEntry>();

    // Obligation-Local Resources (reset between obligations)
    public int CurrentProgress { get; set; } = 0; // Progress toward current phase threshold
    public int CurrentExposure { get; set; } = 0; // Cumulative disturbance/detection
    public int MaxExposure { get; set; } = 10; // Configured via EngagementType
    public int VictoryThreshold { get; set; } = 20; // Configured via EngagementType
    // DOMAIN COLLECTION PRINCIPLE: List<T> instead of Dictionary
    public List<DiscoveryEntry> Discoveries { get; set; } = new List<DiscoveryEntry>();

    // Timing
    public int TimeSegmentsSpent { get; set; } = 0;

    // Tier and Category Methods
    public int GetUnlockedMaxDepth()
    {
        return UnlockedTiers.Max() * 2;
    }

    public int GetCategoryCount(MentalCategory category)
    {
        return CategoryCounts.FirstOrDefault(e => e.Category == category)?.Count ?? 0;
    }

    public void IncrementCategoryCount(MentalCategory category)
    {
        MentalCategoryCountEntry entry = CategoryCounts.FirstOrDefault(e => e.Category == category);
        if (entry != null)
        {
            entry.Count++;
        }
        else
        {
            CategoryCounts.Add(new MentalCategoryCountEntry { Category = category, Count = 1 });
        }
    }

    // Facade helper methods
    public bool ShouldEnd()
    {
        // ONLY check failure condition - Exposure threshold reached
        // Victory condition (SituationCard play) is handled by facade
        return CurrentExposure >= MaxExposure;
    }

    public int GetDrawCount()
    {
        return CurrentLeads; // Draw exactly CurrentLeads (generated by ACT, consumed by OBSERVE)
    }
}

/// <summary>
/// Discovery types (for categorization)
/// </summary>
public enum DiscoveryType
{
    Structural,    // Physical features, architectural elements
    Historical,    // Past events, documented information
    Environmental, // Natural conditions, spatial layout
    Social,        // People involved, relationships
    Hidden         // Secrets, concealed information
}

/// <summary>
/// Mental category count entry for session tracking.
/// DOMAIN COLLECTION PRINCIPLE: Used in List instead of Dictionary.
/// </summary>
public class MentalCategoryCountEntry
{
    public MentalCategory Category { get; set; }
    public int Count { get; set; }
}

/// <summary>
/// Physical category count entry for session tracking.
/// DOMAIN COLLECTION PRINCIPLE: Used in List instead of Dictionary.
/// </summary>
public class PhysicalCategoryCountEntry
{
    public PhysicalCategory Category { get; set; }
    public int Count { get; set; }
}

/// <summary>
/// Discovery entry for session tracking.
/// DOMAIN COLLECTION PRINCIPLE: Used in List instead of Dictionary.
/// </summary>
public class DiscoveryEntry
{
    public DiscoveryType Type { get; set; }
    public List<string> Discoveries { get; set; } = new List<string>();
}

