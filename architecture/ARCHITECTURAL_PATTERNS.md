# ARCHITECTURAL PATTERNS

Comprehensive guide to the architectural patterns used in Wayfarer. All patterns support the core principle: clean separation of concerns, strong typing, and explicit data flow.

---

## BACKEND/FRONTEND SEPARATION PATTERN

The Backend/Frontend Separation pattern ensures that game logic (backend) and player-facing presentation (frontend) remain completely independent. Backend returns domain semantics, frontend transforms those semantics into visual presentation.

### Pattern Definition

**Backend Responsibility:**
- Model domain entities and relationships
- Calculate game state and validity
- Determine WHAT information the player needs
- Return domain values (enums, integers, booleans, descriptions)

**Frontend Responsibility:**
- Transform domain state into visual presentation
- Decide HOW information is displayed
- Map domain concepts to visual representations (colors, icons, layout)
- Generate all display text and styling

**Communication:**
- Backend → Frontend: ViewModels containing domain enums and values
- Frontend → Backend: User intents and domain actions only
- Never: Presentation details flowing from backend

### Violation Patterns

#### Violation 1: CSS Classes in Backend

Backend code selecting CSS classes violates the principle because it makes frontend decisions in backend code.

A TravelStatusViewModel that contains a FocusClass property storing CSS class names represents improper backend responsibility. When a service method retrieves the player's carried weight and creates a view model, it should not evaluate whether weight exceeds thresholds like 80 or 60 and assign corresponding CSS classes like "danger" or "warning". The view model structure itself should not contain properties designed to hold styling information.

**Problems:**
- Backend knows CSS class names (tight coupling to frontend)
- Cannot change styling without modifying backend
- Frontend has no control over presentation
- Tests must mock CSS classes

**Root cause:** Backend calculated "this is dangerous" and decided to express it as CSS, but that's a frontend concern.

#### Violation 2: Icon Names Selected by Backend

Backend code choosing which icon to display violates the principle because icons are visual presentation.

A ResourceDisplayViewModel that includes an IconName property represents backend overreach into visual decisions. When a service retrieves resource information, it should not contain logic that maps resource types to specific icon filenames like "coins", "health-normal", "biceps", or "sparkles". The view model should carry the domain concept (resource type) but should not perform the translation to visual representation (icon selection).

**Problems:**
- Backend knows icon filenames (tight coupling)
- Adding new resource types requires backend changes
- Frontend cannot override icon choices
- Hard to test icon selection independently

**Root cause:** Backend determined "this is coins" and decided how to show it visually, but that's purely frontend logic.

#### Violation 3: Display Text Generated by Backend

Backend code generating player-facing text violates the principle because text formatting is presentation.

An InteractionOptionViewModel with a DisplayText property that contains formatted strings represents backend responsibility creep. When a LocationFacade processes conversation types, it should not perform string matching against values like "friendly_chat", "request", or "delivery" and transform them into display-ready text like "Friendly Chat", "Request Information", or "Deliver Letter". The view model should not contain properties that hold pre-formatted text intended for direct player display.

**Problems:**
- Backend has hardcoded strings for display
- Cannot localize without modifying backend
- Designers cannot adjust wording without code changes
- Mixing domain logic (which types exist) with presentation (how to display them)

**Root cause:** Backend determined what action types exist, then decided how to present them as text. The first is backend's job. The second is frontend's.

#### Violation 4: Message Tokens with Presentation Metadata

Backend code embedding presentation tokens in messages violates the principle by mixing game logic and presentation.

When backend services generate system messages, they should not include presentation tokens that specify icon names like "{icon:coins}" embedded within the message string alongside data placeholders for amounts and item names. Similarly, backend should not construct display-formatted strings with specific layout patterns like pipe-separated lists combining resource labels with their values. These approaches embed visual formatting decisions and icon selection directly into game logic code.

**Problems:**
- Backend deciding how messages should be formatted
- Icon names hardcoded in game logic
- Message format tightly couples backend and frontend
- Cannot change message layout without backend code

**Root cause:** Backend should describe what happened (spent coins, lost health). Frontend should decide how to show it.

### Correct Pattern

The correct pattern separates concerns into three layers:

**Layer 1: Domain** (Backend - Only Game Logic)

Domain enums define the categorical concepts that exist in the game world. A ConversationAction enum establishes action types like FriendlyChat, ServiceRequest, Delivery, and Negotiation. A ResourceType enum defines resource categories like Coins, Stamina, Health, and Focus. These enums represent pure game concepts without any presentation information.

**Layer 2: Backend ViewModel** (Data Transport - Domain Values Only)

ViewModels carry domain data between backend and frontend without presentation decisions. An InteractionOptionViewModel contains an InteractionId identifier, an ActionType property holding a ConversationAction enum value, and an NPCId reference. The ActionType property stores the domain enum directly, not pre-formatted display text. Similarly, a ResourceDisplayViewModel contains a Type property holding a ResourceType enum value and an Amount integer. The Type property carries the semantic meaning (what kind of resource) without specifying how to visually represent it (which icon to show).

**Layer 3: Frontend** (Presentation - All Display Logic)

Frontend components receive domain enums and transform them into visual presentation. Razor components check enum values and generate appropriate HTML structure including button elements with semantic CSS classes and Icon components with specific icon names and styling classes. Helper methods map domain enums to display strings, converting ConversationAction enum values into player-facing text like "Friendly Chat", "Request Information", "Deliver Letter", or "Make Amends". Similar helper methods map ResourceType enum values to icon filenames like "coins", "biceps", "health-normal", or "cut-diamond". All presentation logic including icon selection, text generation, and CSS class application occurs exclusively in frontend code.

### Application Examples

#### Example 1: Travel Status Display

**WRONG:**

Backend calculates load and decides presentation. The TravelStatusViewModel contains properties for pre-formatted display strings like "Light load", "Medium load (+1 stamina)", or "Heavy load (+2 stamina)" stored in a FocusStatus property. It also contains a FocusClass property holding CSS class names like "warning" or "danger". When the backend creates this view model, it evaluates weight thresholds (weight greater than 80, greater than 50) and directly assigns both the display text and the styling class based on those conditions. This couples presentation decisions to backend logic.

**RIGHT:**

Backend provides raw domain values, frontend makes all presentation decisions. The TravelStatusViewModel contains only domain data: TotalWeight as an integer, MaxCapacity as an integer, and StaminaPenalty as an integer calculated by domain logic. The backend returns this view model with simple numeric values and the result of business logic calculations (stamina penalty formula). The frontend receives this domain data and performs all presentation transformation. Razor code calculates the weight-to-capacity ratio, determines the appropriate CSS class based on ratio thresholds (greater than 0.8 yields "danger", greater than 0.6 yields "warning"), and generates status text with descriptive load levels and stamina costs. The rendered output combines an Icon component using "backpack" with the "resource-item" class, wrapped in a div with dynamically-applied CSS classes and calculated status text.

#### Example 2: NPC Relationship Display

**WRONG:**

Backend generates relationship descriptions and CSS classes. The NPCInteractionViewModel contains a RelationshipDescription property holding pre-formatted text and a RelationshipClass property containing CSS class names. Backend code uses a switch expression to evaluate the ConnectionState enum (Friendly, Neutral, Hostile) and generates corresponding display strings like "This NPC likes you", "This NPC is neutral to you", or "This NPC dislikes you". The backend also converts the enum to a lowercase string for use as a CSS class. The view model stores these presentation-ready strings instead of the raw domain enum.

**RIGHT:**

Backend returns domain enum, frontend generates all presentation. The NPCInteractionViewModel contains an NPCId identifier, a RelationshipState property holding the ConnectionState enum directly, and a ConnectionTokens integer. The backend populates this view model by calling domain logic methods to determine the connection state and token count, but performs no text generation or styling decisions. Frontend Razor helpers implement presentation mapping. A GetRelationshipDescription method accepts the ConnectionState enum and returns appropriate text for each state (Friendly maps to "This NPC likes you", Neutral maps to "This NPC is neutral", Hostile maps to "This NPC dislikes you"). A GetRelationshipIcon method maps connection states to icon names (Friendly maps to "hearts", Neutral to "scales", Hostile to "hazard-sign"). The Razor component renders a div with dynamically-generated CSS classes, an Icon component with the mapped icon name and state-specific styling, the relationship description text, and conditionally displays connection tokens when present using the "brain" icon and token count.

#### Example 3: Action Availability Messages

**WRONG:**

Backend generates user-facing restriction messages. The ActionAvailabilityViewModel contains a boolean IsAvailable flag and an UnavailabilityMessage property holding pre-formatted text. Backend code evaluates restriction types using string matching (checking for "stamina", "coins", "item", "tutorial") and generates corresponding player-facing messages like "You're too tired for this", "You can't afford this", or "You don't have the required item". The view model carries these display-ready strings instead of semantic reason codes.

**RIGHT:**

Backend returns domain reason enum, frontend generates messages. The backend defines an ActionRestrictionReason enum with values like InsufficientStamina, InsufficientCoins, RequiredItemMissing, TutorialRestriction, and TimeBlockRestriction. The ActionAvailabilityViewModel contains an IsAvailable boolean and a nullable RestrictionReason property holding the enum value. Backend populates this view model by calling domain logic to calculate why the action is unavailable, returning the semantic reason without text generation. Frontend implements a GetRestrictionMessage helper method that maps each ActionRestrictionReason enum value to appropriate player-facing text (InsufficientStamina maps to "You're too tired for this action", InsufficientCoins to "You can't afford this", RequiredItemMissing to "You don't have the required item"). The Razor component checks availability and conditionally renders an action-unavailable div containing a padlock icon with negative styling and the mapped restriction message.

### Benefits

**Testability:**
- Backend unit tests never check CSS, icons, or display text
- Tests verify game logic only
- Frontend can be tested independently

**Maintainability:**
- Changing how something looks requires frontend changes only
- Changing game logic never requires UI modifications
- Clear boundaries prevent confusion about responsibility

**Designer Autonomy:**
- Designers can modify presentation without knowing backend
- Content creators can edit display strings independently
- Icons can be swapped without code changes

**Scalability:**
- Adding new action types requires adding enum value + frontend display method
- No backend modifications to add visual variants
- Frontend complexity isolated from domain complexity

### Anti-Patterns

**Anti-Pattern 1: Display Metadata in IDs**

Encoding presentation information within entity identifiers violates separation of concerns. An NPC identifier that embeds relationship state and icon names like "npc_friendly_hearts" conflates entity identity with visual representation. Backend code that parses these identifiers using string matching to extract presentation hints (checking if the ID contains "friendly" to determine styling) couples domain logic to display decisions. Domain enums should carry semantic meaning separately from identity. See ID ANTIPATTERN section in CLAUDE.md.

**Anti-Pattern 2: String-Based Display Selection**

Using string properties to route display selection mixes domain semantics with presentation logic. A DisplayType property storing string values like "coins" or "health" requires backend code to establish the mapping between these strings and their visual representations. Frontend code that switches on these string values to select icons creates brittle coupling between backend string conventions and frontend presentation choices. Domain enums with frontend mapping methods provide type-safe semantic categories without embedding display decisions in backend code.

**Anti-Pattern 3: Domain Logic Hidden in Display Methods**

Embedding business logic within frontend display helper methods inverts architectural responsibilities. A GetActionCost method that calculates the actual cost by retrieving base cost, checking for cost-modifying player modifiers, and applying multiplication or zeroing logic performs domain calculations that belong in backend services. Frontend helpers should receive already-calculated costs from backend and only perform formatting transformation (converting integers to display strings, adding currency symbols, etc.). Calculate all costs in backend using domain logic, return numeric results in view models, and let frontend handle only visual formatting.

---

## RELATED PATTERNS

This pattern works alongside other core patterns:

**ID Antipattern (CLAUDE.md):** IDs are for uniqueness/debugging only. Never encode presentation or logic in IDs. See Backend/Frontend Separation for the correct approach - use domain enums instead.

**Generic Property Modification Antipattern (CLAUDE.md):** Never use generic `PropertyName` strings for updates. Map domain concepts to explicit properties. Frontend presentation is the frontend's responsibility, not a backend property.

**Icon System (CLAUDE.md):** Complements Backend/Frontend Separation by establishing HOW frontend should handle icons (SVG from game-icons.net via Icon component). This pattern establishes WHEN and WHERE icon selection happens (frontend only).

**HIGHLANDER (08_crosscutting_concepts.md):** One concept, one implementation. Don't have ActionType enum in backend and separate display string logic in frontend - instead have ActionType flow through both with clear responsibility boundaries.

---

## ENFORCEMENT

**In Code Review:**

```
REJECT PR if:
- [ ] ViewModel has CssClass, StyleClass, or IconClass properties
- [ ] ViewModel has IconName, IconId, or Icon properties (except as description of icon, e.g., for documentation)
- [ ] Backend service contains hardcoded display strings ("Friendly Chat", "Warning", etc.)
- [ ] Service switches on display type or icon name
- [ ] Message tokens contain presentation ({icon:coins}, {css:danger})
- [ ] CSS class names appear outside Razor components or CSS files

APPROVE PR if:
- [ ] Domain enums flow from backend to frontend unchanged
- [ ] ViewModels contain only domain values (int, string, bool, enums)
- [ ] All display text generated in frontend helpers or components
- [ ] All CSS classes applied in Razor components or CSS files
- [ ] All icons selected in frontend only
- [ ] System messages contain domain data only
```

**Verification Commands:**

Code review enforcement uses grep to detect violations. Search ViewModel files for properties named CssClass or StyleClass to find backend styling decisions. Search backend service and subsystem code for Icon property assignments excluding frontend and component files to detect backend icon selection. Search backend code for hardcoded display strings like "Friendly Chat", "Medium load", or "Too tired" while filtering out frontend and Razor files to find text generation in services. Search subsystem code for presentation token patterns like "{icon:" to locate embedded display metadata in system messages.

**Testing Checklist:**

- Backend unit tests never reference CSS, icons, or display text
- Backend tests verify domain logic and state changes
- Frontend tests (if present) verify presentation mapping only
- No tests check "CSS class is 'danger'" - test "weight > threshold" instead

---

## PATTERN STRENGTH

This pattern is **MANDATORY** in Wayfarer because:

1. **Game systems are complex enough** that mixing concerns creates overwhelming interdependencies
2. **Multiple UI outputs likely** (console, mobile, different themes) each need independent presentation
3. **Non-technical content creators** need to modify display text without understanding domain logic
4. **Artist/designer iteration cycles** must be independent of programmer cycles
5. **Testing becomes impossible** if presentation logic is scattered through domain services

Treating this as optional leads to "spaghetti code" where display logic progressively infects domain services until they become unmaintainable.

---
