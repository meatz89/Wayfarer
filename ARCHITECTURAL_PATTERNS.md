# ARCHITECTURAL PATTERNS

Comprehensive guide to the architectural patterns used in Wayfarer. All patterns support the core principle: clean separation of concerns, strong typing, and explicit data flow.

---

## BACKEND/FRONTEND SEPARATION PATTERN

The Backend/Frontend Separation pattern ensures that game logic (backend) and player-facing presentation (frontend) remain completely independent. Backend returns domain semantics, frontend transforms those semantics into visual presentation.

### Pattern Definition

**Backend Responsibility:**
- Model domain entities and relationships
- Calculate game state and validity
- Determine WHAT information the player needs
- Return domain values (enums, integers, booleans, descriptions)

**Frontend Responsibility:**
- Transform domain state into visual presentation
- Decide HOW information is displayed
- Map domain concepts to visual representations (colors, icons, layout)
- Generate all display text and styling

**Communication:**
- Backend → Frontend: ViewModels containing domain enums and values
- Frontend → Backend: User intents and domain actions only
- Never: Presentation details flowing from backend

### Violation Patterns

#### Violation 1: CSS Classes in Backend

Backend code selecting CSS classes violates the principle because it makes frontend decisions in backend code.

**Problem:** ViewModels contain CSS class name properties that backend services populate. Backend calculates thresholds and directly maps them to presentation classes like "danger", "warning", or empty string. This creates tight coupling between backend and frontend styling systems.

**Why It's Wrong:**
- Backend must know CSS class names (tight coupling to frontend)
- Cannot change styling without modifying backend logic
- Frontend has no control over presentation decisions
- Tests must verify CSS class names instead of domain logic
- Changing visual design requires backend code changes

**Root Cause:** Backend calculated semantic meaning (this is dangerous) and then decided how to express it visually (CSS class), but visual expression is a frontend concern.

#### Violation 2: Icon Names Selected by Backend

Backend code choosing which icon to display violates the principle because icons are visual presentation.

**Problem:** ViewModels contain icon name properties that backend selects based on resource type or entity state. Backend maps domain enums to specific icon filenames and passes those names to the frontend.

**Why It's Wrong:**
- Backend must know icon filenames (tight coupling)
- Adding new resource types requires backend changes for icon mapping
- Frontend cannot override icon choices
- Hard to test icon selection independently from domain logic
- Icon library changes require backend modifications

**Root Cause:** Backend determined semantic identity (this is coins) and then decided how to represent it visually (coins icon), but visual representation is purely frontend logic.

#### Violation 3: Display Text Generated by Backend

Backend code generating player-facing text violates the principle because text formatting is presentation.

**Problem:** Backend services contain hardcoded display strings like "Friendly Chat", "Request Information", "Deliver Letter". Backend switches on domain types and generates formatted text strings for frontend consumption.

**Why It's Wrong:**
- Backend has hardcoded strings for display
- Cannot localize without modifying backend services
- Designers cannot adjust wording without code changes
- Mixing domain logic (which types exist) with presentation (how to display them)
- A/B testing different wording requires backend deployment

**Root Cause:** Backend determined what action types exist (domain), then decided how to present them as text (presentation). The first is backend's job. The second is frontend's.

#### Violation 4: Message Tokens with Presentation Metadata

Backend code embedding presentation tokens in messages violates the principle by mixing game logic and presentation.

**Problem:** Message system accepts messages with presentation tokens like {icon:coins} or formatted display strings like "Health: X | Focus: Y | Stamina: Z". Backend decides not just what happened but how to visually represent it.

**Why It's Wrong:**
- Backend deciding how messages should be formatted visually
- Icon names hardcoded in game logic
- Message format tightly couples backend and frontend
- Cannot change message layout without backend code
- Presentation logic scattered across domain services

**Root Cause:** Backend should describe what happened (spent coins, lost health). Frontend should decide how to show it (with icon, in red, with separator).

### Correct Pattern

The correct pattern separates concerns into three layers:

**Layer 1: Domain (Backend - Only Game Logic)**

Domain entities define semantic enums that represent game concepts. Examples include ConversationAction enum with values like FriendlyChat, ServiceRequest, Delivery, Negotiation. ResourceType enum with values like Coins, Stamina, Health, Focus. These enums represent WHAT exists in the game world, not HOW to display it.

**Layer 2: Backend ViewModel (Data Transport - Domain Values Only)**

ViewModels contain domain enums and object references, never presentation metadata. An InteractionOptionViewModel contains ConversationAction enum value (not display text) and NPC object reference (not NPCId string). A ResourceDisplayViewModel contains ResourceType enum value (not icon name) and integer amount. ViewModels use object references instead of entity instance IDs, following the NO ENTITY INSTANCE IDs principle.

**Layer 3: Frontend (Presentation - All Display Logic)**

Frontend components receive domain enums and object references, then map them to visual presentation. Razor components check enum values and render appropriate icons, CSS classes, and display text. Helper methods map enums to presentation: ConversationAction.FriendlyChat becomes "Friendly Chat" text with shaking-hands icon and icon-positive class. ResourceType.Coins becomes coins icon with resource-coin class. All presentation decisions happen in frontend code only.

### Application Examples

#### Example 1: Travel Status Display

**WRONG Approach:**

Backend calculates carried weight and maximum capacity, then generates formatted display string like "Heavy load (+2 stamina)" or "Light load". Backend also selects CSS class names like "danger", "warning", or empty string. ViewModel contains both the formatted status text and the CSS class to apply. This violates separation because backend is making visual presentation decisions.

**RIGHT Approach:**

Backend calculates and returns raw domain values: total weight as integer, maximum capacity as integer, stamina penalty as integer. ViewModel contains only these numeric values representing game state. Frontend receives these values, calculates load ratio, determines appropriate CSS class based on ratio thresholds, generates display text based on load level, and applies icon selection. All presentation logic happens in frontend Razor components where it belongs.

#### Example 2: NPC Relationship Display

**WRONG Approach:**

Backend examines connection state and generates relationship description strings like "This NPC likes you", "This NPC is neutral to you", "This NPC dislikes you". Backend also generates CSS class names based on connection state using ToString and ToLower conversions. ViewModel contains both the formatted description text and CSS class name. This violates separation because display text generation is presentation.

**RIGHT Approach:**

Backend returns domain enum ConnectionState (Friendly, Neutral, Hostile) and NPC object reference. ViewModel contains enum value, object reference, and connection token count as integer. Frontend defines helper methods that map ConnectionState enum to display text, map ConnectionState enum to icon names, map ConnectionState enum to CSS classes. Frontend component uses these helpers to render appropriate icon, text, and styling based on domain state.

#### Example 3: Action Availability Messages

**WRONG Approach:**

Backend determines why an action is unavailable, then generates user-facing message strings like "You're too tired for this", "You can't afford this", "You don't have the required item". Backend switches on restriction type string values and produces formatted messages. ViewModel contains IsAvailable boolean and unavailability message string. This violates separation because error message generation is presentation.

**RIGHT Approach:**

Backend defines ActionRestrictionReason enum with semantic values: InsufficientStamina, InsufficientCoins, RequiredItemMissing, TutorialRestriction, TimeBlockRestriction. Backend calculates which restriction applies and returns the enum value. ViewModel contains IsAvailable boolean and optional ActionRestrictionReason enum. Frontend defines helper method that maps each enum value to user-friendly message string. Frontend component calls helper to generate display text when needed.

### Benefits

**Testability:**
- Backend unit tests verify game logic only, never checking CSS, icons, or display text
- Tests verify domain calculations (weight > threshold) not presentation decisions (class = "danger")
- Frontend can be tested independently for presentation logic
- Clear boundaries make test scope obvious

**Maintainability:**
- Changing how something looks requires frontend changes only
- Changing game logic never requires UI modifications
- Visual redesigns don't touch domain services
- Clear boundaries prevent confusion about responsibility

**Designer Autonomy:**
- Designers can modify presentation without knowing backend
- Content creators can edit display strings independently
- Icons can be swapped without code changes
- A/B testing wording requires frontend changes only

**Scalability:**
- Adding new action types requires adding enum value plus frontend display method
- No backend modifications to add visual variants
- Frontend complexity isolated from domain complexity
- Multiple frontend implementations (mobile, console) consume same backend

### Anti-Patterns

**Anti-Pattern 1: Display Metadata in IDs**

Encoding presentation information in entity ID strings violates both Backend/Frontend Separation and NO ENTITY INSTANCE IDs principle. Example: using ID like "npc_friendly_hearts" and parsing it to extract "friendly" for styling. IDs must never encode presentation metadata. Use domain enums instead. See ID ANTIPATTERN section in CLAUDE.md for complete explanation.

**Anti-Pattern 2: String-Based Display Selection**

Using string property called DisplayType with values like "coins" or "health" to drive frontend icon selection. Backend sets DisplayType string, frontend switches on string value to select icon. This violates type safety and makes backend responsible for presentation routing. Use domain enums with frontend mapping instead. Type-safe enums prevent typos and make intent explicit.

**Anti-Pattern 3: Domain Logic Hidden in Display Methods**

Placing business logic calculations inside frontend display helper methods. Example: display helper that calculates action cost including modifier application, then formats as string. This violates separation because game logic (cost calculation with modifiers) belongs in backend. Backend should calculate final cost as integer. Frontend should only format the integer for display.

---

## RELATED PATTERNS

This pattern works alongside other core patterns:

**ID Antipattern (CLAUDE.md):** IDs are for uniqueness/debugging only. Never encode presentation or logic in IDs. See Backend/Frontend Separation for the correct approach - use domain enums instead.

**Generic Property Modification Antipattern (CLAUDE.md):** Never use generic PropertyName strings for updates. Map domain concepts to explicit properties. Frontend presentation is the frontend's responsibility, not a backend property.

**Icon System (CLAUDE.md):** Complements Backend/Frontend Separation by establishing HOW frontend should handle icons (SVG from game-icons.net via Icon component). This pattern establishes WHEN and WHERE icon selection happens (frontend only).

**HIGHLANDER (08_crosscutting_concepts.md):** One concept, one implementation. Don't have ActionType enum in backend and separate display string logic in frontend - instead have ActionType flow through both with clear responsibility boundaries.

---

## ENFORCEMENT

**In Code Review:**

Code review checklist for Backend/Frontend Separation:

REJECT PR if ANY of the following violations exist:
- ViewModel has CssClass, StyleClass, or IconClass properties
- ViewModel has IconName, IconId, or Icon properties (except as description of icon for documentation)
- Backend service contains hardcoded display strings ("Friendly Chat", "Warning", "Heavy load", etc.)
- Service switches on display type or icon name
- Message tokens contain presentation ({icon:coins}, {css:danger})
- CSS class names appear outside Razor components or CSS files

APPROVE PR if ALL of the following conditions met:
- Domain enums flow from backend to frontend unchanged
- ViewModels contain only domain values (int, string, bool, enums, object references)
- All display text generated in frontend helpers or components
- All CSS classes applied in Razor components or CSS files
- All icons selected in frontend only
- System messages contain domain data only

**Verification Commands:**

Search codebase for common violations using these commands:

Find CSS class properties in ViewModels by searching ViewModel directory for CssClass or StyleClass properties. This reveals backend setting presentation classes.

Find icon properties in backend services by searching Services and Subsystems directories for Icon property assignments, excluding references to Icon component or Frontend code. This reveals backend selecting icons.

Find hardcoded display strings in backend by searching Services and Subsystems for common display text like "Friendly Chat", "Medium load", "Too tired", excluding Frontend and Razor code. This reveals backend generating presentation text.

Find presentation tokens in messages by searching Subsystems for {icon: token syntax. This reveals backend embedding presentation metadata in messages.

**Testing Checklist:**

- Backend unit tests never reference CSS, icons, or display text
- Backend tests verify domain logic and state changes
- Frontend tests (if present) verify presentation mapping only
- No tests check "CSS class is 'danger'" - test "weight > threshold" instead

---

## PATTERN STRENGTH

This pattern is **MANDATORY** in Wayfarer because:

1. **Game systems are complex enough** that mixing concerns creates overwhelming interdependencies
2. **Multiple UI outputs likely** (console, mobile, different themes) each need independent presentation
3. **Non-technical content creators** need to modify display text without understanding domain logic
4. **Artist/designer iteration cycles** must be independent of programmer cycles
5. **Testing becomes impossible** if presentation logic is scattered through domain services

Treating this as optional leads to "spaghetti code" where display logic progressively infects domain services until they become unmaintainable.

---
