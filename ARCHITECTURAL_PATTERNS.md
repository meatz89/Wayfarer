# ARCHITECTURAL PATTERNS

Comprehensive guide to the architectural patterns used in Wayfarer. All patterns support the core principle: clean separation of concerns, strong typing, and explicit data flow.

---

## BACKEND/FRONTEND SEPARATION PATTERN

The Backend/Frontend Separation pattern ensures that game logic (backend) and player-facing presentation (frontend) remain completely independent. Backend returns domain semantics, frontend transforms those semantics into visual presentation.

### Pattern Definition

**Backend Responsibility:**
- Model domain entities and relationships
- Calculate game state and validity
- Determine WHAT information the player needs
- Return domain values (enums, integers, booleans, descriptions)

**Frontend Responsibility:**
- Transform domain state into visual presentation
- Decide HOW information is displayed
- Map domain concepts to visual representations (colors, icons, layout)
- Generate all display text and styling

**Communication:**
- Backend → Frontend: ViewModels containing domain enums and values
- Frontend → Backend: User intents and domain actions only
- Never: Presentation details flowing from backend

### Violation Patterns

#### Violation 1: CSS Classes in Backend

Backend code selecting CSS classes violates the principle because it makes frontend decisions in backend code.

```csharp
// VIOLATION
public class TravelStatusViewModel
{
    public string FocusClass { get; set; } // CSS class name
}

public TravelStatusViewModel GetTravelStatus()
{
    int weight = player.CarriedWeight;
    return new TravelStatusViewModel
    {
        Weight = weight,
        MaxCapacity = 100,
        FocusClass = weight > 80 ? "danger" : weight > 60 ? "warning" : ""
    };
}
```

**Problems:**
- Backend knows CSS class names (tight coupling to frontend)
- Cannot change styling without modifying backend
- Frontend has no control over presentation
- Tests must mock CSS classes

**Root cause:** Backend calculated "this is dangerous" and decided to express it as CSS, but that's a frontend concern.

#### Violation 2: Icon Names Selected by Backend

Backend code choosing which icon to display violates the principle because icons are visual presentation.

```csharp
// VIOLATION
public class ResourceDisplayViewModel
{
    public int Amount { get; set; }
    public string IconName { get; set; } // Backend choosing icon
}

public ResourceDisplayViewModel GetResourceDisplay(ResourceType type)
{
    return new ResourceDisplayViewModel
    {
        Amount = player.GetResourceAmount(type),
        IconName = type switch
        {
            ResourceType.Coins => "coins",
            ResourceType.Health => "health-normal",
            ResourceType.Stamina => "biceps",
            _ => "sparkles"
        }
    };
}
```

**Problems:**
- Backend knows icon filenames (tight coupling)
- Adding new resource types requires backend changes
- Frontend cannot override icon choices
- Hard to test icon selection independently

**Root cause:** Backend determined "this is coins" and decided how to show it visually, but that's purely frontend logic.

#### Violation 3: Display Text Generated by Backend

Backend code generating player-facing text violates the principle because text formatting is presentation.

```csharp
// VIOLATION
public class InteractionOptionViewModel
{
    public string DisplayText { get; set; } // Backend generating display text
}

// In LocationFacade
string displayText = conversationType switch
{
    "friendly_chat" => "Friendly Chat",
    "request" => "Request Information",
    "delivery" => "Deliver Letter",
    _ => "Talk"
};

return new InteractionOptionViewModel
{
    DisplayText = displayText
};
```

**Problems:**
- Backend has hardcoded strings for display
- Cannot localize without modifying backend
- Designers cannot adjust wording without code changes
- Mixing domain logic (which types exist) with presentation (how to display them)

**Root cause:** Backend determined what action types exist, then decided how to present them as text. The first is backend's job. The second is frontend's.

#### Violation 4: Message Tokens with Presentation Metadata

Backend code embedding presentation tokens in messages violates the principle by mixing game logic and presentation.

```csharp
// VIOLATION
_messageSystem.AddSystemMessage("{icon:coins} Spent {0} coins on {1}", amount, item);

// VIOLATION - Formatting for display
_messageSystem.AddSystemMessage($"Health: {health} | Focus: {focus} | Stamina: {stamina}");
```

**Problems:**
- Backend deciding how messages should be formatted
- Icon names hardcoded in game logic
- Message format tightly couples backend and frontend
- Cannot change message layout without backend code

**Root cause:** Backend should describe what happened (spent coins, lost health). Frontend should decide how to show it.

### Correct Pattern

The correct pattern separates concerns into three layers:

**Layer 1: Domain** (Backend - Only Game Logic)
```csharp
public enum ConversationAction
{
    FriendlyChat,
    ServiceRequest,
    Delivery,
    Negotiation
}

public enum ResourceType
{
    Coins,
    Stamina,
    Health,
    Focus
}
```

**Layer 2: Backend ViewModel** (Data Transport - Domain Values Only)
```csharp
public class InteractionOptionViewModel
{
    public ConversationAction ActionType { get; set; } // Domain enum, not display text
    public NPC TargetNPC { get; set; } // Object reference, NOT NPCId string
}

public class ResourceDisplayViewModel
{
    public ResourceType Type { get; set; } // Domain enum, not icon name
    public int Amount { get; set; }
}

// NOTE: ViewModels contain object references and domain enums, NEVER entity instance IDs
```

**Layer 3: Frontend** (Presentation - All Display Logic)
```csharp
// Razor component
@if (Model.ActionType == ConversationAction.FriendlyChat)
{
    <button class="interaction-action interaction-friendly">
        <Icon Name="shaking-hands" CssClass="icon-positive" />
        Friendly Chat
    </button>
}

// Or in component code
private string GetActionDisplayText(ConversationAction action) => action switch
{
    ConversationAction.FriendlyChat => "Friendly Chat",
    ConversationAction.ServiceRequest => "Request Information",
    ConversationAction.Delivery => "Deliver Letter",
    ConversationAction.Negotiation => "Make Amends",
    _ => "Interact"
};

private string GetResourceIcon(ResourceType type) => type switch
{
    ResourceType.Coins => "coins",
    ResourceType.Stamina => "biceps",
    ResourceType.Health => "health-normal",
    ResourceType.Focus => "cut-diamond",
    _ => "sparkles"
};
```

### Application Examples

#### Example 1: Travel Status Display

**WRONG:**
```csharp
// Backend calculates load and decides presentation
public class TravelStatusViewModel
{
    public string FocusStatus { get; set; } // "Light load", "Medium load (+1 stamina)", etc.
    public string FocusClass { get; set; } // CSS class: "", "warning", "danger"
}

return new TravelStatusViewModel
{
    Weight = weight,
    MaxCapacity = maxCapacity,
    FocusStatus = weight > 80 ? "Heavy load (+2 stamina)" : weight > 50 ? "Medium load (+1 stamina)" : "Light load",
    FocusClass = weight > 80 ? "danger" : weight > 50 ? "warning" : ""
};
```

**RIGHT:**
```csharp
// Backend provides raw values, frontend decides presentation
public class TravelStatusViewModel
{
    public int TotalWeight { get; set; }
    public int MaxCapacity { get; set; }
    public int StaminaPenalty { get; set; }
}

return new TravelStatusViewModel
{
    TotalWeight = weight,
    MaxCapacity = maxCapacity,
    StaminaPenalty = CalculateStaminaPenalty(weight) // Domain logic only
};

// Frontend (Razor)
@{
    double ratio = (double)Model.TotalWeight / Model.MaxCapacity;
    string cssClass = ratio > 0.8 ? "danger" : ratio > 0.6 ? "warning" : "";
    string statusText = ratio > 0.8 ? "Heavy load (+2 stamina)" :
                       ratio > 0.6 ? "Medium load (+1 stamina)" :
                       "Light load";
}

<div class="travel-status @cssClass">
    <Icon Name="backpack" CssClass="resource-item" />
    @statusText
</div>
```

#### Example 2: NPC Relationship Display

**WRONG:**
```csharp
// Backend generates relationship description
public class NPCInteractionViewModel
{
    public string RelationshipDescription { get; set; }
    public string RelationshipClass { get; set; }
}

var description = connectionState switch
{
    ConnectionState.Friendly => "This NPC likes you",
    ConnectionState.Neutral => "This NPC is neutral to you",
    ConnectionState.Hostile => "This NPC dislikes you",
};

return new NPCInteractionViewModel
{
    RelationshipDescription = description,
    RelationshipClass = connectionState.ToString().ToLower()
};
```

**RIGHT:**
```csharp
// Backend returns domain value, frontend generates presentation
public class NPCInteractionViewModel
{
    public NPC TargetNPC { get; set; } // Object reference, NOT NPCId string
    public ConnectionState RelationshipState { get; set; } // Domain enum only
    public int ConnectionTokens { get; set; }
}

return new NPCInteractionViewModel
{
    TargetNPC = npc, // Object reference
    RelationshipState = GetConnectionState(npc), // Domain logic
    ConnectionTokens = npc.GetTokenCount()
};

// Frontend (Razor helper)
private string GetRelationshipDescription(ConnectionState state) => state switch
{
    ConnectionState.Friendly => "This NPC likes you",
    ConnectionState.Neutral => "This NPC is neutral",
    ConnectionState.Hostile => "This NPC dislikes you",
    _ => "Unknown relationship"
};

private string GetRelationshipIcon(ConnectionState state) => state switch
{
    ConnectionState.Friendly => "hearts",
    ConnectionState.Neutral => "scales",
    ConnectionState.Hostile => "hazard-sign",
    _ => "question"
};

// In component
<div class="npc-relationship @GetRelationshipState(Model.RelationshipState)">
    <Icon Name="@GetRelationshipIcon(Model.RelationshipState)"
          CssClass="icon-@GetRelationshipState(Model.RelationshipState)" />
    @GetRelationshipDescription(Model.RelationshipState)
    @if (Model.ConnectionTokens > 0)
    {
        <span class="tokens">
            <Icon Name="brain" /> @Model.ConnectionTokens
        </span>
    }
</div>
```

#### Example 3: Action Availability Messages

**WRONG:**
```csharp
// Backend generates restriction messages
public class ActionAvailabilityViewModel
{
    public bool IsAvailable { get; set; }
    public string UnavailabilityMessage { get; set; }
}

string message = restrictionType switch
{
    "stamina" => "You're too tired for this",
    "coins" => "You can't afford this",
    "item" => "You don't have the required item",
    "tutorial" => "This is blocked during tutorial",
    _ => "This action is unavailable"
};

return new ActionAvailabilityViewModel
{
    IsAvailable = false,
    UnavailabilityMessage = message
};
```

**RIGHT:**
```csharp
// Backend returns domain reason, frontend generates message
public enum ActionRestrictionReason
{
    InsufficientStamina,
    InsufficientCoins,
    RequiredItemMissing,
    TutorialRestriction,
    TimeBlockRestriction
}

public class ActionAvailabilityViewModel
{
    public bool IsAvailable { get; set; }
    public ActionRestrictionReason? RestrictionReason { get; set; }
}

return new ActionAvailabilityViewModel
{
    IsAvailable = false,
    RestrictionReason = CalculateRestrictionReason(player, action) // Domain logic
};

// Frontend (Razor helper)
private string GetRestrictionMessage(ActionRestrictionReason reason) => reason switch
{
    ActionRestrictionReason.InsufficientStamina => "You're too tired for this action",
    ActionRestrictionReason.InsufficientCoins => "You can't afford this",
    ActionRestrictionReason.RequiredItemMissing => "You don't have the required item",
    ActionRestrictionReason.TutorialRestriction => "This is blocked during the tutorial",
    ActionRestrictionReason.TimeBlockRestriction => "This action isn't available now",
    _ => "This action is unavailable"
};

// In component
@if (!Model.IsAvailable && Model.RestrictionReason.HasValue)
{
    <div class="action-unavailable">
        <Icon Name="padlock" CssClass="icon-negative" />
        @GetRestrictionMessage(Model.RestrictionReason.Value)
    </div>
}
```

### Benefits

**Testability:**
- Backend unit tests never check CSS, icons, or display text
- Tests verify game logic only
- Frontend can be tested independently

**Maintainability:**
- Changing how something looks requires frontend changes only
- Changing game logic never requires UI modifications
- Clear boundaries prevent confusion about responsibility

**Designer Autonomy:**
- Designers can modify presentation without knowing backend
- Content creators can edit display strings independently
- Icons can be swapped without code changes

**Scalability:**
- Adding new action types requires adding enum value + frontend display method
- No backend modifications to add visual variants
- Frontend complexity isolated from domain complexity

### Anti-Patterns

**Anti-Pattern 1: Display Metadata in IDs**
```csharp
// FORBIDDEN - Encoding presentation in ID
public string Id { get; set; } // = "npc_friendly_hearts"

// Parsing presentation from ID
if (npcId.Contains("friendly")) { /* show positive styling */ }
```

Use domain enums instead. See ID ANTIPATTERN section in CLAUDE.md.

**Anti-Pattern 2: String-Based Display Selection**
```csharp
// FORBIDDEN - String field for display routing
public string DisplayType { get; set; } // = "coins" or "health"

switch (displayType)
{
    case "coins": icon = "coins"; break;
    case "health": icon = "health-normal"; break;
}
```

Use domain enums with frontend mapping instead.

**Anti-Pattern 3: Domain Logic Hidden in Display Methods**
```csharp
// FORBIDDEN - Business logic in display helper
private string GetActionCost(Action action)
{
    int cost = action.BaseCost;
    if (player.HasModifier("double_cost")) cost *= 2;
    if (player.HasModifier("free_action")) cost = 0;
    return cost.ToString();
}
```

Calculate cost in backend, frontend only formats it.

---

## RELATED PATTERNS

This pattern works alongside other core patterns:

**ID Antipattern (CLAUDE.md):** IDs are for uniqueness/debugging only. Never encode presentation or logic in IDs. See Backend/Frontend Separation for the correct approach - use domain enums instead.

**Generic Property Modification Antipattern (CLAUDE.md):** Never use generic `PropertyName` strings for updates. Map domain concepts to explicit properties. Frontend presentation is the frontend's responsibility, not a backend property.

**Icon System (CLAUDE.md):** Complements Backend/Frontend Separation by establishing HOW frontend should handle icons (SVG from game-icons.net via Icon component). This pattern establishes WHEN and WHERE icon selection happens (frontend only).

**HIGHLANDER (08_crosscutting_concepts.md):** One concept, one implementation. Don't have ActionType enum in backend and separate display string logic in frontend - instead have ActionType flow through both with clear responsibility boundaries.

---

## ENFORCEMENT

**In Code Review:**

```
REJECT PR if:
- [ ] ViewModel has CssClass, StyleClass, or IconClass properties
- [ ] ViewModel has IconName, IconId, or Icon properties (except as description of icon, e.g., for documentation)
- [ ] Backend service contains hardcoded display strings ("Friendly Chat", "Warning", etc.)
- [ ] Service switches on display type or icon name
- [ ] Message tokens contain presentation ({icon:coins}, {css:danger})
- [ ] CSS class names appear outside Razor components or CSS files

APPROVE PR if:
- [ ] Domain enums flow from backend to frontend unchanged
- [ ] ViewModels contain only domain values (int, string, bool, enums)
- [ ] All display text generated in frontend helpers or components
- [ ] All CSS classes applied in Razor components or CSS files
- [ ] All icons selected in frontend only
- [ ] System messages contain domain data only
```

**Verification Commands:**

```bash
# Find CSS class properties in ViewModels
grep -r "CssClass\|StyleClass" src/ViewModels --include="*.cs"

# Find icon properties in backend services
grep -r "Icon =" src/Services src/Subsystems --include="*.cs" \
  | grep -v "Icon component" | grep -v "Frontend"

# Find hardcoded display strings in backend
grep -r "Friendly Chat\|Medium load\|Too tired" src/Services src/Subsystems --include="*.cs" \
  | grep -v "Frontend" | grep -v "Razor"

# Find presentation tokens in messages
grep -r "{icon:" src/Subsystems --include="*.cs"
```

**Testing Checklist:**

- Backend unit tests never reference CSS, icons, or display text
- Backend tests verify domain logic and state changes
- Frontend tests (if present) verify presentation mapping only
- No tests check "CSS class is 'danger'" - test "weight > threshold" instead

---

## PATTERN STRENGTH

This pattern is **MANDATORY** in Wayfarer because:

1. **Game systems are complex enough** that mixing concerns creates overwhelming interdependencies
2. **Multiple UI outputs likely** (console, mobile, different themes) each need independent presentation
3. **Non-technical content creators** need to modify display text without understanding domain logic
4. **Artist/designer iteration cycles** must be independent of programmer cycles
5. **Testing becomes impossible** if presentation logic is scattered through domain services

Treating this as optional leads to "spaghetti code" where display logic progressively infects domain services until they become unmaintainable.

---
