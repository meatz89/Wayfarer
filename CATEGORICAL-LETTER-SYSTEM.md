# CATEGORICAL LETTER SYSTEM

**The definitive guide to how letters, NPCs, and token types interact in Wayfarer**

## Core Design Principle

Letters are generated through **categorical matching** between letter templates and NPCs. This creates a clean, maintainable system where:
- Letter templates define mechanical properties and token type
- NPCs define which token types they handle via `letterTokenTypes`
- The system matches them automatically

## How It Works

### 1. Letter Templates Define Token Type

Letter templates specify ONLY mechanical properties:
```json
{
    "id": "trade_agreement",
    "description": "Commercial correspondence about trade deals",
    "tokenType": "Trade",  // This is the key matching field
    "category": "Basic",
    "minTokensRequired": 3,
    "minDeadline": 2,
    "maxDeadline": 4,
    "minPayment": 4,
    "maxPayment": 6
}
```

**What templates DON'T have**:
- No specific sender names
- No specific recipient names
- No `possibleSenders` or `possibleRecipients` arrays
- Just pure mechanical definitions

### 2. NPCs Define Their Letter Types

Each NPC specifies which token types they handle:
```json
{
    "id": "elena_millbrook",
    "name": "Elena",
    "profession": "Merchant",
    "letterTokenTypes": ["Trust"]  // Elena only handles Trust letters
},
{
    "id": "marcus_thornwood", 
    "name": "Marcus",
    "profession": "Merchant",
    "letterTokenTypes": ["Trade"]  // Marcus only handles Trade letters
},
{
    "id": "river_worker",
    "name": "River Worker",
    "profession": "Laborer",
    "letterTokenTypes": ["Common", "Shadow"]  // Handles both types
}
```

### 3. System Matches Categorically

When generating a letter:
1. Template specifies `tokenType: "Trade"`
2. System finds all NPCs with `"Trade"` in their `letterTokenTypes`
3. Randomly selects sender and recipient from matching NPCs
4. Creates letter with real NPC names

Example flow:
```csharp
// Find NPCs that can handle this letter type
var relevantNpcs = _npcRepository.GetAllNPCs()
    .Where(npc => npc.LetterTokenTypes.Contains(tokenType))
    .ToList();

// Select sender and recipient
var sender = relevantNpcs[_random.Next(relevantNpcs.Count)];
var recipient = relevantNpcs.Where(n => n.ID != sender.ID)
    .ToList()[_random.Next(relevantNpcs.Count - 1)];

// Generate letter with actual NPC names
return GenerateLetterFromTemplate(template, sender.Name, recipient.Name);
```

## Special Cases

### Patron Letters

Patron letters are unique - they use narrative placeholders instead of real NPCs:

1. **Templates**: Define as `tokenType: "Noble"` with high payment
2. **PatronLetterService**: Generates narrative names like "Your Patron", "Field Agent"
3. **Not Real NPCs**: These names are narrative elements, not NPC IDs
4. **Mystery Preserved**: Player never knows who their patron really is

Example:
```csharp
// PatronLetterService generates these names directly
var patronSenders = new[] { "Your Patron", "Patron's Secretary", "House Steward" };
var patronRecipients = new[] { "Field Agent", "Local Contact", "Resource Master" };
```

### Shadow Network Letters

Similar to patron letters, shadow network uses thematic placeholders:
- Senders: "The Fence", "Shadow Broker", "Anonymous Source"
- Recipients: "Dead Drop", "Safe House", "Underground Contact"

These are generated by `StandingObligationManager` for shadow obligations.

## Implementation Details

### Key Classes

1. **LetterTemplate** - Defines mechanical properties
   - `TokenType` - The categorical matcher
   - Payment, deadline, size properties
   - NO sender/recipient fields

2. **NPC** - Defines letter handling capabilities
   - `LetterTokenTypes` array - Which types this NPC handles
   - Can have multiple types (e.g., Trade AND Shadow)

3. **LetterTemplateRepository** - Generates letters
   - `GenerateLetterFromTemplate()` - For regular letters with real NPCs
   - `GenerateForcedLetterFromTemplate()` - For narrative letters

### Validation

The `LetterTemplateFactory` skips NPC validation for narrative templates:
```csharp
// Special narrative templates that use placeholder names
var narrativeTemplates = new HashSet<string> 
{
    "forced_patron_resources", "forced_patron_instructions", 
    "forced_shadow_dead_drop", "forced_shadow_intelligence"
};

// Skip validation if it's a narrative template
bool isNarrativeTemplate = narrativeTemplates.Contains(id);
```

## Design Benefits

1. **Clean Separation**: Templates are data, NPCs are entities, matching is logic
2. **Easy Extension**: Add new NPCs with letterTokenTypes, they automatically participate
3. **Narrative Freedom**: Special services can generate thematic names without NPCs
4. **No Hardcoding**: System discovers relationships through data, not code
5. **Type Safety**: Token types are enums, preventing typos and errors

## Common Patterns

### Adding a New Letter Type
1. Create template with appropriate `tokenType`
2. Ensure NPCs exist with that type in `letterTokenTypes`
3. System automatically handles matching

### Creating Specialized NPCs
```json
{
    "id": "court_scribe",
    "letterTokenTypes": ["Noble", "Trust"]  // Handles court and personal letters
}
```

### Mixed-Type NPCs
River workers who do legitimate shipping AND smuggling:
```json
{
    "letterTokenTypes": ["Trade", "Shadow"]
}
```

## Warnings and Edge Cases

1. **Must Have Matching NPCs**: Each tokenType needs at least 2 NPCs
2. **Narrative Templates**: Don't need real NPCs, handled by services
3. **No Cross-Pollution**: Regular letters never use narrative names
4. **Token Type Required**: Every template MUST specify a tokenType

This categorical system creates emergent narrative opportunities while maintaining clean architecture and data-driven design.