# Handoff: Location Locking System & Hex Grid Integration for Dependent Locations

## Problem & Motivation

Scene-generated dependent locations need to start in a locked state and unlock through player choices within the scene. For example, when a player negotiates lodging with an innkeeper, the system procedurally generates a private room location adjacent to the inn. This room must be inaccessible until the player completes a choice that grants access (like paying for the room). The player then manually navigates to the unlocked room to continue the scene.

The pain point: Players need visual feedback showing which locations are accessible versus locked. Without this, players don't understand why clicking a location action does nothing, leading to confusion about game state and broken player mental models.

Business value: This enables dynamic world expansion through scenes while maintaining player agency through manual navigation. Players feel they're earning access to new areas rather than being teleport-chained through content.

Beyond the locking system, a critical architectural gap exists: when scenes generate dependent locations at runtime, these locations exist in the game world but not in the hex grid lookup system, causing null reference crashes when players attempt to navigate to them.

## Architectural Discovery: The Parser-JSON-Entity Triangle

The codebase follows a three-phase data transformation pipeline from JSON authoring through parse-time translation to runtime domain entities. This pattern appears consistently across the system:

**Phase 1: JSON Authoring** - Content creators write categorical descriptive properties. For example, location properties like "crossroads" or "commercial" describe the nature of a place without specifying exact mechanical values. Scene archetypes specify dependent locations as "locked initially" without implementing the locking mechanism.

**Phase 2: Parse-Time Translation** - Parser classes translate categorical strings into strongly-typed concrete domain properties. This is where "crossroads" becomes the LocationPropertyType enum value Crossroads, and where "Locked" as an initial state string should become IsLocked boolean true. The CATALOGUE PATTERN governs this translation: catalogues examine categorical properties and generate complete runtime entities with concrete typed values.

**Phase 3: Runtime Domain** - Domain entities use only concrete strongly-typed properties. No string matching, no dictionary lookups, no catalogue calls at runtime. Services and facades query concrete properties directly with type safety.

This triangle must be complete: JSON → Parser Translation → Runtime Entity. Any gap in this chain breaks the system.

## Domain Model Understanding: Location Locking as State Management

Locations are first-class domain entities with lifecycle state beyond just existence. The IsLocked property represents whether a location is accessible for player navigation. This is distinct from visibility (locked locations appear on the map) and routing (locked locations have movement actions generated for them).

The locking system involves several collaborating domain concepts:

**Location Entity** owns its locked state through the IsLocked boolean property. This follows the HIGHLANDER principle: one entity (Location) owns lock state, no duplicate tracking elsewhere. The entity initializes this as false by default, representing the open-world assumption that locations start accessible unless explicitly locked.

**Choice Rewards** modify location lock state through typed reward properties. A Choice can have LocationsToUnlock and LocationsToLock lists containing location IDs. When a choice executes, the RewardApplicationService iterates these lists and directly modifies the referenced Location entities' IsLocked properties.

**Movement Actions** are generated by catalogue for all adjacent hex locations regardless of lock state. The LocationActionManager queries Location.IsLocked at action availability check time and sets LocationAction.IsAvailable to false for locked destinations. This separates action existence from action executability.

**UI Rendering** applies CSS classes based on action availability. The Landing.razor component conditionally adds "locked" class to action cards where IsAvailable is false, and renders lock icons with reason text. The CSS defines visual treatment for this locked state.

The key insight: locking is a location property, not a movement property or UI property. The lock state lives on the Location entity and propagates outward to affect action availability and presentation.

## The Scene-Generated Dependent Location Architecture

Scenes can spawn dependent resources like locations and items that exist only within that scene's lifecycle. This enables dynamic world expansion where story content generates new physical spaces.

**Scene Archetypes** define patterns for dependent resource generation. The service_with_location_access archetype represents mercantile transactions that grant access to private spaces (buying lodging, renting workshops, etc). The archetype specifies that one dependent location should be generated, locked initially, and unlocked through a specific choice reward.

**SceneInstantiator** builds these specifications during scene finalization. When creating a dependent location, it finds an adjacent hex position using spatial reasoning (which neighbors of the base location are unoccupied), assigns Q/R coordinates to the location DTO, and sets InitialState to "Locked" based on the archetype's IsLockedInitially flag.

**Dynamic Package Loading** serializes dependent resources to JSON and loads them through the same PackageLoader pipeline used for static content. This maintains the Parser-JSON-Entity Triangle for dynamically-created content, ensuring consistent data transformation patterns.

The architectural elegance: dependent resources flow through the same parsing pipeline as authored content, maintaining consistency and leveraging existing validation and translation logic.

## Current State Analysis: The Two Missing Translations

Investigation revealed two broken links in the Parser-JSON-Entity Triangle for dependent locations:

**First Gap: InitialState String Not Translated to IsLocked Boolean**

LocationParser.ConvertDTOToLocation receives a LocationDTO with InitialState set to "Locked" from the scene instantiator. The parser stores this string on the Location entity but never translates it to the concrete IsLocked boolean property. The entity defaults IsLocked to false and this value never changes during parsing.

Result: All dependent locations appear unlocked regardless of their InitialState specification. The LocationActionManager checks IsLocked, finds false, marks actions as available, and the UI renders clickable unlocked actions. Players can click these actions but nothing happens because the location exists but isn't properly integrated.

**Second Gap: Hex Grid Not Updated for Runtime-Created Locations**

When dependent locations are created, they receive Q/R hex coordinates and get Location.HexPosition set correctly. Route generation creates RouteOptions connecting the new location to its neighbors. However, the WorldHexGrid.HexMap data structure is never updated with a Hex object at those coordinates.

The hex grid uses a two-level lookup: a Hexes list containing all hex objects, and a _hexLookup dictionary mapping coordinates to hexes. Both are populated during initial world load from static JSON but never updated when dependent locations spawn.

When a player attempts to move to a dependent location, the movement system calls GetPlayerCurrentLocation which queries WorldHexGrid.GetHex with the player's position. This lookup fails because no hex was added at those coordinates, returning null. The system then tries to access null.Venue causing a NullReferenceException crash.

Result: Dependent locations exist as Location entities with coordinates and routes, but they're invisible to the hex grid spatial indexing system, causing crashes when navigation actually occurs.

## Design Approach & Rationale

Two independent fixes are required, each addressing a different phase of the transformation pipeline:

**Approach for Location Locking Translation**

Add parse-time translation in LocationParser immediately after initializing the Location entity. Check if InitialState equals "Locked" and set IsLocked to true. This follows the CATALOGUE PATTERN: categorical string values from JSON/DTOs translate to concrete typed properties during parsing.

Why this approach: It maintains the Parser-JSON-Entity Triangle by completing the missing translation link. The parser already handles all other property translations (enum parsing, time windows, available work actions), so adding lock state translation is consistent with existing patterns.

Alternative rejected: Setting IsLocked directly in SceneInstantiator during DTO creation. This would bypass the parser and violate the separation between scene generation (creates specs) and parsing (translates specs to entities). The parser is the SINGLE translation point for all location properties.

**Approach for Hex Grid Integration**

When a location with coordinates loads through dynamic package loading, create a corresponding Hex object and add it to WorldHexGrid. This must happen after the location entity is created but before any navigation actions are generated or executed.

The hex creation must use the location's coordinates, assign the location ID to the hex's LocationId property, and rebuild the hex lookup dictionary to include the new coordinates. This maintains the invariant that every location with HexPosition has a corresponding hex in the grid at those exact coordinates.

Why this approach: It maintains architectural consistency where HexMap is the spatial index for all locations in the world. The lookup dictionary enables O(1) coordinate-to-hex queries that navigation depends on. Adding hexes for dependent locations ensures they integrate with the same spatial systems as authored locations.

Alternative rejected: Skipping hex grid entirely for dependent locations and using direct Location.HexPosition queries. This would require reimplementing all spatial reasoning, route validation, and adjacency logic outside the hex grid. It violates the HIGHLANDER principle by creating two parallel spatial systems and would break existing navigation code that assumes hex grid completeness.

## Implementation Strategy

**Location Locking Translation Strategy**

The parser receives a LocationDTO and builds a Location entity through property-by-property translation. After creating the entity object and setting basic properties like InitialState, add conditional logic to examine InitialState value and translate known states to typed properties. When InitialState is "Locked", set IsLocked to true.

This occurs in the same method that handles all other property translations, maintaining the pattern that one parser method completely transforms DTO to entity. The translation happens once at parse time, after which the InitialState string is never consulted again—all runtime code uses the concrete IsLocked boolean.

**Hex Grid Integration Strategy**

After PackageLoader loads location entities from a dynamic package, identify which locations have HexPosition values. For each such location, create a Hex object at those coordinates with the location's ID. Add this hex to the HexMap.Hexes collection and rebuild the coordinate lookup dictionary.

The hex creation must match the structure of hexes created during initial world load: same properties, same relationships, same ID assignment patterns. The lookup dictionary rebuild is crucial because the dictionary is the actual query interface used by navigation code.

Timing matters: hexes must be added after locations exist (so the location ID is valid) but before any route generation or navigation actions occur (so spatial queries work correctly). The dynamic package loading already has a sequence: load content, generate location actions, create routes. Hex creation belongs between loading content and generating actions.

## Critical Constraints

**Parser-JSON-Entity Triangle Completeness** - Every categorical property in JSON must translate to a concrete typed property on the domain entity during parsing. Runtime code never does string matching, dictionary lookups, or catalogue calls. This constraint ensures type safety, eliminates runtime parsing overhead, and makes the domain model self-contained.

**HIGHLANDER Principle for State** - Each piece of state has exactly one owner and one representation. Location lock state lives on Location.IsLocked, not duplicated in action lists, not tracked in a separate lock manager, not computed from other properties. Query the single source of truth.

**Parse-Time vs Runtime Resolution** - Entity references and property translations happen once during parsing, never during gameplay. A location ID becomes a Location object reference during parsing, never through repeated GameWorld lookups at runtime. The InitialState string becomes IsLocked boolean during parsing, never through conditional checks at runtime.

**Hex Grid as Spatial Index** - All locations with positions must have corresponding hexes in WorldHexGrid. The grid is not optional, not parallel to another system, not only for authored content. Any location a player can navigate to must have a hex in the grid at its coordinates.

**Dependent Resources Through Standard Pipeline** - Scene-generated content must flow through the same parsing and validation pipeline as authored content. No special cases, no bypass paths, no "just set the property directly" shortcuts. Dynamic content leverages existing translation and validation infrastructure.

**No Auto-Navigation** - When a location unlocks, the player does not automatically move there. The system unlocks access and the player must manually choose to navigate. This preserves player agency and the exploration mental model. UI shows unlocked state, player makes navigation decision.

## Key Files & Their Roles

**LocationParser.cs (Content Layer)** - Translates LocationDTO objects into Location domain entities. Handles property-by-property transformation from DTO structure to domain structure. Contains ConvertDTOToLocation which processes InitialState and should set IsLocked. This is where the categorical-to-concrete translation must occur for locking state.

**Location.cs (Domain Entity)** - Represents a physical place in the game world. Owns the IsLocked property as part of its state. Has HexPosition property storing Q/R coordinates. Location is the single source of truth for its locked state and spatial position.

**SceneInstantiator.cs (Content Layer)** - Generates dependent resource specifications during scene finalization. Builds LocationDTOs for scene-generated locations, including finding adjacent hex positions and setting InitialState based on archetype flags. Creates the specifications that feed into parsing.

**PackageLoader.cs (Content Layer)** - Orchestrates loading content packages into GameWorld. Handles both static packages from files and dynamic packages from scene-generated JSON. Calls various Load methods for different content types in sequence. Contains LoadDynamicPackageFromJson which must integrate hex grid updates.

**GameWorld.cs (Domain Root)** - Single source of truth for all game state. Contains WorldHexGrid for spatial indexing. Provides GetPlayerCurrentLocation which queries hex grid based on player coordinates. Owns the HexMap that must be updated when dependent locations spawn.

**HexMap.cs (Domain Model)** - Spatial index mapping coordinates to hexes. Contains Hexes list and _hexLookup dictionary. Provides GetHex method that navigation depends on for coordinate-to-hex queries. Must be updated with new hexes when dependent locations create new spatial positions.

**Hex.cs (Domain Entity)** - Represents one hex cell in the spatial grid. Has Q/R coordinates and LocationId reference. When a location exists at coordinates, a hex must exist there referencing that location. Hex and Location have bidirectional relationship through ID and coordinates.

**LocationActionManager.cs (Service Layer)** - Generates and validates location movement actions. Checks Location.IsLocked when determining action availability. Queries the concrete boolean property and sets LocationAction.IsAvailable accordingly. This is where lock state affects action executability.

**Landing.razor (UI Layer)** - Renders location actions as cards. Applies CSS classes based on action availability. Shows lock icons and lock reason text for unavailable actions. Pure presentation layer that displays lock state determined by backend.

**location.css (UI Layer)** - Defines visual styling for action cards in different states. Contains .action-card.locked styles for grayed appearance, dashed borders, and disabled cursor. Provides the visual feedback that communicates lock state to players.

**SceneArchetypeCatalog.cs (Content Generation)** - Defines patterns for scene generation including dependent resource specifications. The service_with_location_access archetype specifies IsLockedInitially flag on dependent locations. Catalogues drive procedural generation through categorical specifications.

**RewardApplicationService.cs (Service Layer)** - Executes choice rewards including location lock state changes. Iterates LocationsToUnlock and LocationsToLock lists and directly modifies Location.IsLocked properties. This is where player choices actually unlock locations through reward application.

**HexParser.cs (Content Layer)** - Parses hex grid from JSON during initial world load. Contains SyncLocationHexPositions which syncs location positions from existing hexes. Currently only handles static content from JSON, doesn't create hexes for dynamic locations.

## The Data Flow: Scene Generation to Hex Grid Integration

Understanding the complete flow from archetype to crash helps frame where fixes belong:

Scene archetype defines dependent location with IsLockedInitially flag. SceneInstantiator reads this during finalization and builds a DependentLocationSpec with coordinates found via spatial reasoning. The spec converts to LocationDTO with Q/R values and InitialState string. This DTO serializes to JSON forming a dynamic package.

GameFacade spawns the scene and loads the dynamic package through PackageLoader. The loader calls LoadLocations which invokes LocationParser for each LocationDTO. Parser creates Location entities and stores InitialState string but currently doesn't translate to IsLocked boolean—first gap. Parser sets Location.HexPosition from DTO coordinates.

After location loading completes, PackageLoader calls GenerateLocationActionsFromCatalogue. LocationActionCatalog generates intra-venue movement actions for adjacent hexes by querying route connections. Actions exist because routes were generated based on coordinates.

When LocationActionManager checks action availability, it queries Location.IsLocked expecting to find true for locked locations but finds false because translation never happened. Actions appear available when they shouldn't.

Meanwhile, no hex was added to WorldHexGrid for the new location. The HexMap.Hexes list and _hexLookup dictionary still only contain hexes from initial world load—second gap. The location exists with coordinates but the spatial index doesn't know about it.

When player clicks the action to move to the dependent location, MovementValidator checks lock state (finds false because of first gap, so validation passes), then updates player position to the new coordinates. Next frame, GetLocationContentViewModel tries to render the new location by calling GetCurrentLocation.

GetPlayerCurrentLocation queries WorldHexGrid.GetHex with player's new coordinates. The lookup dictionary doesn't contain these coordinates because no hex was added. GetHex returns null. Code tries to access null.Venue and throws NullReferenceException.

The system crashes not because locking failed but because the location isn't integrated into the spatial grid that navigation depends on.

## Integration Points: Where Systems Connect

The location locking fix integrates at the parser where DTOs become entities. This is the boundary between content specification and domain model. The InitialState string crosses from content authoring representation to domain runtime representation at this exact point.

The hex grid integration fix belongs after dynamic package loading but before action generation. This is the boundary where dependent resources join the world state. New entities must be fully integrated into world indexes before any systems query for them.

Both fixes respect the same architectural principle: transformations happen at layer boundaries, not scattered through runtime code. Parsers transform data format, loaders integrate into world state, then systems query stable integrated state. No transformation during gameplay, no integration during queries.

## Testing Validation

To validate the location locking fix: Generate a scene with dependent location, examine Location.IsLocked in debugger after parsing, should be true not false. Examine action availability, should be false. Examine rendered UI, should show locked styling with dashed border and lock icon.

After choosing the unlock reward, Location.IsLocked should flip to false, action availability should flip to true, UI should show standard clickable styling. Then player manually navigates and reaches the location.

To validate hex grid integration: After dependent location loads, query WorldHexGrid.GetHex with the location's coordinates. Should return a Hex object not null. Hex.LocationId should match the dependent location's ID. Player should be able to navigate to the location without NullReferenceException.

The system functions correctly when players can see locked locations, understand they're locked through visual feedback, unlock them through scene choices, navigate to them manually, and continue the scene there.

## Future Implications

This establishes pattern for runtime world modification. Any system that creates new locations dynamically must follow the same integration: create DTO, parse through standard pipeline, add to hex grid if positioned, generate actions. No special cases.

The lock/unlock pattern extends beyond locations. Items could be locked in inventory, NPCs could be locked from interaction, scenes could be locked from spawning. The same pattern applies: entity owns state, rewards modify state, availability checks query state, UI displays state. One representation, clear ownership, explicit modification.

The dependent resource pattern enables emergent gameplay. Scenes can spawn entire location networks, NPC populations, item sets. As long as each follows the Parser-JSON-Entity Triangle and integrates with world indexes, the content exists in the same systems as authored content.

## Known Issues After Fix

The locking translation fix is implemented and working. The hex grid integration gap is identified but not yet fixed. Any attempt to navigate to a dependent location will crash until hex grid integration is implemented.

Temporary workaround: Don't click movement actions for dependent locations until hex grid fix is in place. The action will be clickable (because locking works), but clicking will crash (because hex grid doesn't know about the location).

Priority: Hex grid integration is critical path for dependent locations to be playable. All other dependent resource features depend on locations being navigable without crashing.
