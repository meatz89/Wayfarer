@* LocationSpotMap.razor *@
<div class="locations-grid">
    @foreach (LocationSpot spot in GetKnownSpots())
    {
        <div class="@(!spot.IsClosed ? "enabled" : "disabled")">

            <div class="location-card @(spot.Id == CurrentSpot.Id ? "current" : "reachable")">
                <div class="location-spot-properties">
                    @foreach (var prop in GetSpotProperties(GetLocation(), spot))
                    {
                        <div class="property-tag @prop.CssClass">
                            <span class="property-icon">@prop.Icon</span>
                            <span class="property-text">@prop.Text</span>
                        </div>
                    }
                </div>
                <div class="location-name">
                    @spot.Name @(spot.IsClosed ? "(Closed)" : "")
                </div>
                <div class="location-type">@spot.Description</div>

                @* Add travel option if not current spot *@
                @if (spot.Id == CurrentSpot.Id)
                {
                    @foreach (UserActionOption action in GameState.ActionStateTracker.LocationSpotActions)
                    {
                        <button class="action-button"
                                @onclick="() => ShowApproachesForAction(action)"
                                disabled="@(action.IsDisabled)"
                                @onmouseover="(e) => HandleShowTooltip(action, e)"
                                @onmouseout="HandleHideTooltip">
                            <div class="card-cost-indicator"></div>
                            @action.ActionImplementation.Name (@action.ActionImplementation.ActionType)
                        </button>
                    }
                }
                else
                {
                    <button class="action-button" disabled="@(!GameManager.CanMoveToSpot(spot.Id))"
                            @onclick="() => OnSpotSelected.InvokeAsync(spot)">
                        MOVE HERE
                    </button>
                }

                @if (showingApproaches && selectedAction != null)
                {
                    <div class="approaches-container">
                        <div class="approaches-header">
                            <h3>@selectedAction.ActionImplementation.Name - Select Your Approach</h3>
                            <button class="close-button" @onclick="HideApproaches">×</button>
                        </div>

                        <div class="approaches-description">
                            @selectedAction.ActionImplementation.Description
                        </div>

                        <div class="approaches-list">
                            @foreach (var approach in GetApproachesForAction(selectedAction))
                            {
                                bool canUseApproach = CanUseApproach(approach);
                                <div class="approach-option @(canUseApproach ? "" : "disabled")">
                                    <div class="approach-header">
                                        <h4>@approach.Name</h4>
                                        <div class="card-requirement">
                                            <div class="card-preview @GetCardTypeClass(approach.RequiredCardType)"></div>
                                            <span>@approach.RequiredCardType Card</span>
                                        </div>
                                    </div>

                                    <p class="approach-description">@approach.Description</p>

                                    @if (!canUseApproach)
                                    {
                                        <div class="requirement-unmet">
                                            <span>@GetUnmetRequirementMessage(approach)</span>
                                        </div>
                                    }

                                    <button class="approach-button"
                                            disabled="@(!canUseApproach)"
                                            @onclick="() => SelectApproach(approach)">
                                        Select Approach
                                    </button>
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    }
</div>

@if (showTooltip && hoveredAction != null)
{
    <div class="tooltip" style="left: @(mouseX + 10)px; top: @(mouseY + 10)px">
        <ActionPreview CurrentAction="@hoveredAction"
        GameState="@GameState" />
    </div>
}

@code {
    [Inject] private GameManager GameManager { get; set; }
    [Inject] private GameState GameState { get; set; }
    [Inject] private LocationSystem LocationSystem { get; set; }

    [Parameter] public Location CurrentLocation { get; set; }
    [Parameter] public LocationSpot CurrentSpot { get; set; }
    [Parameter] public EventCallback<LocationSpot> OnSpotSelected { get; set; }
    [Parameter] public EventCallback<UserActionOption> OnActionSelected { get; set; }

    private bool showTooltip;
    private UserActionOption hoveredAction;
    private double mouseX;
    private double mouseY;

    private UserActionOption selectedAction = null;
    private bool showingApproaches = false;


    private string GetCardCostClass(CardTypes costType)
    {
        return costType switch
        {
            CardTypes.Physical => "physical-cost",
            CardTypes.Intellectual => "intellectual-cost",
            CardTypes.Social => "social-cost",
            _ => ""
        };
    }

    private List<ApproachOption> GetApproachesForAction(UserActionOption action)
    {
        return action.ActionImplementation.Approaches;
    }

    private bool CanUseApproach(ApproachOption approach)
    {
        // Check if player has the required card type and meets other requirements
        bool hasRequiredCard = PlayerHasAvailableCard(approach.RequiredCardType);

        // Additional requirements would be checked here
        return hasRequiredCard;
    }

    private string GetUnmetRequirementMessage(ApproachOption approach)
    {
        // Return appropriate message based on what requirement isn't met
        if (!PlayerHasAvailableCard(approach.RequiredCardType))
            return $"You need an available {approach.RequiredCardType} card";

        return "Requirements not met";
    }

    private bool PlayerHasAvailableCard(CardTypes cardType)
    {
        // Check if player has an available (non-exhausted) card of the required type
        return GameState.PlayerState.HasAvailableCard(cardType);
    }

    private void SelectApproach(ApproachOption approach)
    {
        // Update the selected action with the chosen approach
        UserActionOption actionWithApproach = selectedAction with { SelectedApproach = approach };

        // Execute the action with the selected approach
        OnActionSelected.InvokeAsync(actionWithApproach);

        // Reset the approach selection UI
        HideApproaches();
    }

    private string GetCardTypeClass(CardTypes type)
    {
        return type switch
        {
            CardTypes.Physical => "physical",
            CardTypes.Intellectual => "intellectual",
            CardTypes.Social => "social",
            _ => ""
        };
    }

    private void ShowApproachesForAction(UserActionOption action)
    {
        selectedAction = action;
        showingApproaches = true;
    }

    private void HideApproaches()
    {
        showingApproaches = false;
        selectedAction = null;
    }

    private void HandleShowTooltip(UserActionOption action, MouseEventArgs e)
    {
        hoveredAction = action;
        mouseX = e.ClientX;
        mouseY = e.ClientY;
        showTooltip = true;
    }

    private void HandleHideTooltip()
    {
        hoveredAction = null;
        showTooltip = false;
    }

    public List<LocationSpot> GetKnownSpots()
    {
        List<LocationSpot> locationSpots = LocationSystem.GetLocationSpots(CurrentLocation.Id);
        return locationSpots;
    }

    public Location GetLocation()
    {
        return LocationSystem.GetLocation(CurrentLocation.Id);
	}

    private List<PropertyDisplay> GetSpotProperties(Location location, LocationSpot spot)
    {
        List<PropertyDisplay> properties = new List<PropertyDisplay>();

        if (location.Population != null)
        {
            properties.Add(new(
            "📐",
            FormatEnumString(location.Population.ToString()),
            "",
            "",
            ""
            ));
        }

        if (location.Physical != null)
        {
            properties.Add(new(
            "🧩",
            FormatEnumString(location.Physical.ToString()),
            "",
            "",
            ""
            ));
        }

        if (location.Illumination != null)
        {
            properties.Add(new(
            "☀️",
            FormatEnumString(location.Illumination.ToString()),
            "",
            "",
            ""
            ));
        }

        return properties;
    }

    private string FormatEnumString(string value)
    {
        return string.Concat(value
            .Select((x, i) => i > 0 && char.IsUpper(x) ? " " + x : x.ToString()))
            .Replace("Type", "")
            .Replace("Types", "");
    }

}