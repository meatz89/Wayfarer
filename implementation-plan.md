# Wayfarer POC Implementation Plan

*Generated by Claude Code on 2025-07-08*

## Overview

This implementation plan provides specific code changes, file modifications, and complexity estimates for completing the Wayfarer economic simulation POC. Tasks are ordered by criticality, with foundational constraints implemented first.

**Total Estimated Effort:** 65-85 hours across 4 weeks
**Implementation Order:** Foundation Constraints ‚Üí Trading Systems ‚Üí Goal Structure ‚Üí Polish

---

## PHASE 1: FOUNDATION CONSTRAINTS (Week 1)
*Critical systems that enable "everything costs something else" gameplay*

### üî• CRITICAL: Task 1 - Time Block Constraint Enforcement
**Complexity:** Medium (6 hours)
**Priority:** MUST HAVE - Enables daily planning pressure

#### Files to Modify:
1. `src/GameState/TimeManager.cs` - Core constraint logic
2. `src/Game/ProgressionSystems/ActionProcessor.cs` - Action validation
3. `src/Pages/MainGameplayView.razor` - UI display
4. `src/UIHelpers/StyleHelper.cs` - UI styling for time blocks

#### Code Changes Required:

**File 1: `src/GameState/TimeManager.cs`**
```csharp
public class TimeManager
{
    // ADD: Constants and tracking
    public const int MAX_DAILY_TIME_BLOCKS = 5;
    private int usedTimeBlocks = 0;
    
    // ADD: New properties
    public int UsedTimeBlocks => usedTimeBlocks;
    public int RemainingTimeBlocks => MAX_DAILY_TIME_BLOCKS - usedTimeBlocks;
    public bool CanPerformTimeBlockAction => usedTimeBlocks < MAX_DAILY_TIME_BLOCKS;
    
    // MODIFY: Existing AdvanceTime method
    public void AdvanceTime(int duration)
    {
        if (usedTimeBlocks + duration > MAX_DAILY_TIME_BLOCKS)
        {
            throw new InvalidOperationException($"Cannot exceed daily limit of {MAX_DAILY_TIME_BLOCKS} time blocks");
        }
        
        usedTimeBlocks += duration;
        SetNewTime(CurrentTimeHours + duration);
    }
    
    // MODIFY: Existing StartNewDay method
    public void StartNewDay()
    {
        usedTimeBlocks = 0; // ADD: Reset time block counter
        worldState.CurrentDay++;
        SetNewTime(TimeDayStart);
    }
    
    // ADD: New validation method
    public bool ValidateTimeBlockAction(int requiredBlocks)
    {
        return usedTimeBlocks + requiredBlocks <= MAX_DAILY_TIME_BLOCKS;
    }
    
    // ADD: Force day end when blocks exhausted
    public void CheckDayCompletion()
    {
        if (usedTimeBlocks >= MAX_DAILY_TIME_BLOCKS)
        {
            // Trigger end of day sequence
            StartNewDay();
        }
    }
}
```

**File 2: `src/Game/ProgressionSystems/ActionProcessor.cs`**
```csharp
public class ActionProcessor
{
    // ADD: New validation method
    public bool CanProcessAction(LocationAction action)
    {
        // Check time block availability
        if (!gameWorld.TimeManager.CanPerformTimeBlockAction)
        {
            messageSystem.AddMessage("No time blocks remaining today", SystemMessageTypes.Warning);
            return false;
        }
        
        // Check stamina requirement
        if (player.Stamina < action.StaminaCost)
        {
            messageSystem.AddMessage("Not enough stamina", SystemMessageTypes.Warning);
            return false;
        }
        
        return true;
    }
    
    // MODIFY: Existing ProcessAction method
    public void ProcessAction(LocationAction action)
    {
        if (!CanProcessAction(action))
        {
            throw new InvalidOperationException("Action cannot be processed due to resource constraints");
        }
        
        Player player = gameWorld.GetPlayer();
        player.ApplyActionPointCost(action.ActionPointCost);
        
        // ADD: Time block consumption
        gameWorld.TimeManager.AdvanceTime(action.TimeBlockCost);
        
        // ADD: Check if day should end
        gameWorld.TimeManager.CheckDayCompletion();
    }
}
```

**File 3: `src/Pages/MainGameplayView.razor`**
```razor
<!-- ADD: Time block display section -->
<div class="time-blocks-display">
    <h4>Daily Time</h4>
    <div class="time-block-tracker">
        @for (int i = 0; i < TimeManager.MAX_DAILY_TIME_BLOCKS; i++)
        {
            <div class="time-block @(i < GameWorld.TimeManager.UsedTimeBlocks ? "used" : "available")">
                @(i + 1)
            </div>
        }
    </div>
    <p>@GameWorld.TimeManager.RemainingTimeBlocks blocks remaining</p>
</div>

<!-- MODIFY: Action buttons to check time availability -->
@foreach (var action in availableActions)
{
    <button class="action-btn" 
            disabled="@(!GameWorld.TimeManager.CanPerformTimeBlockAction || !CanAffordAction(action))"
            @onclick="() => ExecuteAction(action)">
        @action.Name
        <span class="action-cost">(@action.TimeBlockCost blocks, @action.StaminaCost stamina)</span>
    </button>
}
```

**Complexity Breakdown:**
- TimeManager modifications: 2 hours
- ActionProcessor integration: 1.5 hours  
- UI implementation: 2 hours
- Testing and debugging: 0.5 hours

---

### üîß CRITICAL: Task 2 - Inventory and Stamina Constraints
**Complexity:** Low (2 hours)
**Priority:** MUST HAVE - Creates strategic pressure

#### Files to Modify:
1. `src/GameState/Player.cs` - Adjust resource limits
2. `src/Game/MainSystem/Inventory.cs` - Update capacity validation

#### Code Changes Required:

**File 1: `src/GameState/Player.cs`**
```csharp
public class Player
{
    // CHANGE: Line 25 - Reduce max stamina from 12 to 6
    public int MaxStamina { get; set; } = 6;
    
    // CHANGE: Line 19 - Reduce starting stamina to match max
    public int Stamina { get; set; } = 6;
    
    // CHANGE: Line 166 - Reduce inventory size from 10 to 6
    public Player()
    {
        Background = GameRules.StandardRuleset.Background;
        Inventory = new Inventory(6); // Changed from 10
        
        Coins = 5;
        Level = 1;
        CurrentXP = 0;
        XPToNextLevel = 100;
        
        AvailableCards = new List<SkillCard>();
    }
    
    // ADD: Method to check if action is affordable
    public bool CanAffordAction(int staminaCost, int timeCost, int coinCost)
    {
        return Stamina >= staminaCost && 
               Coins >= coinCost;
               // Time cost checked in TimeManager
    }
}
```

**Complexity Breakdown:**
- Resource limit adjustments: 0.5 hours
- Testing constraint effects: 1 hour
- UI updates for new limits: 0.5 hours

---

## PHASE 2: TRADING SYSTEMS (Week 2)
*Enable profitable arbitrage and strategic route planning*

### üí∞ HIGH: Task 3 - Dynamic Location-Based Pricing
**Complexity:** High (12 hours)
**Priority:** HIGH - Core profit mechanism

#### Files to Modify:
1. `src/GameState/MarketManager.cs` - Pricing system overhaul
2. `src/Game/MainSystem/Item.cs` - Location-specific properties  
3. `src/Content/Templates/items.json` - Add location pricing data
4. `src/Pages/Market.razor` - Update trading UI

#### Code Changes Required:

**File 1: `src/GameState/MarketManager.cs`**
```csharp
public class MarketManager
{
    private GameWorld gameWorld;
    private LocationSystem LocationSystem;
    private Dictionary<string, Dictionary<string, LocationPricing>> locationPricing;
    
    public class LocationPricing
    {
        public int BuyPrice { get; set; }
        public int SellPrice { get; set; }
        public float SupplyLevel { get; set; } // 0.5 = scarce, 1.0 = normal, 2.0 = abundant
        public bool IsAvailable { get; set; }
    }
    
    public MarketManager(GameWorld gameWorld, LocationSystem locationSystem)
    {
        this.gameWorld = gameWorld;
        LocationSystem = locationSystem;
        InitializeLocationPricing();
    }
    
    // ADD: Initialize location-specific pricing
    private void InitializeLocationPricing()
    {
        locationPricing = new Dictionary<string, Dictionary<string, LocationPricing>>
        {
            ["town_square"] = new Dictionary<string, LocationPricing>
            {
                ["herbs"] = new LocationPricing { BuyPrice = 3, SellPrice = 2, SupplyLevel = 1.2f, IsAvailable = true },
                ["tools"] = new LocationPricing { BuyPrice = 8, SellPrice = 6, SupplyLevel = 0.8f, IsAvailable = true },
                ["rope"] = new LocationPricing { BuyPrice = 7, SellPrice = 4, SupplyLevel = 0.9f, IsAvailable = true },
                ["food"] = new LocationPricing { BuyPrice = 4, SellPrice = 2, SupplyLevel = 0.7f, IsAvailable = true }
            },
            ["dusty_flagon"] = new Dictionary<string, LocationPricing>
            {
                ["herbs"] = new LocationPricing { BuyPrice = 2, SellPrice = 1, SupplyLevel = 1.8f, IsAvailable = true },
                ["food"] = new LocationPricing { BuyPrice = 1, SellPrice = 1, SupplyLevel = 2.0f, IsAvailable = true },
                ["tools"] = new LocationPricing { BuyPrice = 12, SellPrice = 8, SupplyLevel = 0.3f, IsAvailable = true },
                ["rope"] = new LocationPricing { BuyPrice = 9, SellPrice = 5, SupplyLevel = 0.5f, IsAvailable = false }
            }
            // Add more locations as needed
        };
    }
    
    // ADD: Get location-specific item price
    public int GetItemPrice(string locationId, string itemId, bool isBuyPrice)
    {
        if (locationPricing.ContainsKey(locationId) && 
            locationPricing[locationId].ContainsKey(itemId))
        {
            LocationPricing pricing = locationPricing[locationId][itemId];
            if (!pricing.IsAvailable) return -1; // Item not available
            
            return isBuyPrice ? pricing.BuyPrice : pricing.SellPrice;
        }
        return -1; // Item not found
    }
    
    // ADD: Get all available items for location
    public List<Item> GetAvailableItems(string locationId)
    {
        List<Item> availableItems = new List<Item>();
        
        if (locationPricing.ContainsKey(locationId))
        {
            foreach (var itemPricing in locationPricing[locationId])
            {
                if (itemPricing.Value.IsAvailable)
                {
                    Item item = CreateItemWithLocationPricing(itemPricing.Key, locationId);
                    availableItems.Add(item);
                }
            }
        }
        
        return availableItems;
    }
    
    // ADD: Create item with location-specific pricing
    private Item CreateItemWithLocationPricing(string itemId, string locationId)
    {
        LocationPricing pricing = locationPricing[locationId][itemId];
        
        return new Item
        {
            Name = itemId,
            BuyPrice = pricing.BuyPrice,
            SellPrice = pricing.SellPrice,
            IsAvailable = pricing.IsAvailable
            // Copy other properties from base item definition
        };
    }
    
    // ADD: Calculate potential profits between locations
    public List<ArbitrageOpportunity> GetArbitrageOpportunities(string fromLocation, string toLocation)
    {
        List<ArbitrageOpportunity> opportunities = new List<ArbitrageOpportunity>();
        
        if (!locationPricing.ContainsKey(fromLocation) || !locationPricing.ContainsKey(toLocation))
            return opportunities;
            
        foreach (string itemId in locationPricing[fromLocation].Keys)
        {
            if (locationPricing[toLocation].ContainsKey(itemId))
            {
                int buyPrice = GetItemPrice(fromLocation, itemId, true);
                int sellPrice = GetItemPrice(toLocation, itemId, false);
                
                if (buyPrice > 0 && sellPrice > 0 && sellPrice > buyPrice)
                {
                    opportunities.Add(new ArbitrageOpportunity
                    {
                        ItemId = itemId,
                        BuyPrice = buyPrice,
                        SellPrice = sellPrice,
                        Profit = sellPrice - buyPrice,
                        ProfitMargin = ((float)(sellPrice - buyPrice) / buyPrice) * 100
                    });
                }
            }
        }
        
        return opportunities.OrderByDescending(o => o.Profit).ToList();
    }
    
    // MODIFY: Existing CanBuyItem method
    public bool CanBuyItem(string itemId, string locationId)
    {
        Player player = gameWorld.GetPlayer();
        int buyPrice = GetItemPrice(locationId, itemId, true);
        
        if (buyPrice <= 0) return false; // Item not available
        
        bool hasEnoughMoney = player.Coins >= buyPrice;
        bool hasInventorySpace = player.Inventory.HasFreeSlot();
        
        return hasEnoughMoney && hasInventorySpace;
    }
    
    // MODIFY: Existing BuyItem method  
    public bool BuyItem(string itemId, string locationId)
    {
        if (!CanBuyItem(itemId, locationId)) return false;
        
        Player player = gameWorld.GetPlayer();
        int buyPrice = GetItemPrice(locationId, itemId, true);
        
        player.Coins -= buyPrice;
        player.Inventory.AddItem(itemId);
        
        return true;
    }
    
    // ADD: Sell item at location
    public bool SellItem(string itemId, string locationId)
    {
        Player player = gameWorld.GetPlayer();
        
        if (!player.Inventory.HasItem(itemId)) return false;
        
        int sellPrice = GetItemPrice(locationId, itemId, false);
        if (sellPrice <= 0) return false; // Cannot sell here
        
        player.Inventory.RemoveItem(itemId);
        player.Coins += sellPrice;
        
        return true;
    }
}

// ADD: New class for arbitrage calculations
public class ArbitrageOpportunity
{
    public string ItemId { get; set; }
    public int BuyPrice { get; set; }
    public int SellPrice { get; set; }
    public int Profit { get; set; }
    public float ProfitMargin { get; set; }
}
```

**File 2: `src/Content/Templates/items.json`**
```json
[
  {
    "id": "herbs",
    "name": "Herbs",
    "weight": 1,
    "inventorySlots": 1,
    "enabledRouteTypes": [],
    "isContraband": false,
    "description": "Common herbs useful for cooking and basic remedies.",
    "locationPricing": {
      "town_square": { "buyPrice": 3, "sellPrice": 2, "supplyLevel": 1.2 },
      "dusty_flagon": { "buyPrice": 2, "sellPrice": 1, "supplyLevel": 1.8 }
    }
  },
  {
    "id": "tools", 
    "name": "Tools",
    "weight": 3,
    "inventorySlots": 1,
    "enabledRouteTypes": [],
    "isContraband": false,
    "description": "Basic tools for various trades and repairs.",
    "locationPricing": {
      "town_square": { "buyPrice": 8, "sellPrice": 6, "supplyLevel": 0.8 },
      "dusty_flagon": { "buyPrice": 12, "sellPrice": 8, "supplyLevel": 0.3 }
    }
  }
]
```

**Complexity Breakdown:**
- MarketManager pricing system: 6 hours
- JSON data structure updates: 2 hours
- Integration with existing systems: 2 hours
- Arbitrage calculation logic: 2 hours

---

### üöó HIGH: Task 4 - Route Selection Interface
**Complexity:** High (10 hours)
**Priority:** HIGH - Enables strategic travel decisions

#### Files to Create:
1. `src/Pages/RouteSelection.razor` - New route selection UI
2. `src/Pages/RouteSelection.razor.cs` - Code-behind logic

#### Files to Modify:
3. `src/Pages/MainGameplayView.razor` - Add route selection navigation
4. `src/wwwroot/css/routes.css` - Styling for route interface

#### Code Changes Required:

**File 1: `src/Pages/RouteSelection.razor`**
```razor
@page "/route-selection/{DestinationLocation}"
@inject GameWorldManager GameManager
@inject NavigationManager Navigation

<div class="route-selection-container">
    <div class="route-header">
        <h2>Travel to @DestinationLocation</h2>
        <button class="back-btn" @onclick="GoBack">‚Üê Back</button>
    </div>
    
    <div class="current-status">
        <div class="status-group">
            <h4>Current Resources</h4>
            <div class="resource-display">
                <span class="resource-item">
                    <i class="icon-coins"></i>
                    Coins: @player.Coins
                </span>
                <span class="resource-item">
                    <i class="icon-stamina"></i>
                    Stamina: @player.Stamina/@player.MaxStamina
                </span>
                <span class="resource-item">
                    <i class="icon-time"></i>
                    Time: @gameWorld.TimeManager.RemainingTimeBlocks/5 blocks
                </span>
                <span class="resource-item">
                    <i class="icon-weight"></i>
                    Weight: @currentWeight (@GetWeightDescription(currentWeight))
                </span>
            </div>
        </div>
    </div>
    
    <div class="route-options">
        <h3>Available Routes</h3>
        
        @if (availableRoutes.Any())
        {
            @foreach (var route in availableRoutes)
            {
                <div class="route-card @(CanAffordRoute(route) ? "affordable" : "unaffordable")">
                    <div class="route-header">
                        <h4>@route.Name</h4>
                        <span class="route-method">@route.Method</span>
                    </div>
                    
                    <div class="route-costs">
                        <div class="cost-grid">
                            <div class="cost-item">
                                <span class="cost-icon">‚è∞</span>
                                <span class="cost-label">Time:</span>
                                <span class="cost-value @(gameWorld.TimeManager.RemainingTimeBlocks >= route.TimeBlockCost ? "affordable" : "unaffordable")">
                                    @route.TimeBlockCost blocks
                                </span>
                            </div>
                            
                            <div class="cost-item">
                                <span class="cost-icon">üí∞</span>
                                <span class="cost-label">Coins:</span>
                                <span class="cost-value @(player.Coins >= route.BaseCoinCost ? "affordable" : "unaffordable")">
                                    @route.BaseCoinCost
                                </span>
                            </div>
                            
                            <div class="cost-item">
                                <span class="cost-icon">üí™</span>
                                <span class="cost-label">Stamina:</span>
                                <span class="cost-value @(player.Stamina >= CalculateStaminaCost(route) ? "affordable" : "unaffordable")">
                                    @CalculateStaminaCost(route)
                                    @if (currentWeight > 3)
                                    {
                                        <span class="weight-penalty">(@(CalculateStaminaCost(route) - route.BaseStaminaCost) weight penalty)</span>
                                    }
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="route-description">
                        <p>@route.Description</p>
                        
                        @if (route.DepartureTime != null)
                        {
                            <div class="departure-info">
                                <strong>Departure:</strong> @route.DepartureTime only
                            </div>
                        }
                        
                        @if (route.RequiredRouteTypes.Any())
                        {
                            <div class="requirements">
                                <strong>Requires:</strong> @string.Join(", ", route.RequiredRouteTypes)
                            </div>
                        }
                    </div>
                    
                    <div class="route-actions">
                        @if (CanAffordRoute(route))
                        {
                            <button class="select-route-btn primary" @onclick="() => SelectRoute(route)">
                                Select This Route
                            </button>
                        }
                        else
                        {
                            <button class="select-route-btn disabled" disabled>
                                Cannot Afford
                                @if (!HasRequiredItems(route))
                                {
                                    <span class="reason">(Missing required items)</span>
                                }
                                else if (gameWorld.TimeManager.RemainingTimeBlocks < route.TimeBlockCost)
                                {
                                    <span class="reason">(Not enough time)</span>
                                }
                                else if (player.Coins < route.BaseCoinCost)
                                {
                                    <span class="reason">(Not enough coins)</span>
                                }
                                else if (player.Stamina < CalculateStaminaCost(route))
                                {
                                    <span class="reason">(Not enough stamina)</span>
                                }
                            </button>
                        }
                    </div>
                </div>
            }
        }
        else
        {
            <div class="no-routes">
                <p>No routes available to @DestinationLocation at this time.</p>
                <p>You may need to discover new travel methods or wait for better conditions.</p>
            </div>
        }
    </div>
    
    @if (availableRoutes.Any())
    {
        <div class="route-comparison">
            <h4>Quick Comparison</h4>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Route</th>
                        <th>Time</th>
                        <th>Coins</th>
                        <th>Stamina</th>
                        <th>Total Cost*</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var route in availableRoutes)
                    {
                        <tr class="@(CanAffordRoute(route) ? "affordable" : "unaffordable")">
                            <td>@route.Name</td>
                            <td>@route.TimeBlockCost</td>
                            <td>@route.BaseCoinCost</td>
                            <td>@CalculateStaminaCost(route)</td>
                            <td>@CalculateRouteCostScore(route)</td>
                        </tr>
                    }
                </tbody>
            </table>
            <p class="cost-note">*Cost score: weighted combination of all resources</p>
        </div>
    }
</div>
```

**File 2: `src/Pages/RouteSelection.razor.cs`**
```csharp
public partial class RouteSelection
{
    [Parameter] public string DestinationLocation { get; set; }
    
    private Player player;
    private GameWorld gameWorld;
    private List<RouteOption> availableRoutes;
    private int currentWeight;
    
    protected override void OnInitialized()
    {
        gameWorld = GameManager.GetGameWorld();
        player = gameWorld.GetPlayer();
        LoadAvailableRoutes();
        currentWeight = CalculateCurrentWeight();
    }
    
    private void LoadAvailableRoutes()
    {
        string currentLocationId = player.CurrentLocation?.Id ?? "";
        availableRoutes = GameManager.TravelManager
            .GetAvailableRoutes(currentLocationId, DestinationLocation);
    }
    
    private int CalculateCurrentWeight()
    {
        return GameManager.TravelManager.CalculateCurrentWeight(gameWorld);
    }
    
    private string GetWeightDescription(int weight)
    {
        return GameManager.TravelManager.GetWeightStatusDescription(weight);
    }
    
    private int CalculateStaminaCost(RouteOption route)
    {
        return GameManager.TravelManager.CalculateStaminaCost(route);
    }
    
    private bool CanAffordRoute(RouteOption route)
    {
        // Check all resource requirements
        bool hasTimeBlocks = gameWorld.TimeManager.RemainingTimeBlocks >= route.TimeBlockCost;
        bool hasCoins = player.Coins >= route.BaseCoinCost;
        bool hasStamina = player.Stamina >= CalculateStaminaCost(route);
        bool hasRequiredItems = HasRequiredItems(route);
        bool meetsTimeRestrictions = MeetsTimeRestrictions(route);
        
        return hasTimeBlocks && hasCoins && hasStamina && hasRequiredItems && meetsTimeRestrictions;
    }
    
    private bool HasRequiredItems(RouteOption route)
    {
        foreach (string requiredType in route.RequiredRouteTypes)
        {
            bool hasEnablingItem = false;
            foreach (string itemName in player.Inventory.ItemSlots)
            {
                if (!string.IsNullOrEmpty(itemName))
                {
                    // Check if item enables this route type
                    // This would need to be implemented based on item system
                    if (ItemEnablesRouteType(itemName, requiredType))
                    {
                        hasEnablingItem = true;
                        break;
                    }
                }
            }
            if (!hasEnablingItem) return false;
        }
        return true;
    }
    
    private bool MeetsTimeRestrictions(RouteOption route)
    {
        if (route.DepartureTime == null) return true;
        
        return gameWorld.CurrentTimeBlock <= route.DepartureTime;
    }
    
    private bool ItemEnablesRouteType(string itemName, string routeType)
    {
        // Implementation depends on item system
        // For now, return true - this should check item.EnabledRouteTypes
        return true;
    }
    
    private int CalculateRouteCostScore(RouteOption route)
    {
        // Weighted cost calculation for comparison
        // Weight time blocks more heavily as they're limited
        int timeWeight = route.TimeBlockCost * 10;
        int coinWeight = route.BaseCoinCost * 2;
        int staminaWeight = CalculateStaminaCost(route) * 3;
        
        return timeWeight + coinWeight + staminaWeight;
    }
    
    private void SelectRoute(RouteOption route)
    {
        try
        {
            // Execute the travel
            string destinationSpot = route.DestinationLocationSpot ?? "";
            GameManager.TravelManager.TravelToLocation(
                DestinationLocation, 
                destinationSpot, 
                route);
            
            // Navigate to destination
            Navigation.NavigateTo($"/location/{DestinationLocation}");
        }
        catch (Exception ex)
        {
            // Handle travel errors (insufficient resources, etc.)
            // Add error display to UI
            Console.WriteLine($"Travel failed: {ex.Message}");
        }
    }
    
    private void GoBack()
    {
        Navigation.NavigateTo("/gameplay");
    }
}
```

**Complexity Breakdown:**
- Route selection UI: 4 hours
- Code-behind logic: 3 hours
- CSS styling: 1.5 hours
- Integration testing: 1.5 hours

---

## PHASE 3: GOAL STRUCTURE (Week 3)
*Add time pressure and structured objectives*

### üìã MEDIUM: Task 5 - Complete Contract System
**Complexity:** High (14 hours)
**Priority:** MEDIUM - Adds goal-oriented gameplay

#### Files to Modify:
1. `src/Game/MainSystem/ContractSystem.cs` - Complete deadline logic
2. `src/GameState/Contract.cs` - Add completion tracking
3. `src/Pages/ContractUI.razor` - Update contract interface
4. `src/GameState/GameWorldManager.cs` - Daily contract processing

#### Code Changes Required:

**File 1: `src/Game/MainSystem/ContractSystem.cs`**
```csharp
public class ContractSystem
{
    private GameWorld gameWorld;
    private LocationSystem locationSystem;
    private List<Contract> availableContracts;
    private List<Contract> activeContracts;
    private List<Contract> completedContracts;
    private List<Contract> failedContracts;
    
    public ContractSystem(GameWorld gameWorld, LocationSystem locationSystem)
    {
        this.gameWorld = gameWorld;
        this.locationSystem = locationSystem;
        this.availableContracts = new List<Contract>();
        this.activeContracts = new List<Contract>();
        this.completedContracts = new List<Contract>();
        this.failedContracts = new List<Contract>();
    }
    
    // ADD: Contract availability and selection
    public List<Contract> GetAvailableContracts(string locationId)
    {
        return availableContracts
            .Where(c => c.StartLocation == locationId && 
                       !activeContracts.Contains(c) && 
                       !completedContracts.Contains(c) &&
                       gameWorld.CurrentDay >= c.StartDay)
            .ToList();
    }
    
    public bool CanAcceptContract(Contract contract)
    {
        // Check if player can accept more contracts (limit to 2)
        if (activeContracts.Count >= 2) return false;
        
        // Check if contract is still available
        if (gameWorld.CurrentDay > contract.StartDay + 1) return false;
        
        return true;
    }
    
    public bool AcceptContract(Contract contract)
    {
        if (!CanAcceptContract(contract)) return false;
        
        activeContracts.Add(contract);
        availableContracts.Remove(contract);
        
        // Add to player's active goals
        gameWorld.GetPlayer().AddGoal(new Goal
        {
            Type = GoalType.Delivery,
            Description = contract.Description,
            TargetLocation = contract.DestinationLocation,
            Deadline = contract.DueDay,
            IsCompleted = false
        });
        
        return true;
    }
    
    // ADD: Contract completion logic
    public bool CanCompleteContract(Contract contract)
    {
        Player player = gameWorld.GetPlayer();
        
        // Check if at correct location
        if (player.CurrentLocation?.Id != contract.DestinationLocation)
            return false;
        
        // Check if has required items
        foreach (string requiredItem in contract.RequiredItems)
        {
            if (!player.Inventory.HasItem(requiredItem))
                return false;
        }
        
        // Check if has visited required locations
        foreach (string requiredLocation in contract.RequiredLocations)
        {
            if (!player.HasVisitedLocation(requiredLocation))
                return false;
        }
        
        return true;
    }
    
    public ContractResult AttemptCompleteContract(Contract contract)
    {
        if (!activeContracts.Contains(contract))
        {
            return new ContractResult
            {
                Success = false,
                Message = "Contract is not active"
            };
        }
        
        if (IsContractExpired(contract))
        {
            return new ContractResult
            {
                Success = false,
                Message = "Contract has expired",
                ReputationPenalty = -5,
                IsExpired = true
            };
        }
        
        if (!CanCompleteContract(contract))
        {
            return new ContractResult
            {
                Success = false,
                Message = "Contract requirements not met"
            };
        }
        
        // Complete the contract
        Player player = gameWorld.GetPlayer();
        
        // Remove required items
        foreach (string item in contract.RequiredItems)
        {
            player.Inventory.RemoveItem(item);
        }
        
        // Calculate payment (reduced if late)
        int payment = CalculateContractPayment(contract);
        player.AddCoins(payment);
        
        // Add reputation bonus
        player.Reputation += 2;
        
        // Move contract to completed
        activeContracts.Remove(contract);
        contract.IsCompleted = true;
        completedContracts.Add(contract);
        
        // Unlock follow-up contracts
        UnlockFollowUpContracts(contract);
        
        return new ContractResult
        {
            Success = true,
            Message = $"Contract completed successfully! Earned {payment} coins.",
            CoinsEarned = payment,
            ReputationGain = 2
        };
    }
    
    // ADD: Contract expiration checking
    public bool IsContractExpired(Contract contract)
    {
        return gameWorld.CurrentDay > contract.DueDay;
    }
    
    private int CalculateContractPayment(Contract contract)
    {
        int basePayment = contract.Payment;
        int daysRemaining = contract.DueDay - gameWorld.CurrentDay;
        
        // Reduce payment if delivered late (but before expiration)
        if (daysRemaining < 0)
        {
            // Late delivery penalty
            int daysLate = Math.Abs(daysRemaining);
            float penalty = Math.Min(0.5f, daysLate * 0.1f); // Max 50% penalty
            basePayment = (int)(basePayment * (1.0f - penalty));
        }
        else if (daysRemaining > 1)
        {
            // Early delivery bonus
            float bonus = Math.Min(0.2f, daysRemaining * 0.05f); // Max 20% bonus
            basePayment = (int)(basePayment * (1.0f + bonus));
        }
        
        return Math.Max(1, basePayment); // Minimum 1 coin
    }
    
    // ADD: Daily contract processing
    public void ProcessDailyContractUpdates()
    {
        List<Contract> expiredContracts = new List<Contract>();
        
        foreach (Contract contract in activeContracts)
        {
            if (IsContractExpired(contract))
            {
                expiredContracts.Add(contract);
            }
        }
        
        // Handle expired contracts
        foreach (Contract expired in expiredContracts)
        {
            FailContract(expired);
        }
        
        // Generate new contracts periodically
        if (gameWorld.CurrentDay % 2 == 0) // Every other day
        {
            GenerateNewContracts();
        }
    }
    
    private void FailContract(Contract contract)
    {
        Player player = gameWorld.GetPlayer();
        
        // Apply reputation penalty
        player.Reputation -= 5;
        
        // Apply any specific failure penalties
        if (!string.IsNullOrEmpty(contract.FailurePenalty))
        {
            // Apply specific penalty (could be more coins, items, etc.)
            ApplyFailurePenalty(contract.FailurePenalty);
        }
        
        // Move to failed contracts
        activeContracts.Remove(contract);
        contract.IsFailed = true;
        failedContracts.Add(contract);
        
        // Lock certain contracts if specified
        foreach (string lockedId in contract.LocksContractIds)
        {
            LockContract(lockedId);
        }
    }
    
    private void UnlockFollowUpContracts(Contract completedContract)
    {
        foreach (string unlockedId in completedContract.UnlocksContractIds)
        {
            UnlockContract(unlockedId);
        }
    }
    
    private void GenerateNewContracts()
    {
        // Add logic to generate new contracts based on current game state
        // This could be random selection from a pool, or procedurally generated
    }
    
    // ADD: Contract status methods
    public List<Contract> GetActiveContracts()
    {
        return new List<Contract>(activeContracts);
    }
    
    public List<Contract> GetCompletedContracts()
    {
        return new List<Contract>(completedContracts);
    }
    
    public List<Contract> GetFailedContracts()
    {
        return new List<Contract>(failedContracts);
    }
    
    public int GetContractDeadlinePressure(Contract contract)
    {
        int daysRemaining = contract.DueDay - gameWorld.CurrentDay;
        
        if (daysRemaining < 0) return 3; // Expired
        if (daysRemaining == 0) return 2; // Due today
        if (daysRemaining == 1) return 1; // Due tomorrow
        return 0; // No immediate pressure
    }
    
    // MODIFY: Existing FormatActiveContracts method
    public string FormatActiveContracts(List<Contract> contracts)
    {
        StringBuilder sb = new StringBuilder();
        
        if (contracts == null || !contracts.Any())
            return "None";
        
        foreach (Contract contract in contracts)
        {
            int daysRemaining = contract.DueDay - gameWorld.CurrentDay;
            string urgency = daysRemaining <= 1 ? " (URGENT!)" : "";
            
            sb.AppendLine($"- {contract.Id}: {contract.Description}");
            sb.AppendLine($"  Destination: {contract.DestinationLocation}");
            sb.AppendLine($"  Due: Day {contract.DueDay} ({daysRemaining} days remaining){urgency}");
            sb.AppendLine($"  Payment: {contract.Payment} coins");
            sb.AppendLine();
        }
        
        return sb.ToString();
    }
}

// ADD: Contract result class
public class ContractResult
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public int CoinsEarned { get; set; }
    public int ReputationGain { get; set; }
    public int ReputationPenalty { get; set; }
    public bool IsExpired { get; set; }
}

// ADD: Goal type enum (if not exists)
public enum GoalType
{
    Delivery,
    Trading,
    Exploration,
    Reputation
}
```

**Complexity Breakdown:**
- Contract completion logic: 6 hours
- Deadline processing system: 3 hours
- Contract generation system: 2 hours
- UI integration: 2 hours
- Testing and balancing: 1 hour

---

## PHASE 4: POLISH AND OPTIMIZATION (Week 4)
*Refine systems and improve code quality*

### üé® LOW: Task 6 - Style and Code Quality
**Complexity:** Medium (8 hours)
**Priority:** LOW - Code quality improvement

#### Files to Modify:
*Multiple files identified in analysis - 47 files total*

#### Code Changes Required:

**Pattern 1: Replace var Usage (8 files)**
```csharp
// BEFORE (in multiple files):
var item = GetItem();
var player = gameWorld.GetPlayer();
var routes = GetAvailableRoutes();

// AFTER:
Item item = GetItem();
Player player = gameWorld.GetPlayer();
List<RouteOption> routes = GetAvailableRoutes();
```

**Files to update:**
- `src/GameState/GameWorldManager.cs`
- `src/GameState/GameWorld.cs`
- `src/Game/EvolutionSystem/WorldStateInputBuilder.cs`
- `src/Game/EncounterSystem/ChoiceProjectionService.cs`
- `src/Game/AiNarrativeSystem/Providers/OllamaProvider.cs`
- `src/Game/AiNarrativeSystem/EncounterChoiceResponseParser.cs`
- `src/Game/AiNarrativeSystem/AIPromptBuilder.cs`
- `src/Game/AiNarrativeSystem/AIGameMaster.cs`

**Pattern 2: Reduce Lambda Expression Usage (Selected Files)**
```csharp
// BEFORE:
var availableItems = items.Where(i => i.IsAvailable && i.Price <= budget).ToList();
var sortedRoutes = routes.OrderBy(r => r.TotalCost).ThenBy(r => r.TimeBlocks).ToList();

// AFTER:
var availableItems = items.Where(IsAffordableAndAvailable).ToList();
var sortedRoutes = routes.OrderBy(GetRouteTotalCost).ThenBy(GetRouteTimeBlocks).ToList();

private bool IsAffordableAndAvailable(Item item)
{
    return item.IsAvailable && item.Price <= budget;
}

private int GetRouteTotalCost(RouteOption route)
{
    return route.TotalCost;
}

private int GetRouteTimeBlocks(RouteOption route)
{
    return route.TimeBlocks;
}
```

**Complexity Breakdown:**
- var replacement: 3 hours
- Lambda reduction: 4 hours  
- Code review and testing: 1 hour

---

### üß™ CRITICAL: Task 7 - Integration Testing and Balance
**Complexity:** Medium (6 hours)  
**Priority:** CRITICAL - Ensure systems work together

#### Testing Areas:

**Test 1: Daily Resource Constraint Loop**
```csharp
// Test scenario: Complete day using all 5 time blocks
// Verify: Cannot perform 6th action
// Verify: Resources reset properly next day
// Verify: Strategic pressure creates meaningful choices

[Test]
public void TestDailyTimeBlockConstraint()
{
    // Setup player with full resources
    // Perform 5 actions consuming 1 time block each
    // Attempt 6th action - should fail
    // Advance to next day
    // Verify time blocks reset to 5
}
```

**Test 2: Economic Arbitrage Opportunities**
```csharp
// Test scenario: Buy low at one location, sell high at another
// Verify: Profit calculations correct
// Verify: Travel costs factored into profitability
// Verify: Inventory limitations create strategic decisions

[Test]
public void TestTradingProfitability()
{
    // Buy item at location A for low price
    // Travel to location B (with travel costs)
    // Sell item for higher price
    // Verify net profit calculation
    // Test with inventory limitations
}
```

**Test 3: Contract Time Pressure**
```csharp
// Test scenario: Accept contract with tight deadline
// Verify: Time pressure affects decision making
// Verify: Late delivery penalties applied
// Verify: Contract failure consequences

[Test]
public void TestContractDeadlinePressure()
{
    // Accept contract due in 2 days
    // Use 1 day for other activities
    // Complete contract on final day
    // Verify payment and reputation effects
}
```

**Complexity Breakdown:**
- Test scenario creation: 2 hours
- Balance testing and adjustment: 3 hours
- Documentation updates: 1 hour

---

## IMPLEMENTATION ORDER SUMMARY

### Week 1: Foundation (18 hours)
1. **Time Block Constraints** (6 hours) - CRITICAL
2. **Resource Limit Adjustments** (2 hours) - CRITICAL  
3. **Basic Integration Testing** (2 hours) - HIGH
4. **UI Updates for Constraints** (3 hours) - HIGH
5. **Documentation Updates** (1 hour) - MEDIUM

### Week 2: Trading Systems (22 hours)
1. **Dynamic Pricing System** (12 hours) - HIGH
2. **Route Selection Interface** (10 hours) - HIGH

### Week 3: Goal Structure (20 hours)
1. **Complete Contract System** (14 hours) - MEDIUM
2. **Contract UI Integration** (4 hours) - MEDIUM
3. **Balance Testing** (2 hours) - HIGH

### Week 4: Polish (14 hours)
1. **Code Style Cleanup** (8 hours) - LOW
2. **Integration Testing** (6 hours) - CRITICAL

**Total Estimated Hours:** 74 hours across 4 weeks (~18.5 hours per week)

---

## RISK MITIGATION

### High Risk Items:
1. **Dynamic Pricing Complexity** - Start with simple pricing, iterate
2. **Route UI Complexity** - Focus on functionality over visual polish initially  
3. **Contract Balance** - Test thoroughly with multiple scenarios
4. **Integration Bugs** - Implement comprehensive testing at each phase

### Success Criteria Validation:
- [ ] Players face meaningful "everything costs something else" decisions
- [ ] Time pressure creates urgency in decision making  
- [ ] Multiple viable strategies emerge from testing
- [ ] Resource constraints feel fair but challenging
- [ ] UI provides clear information for strategic decisions

This implementation plan provides the specific code changes, file modifications, and complexity estimates needed to complete the Wayfarer economic simulation POC according to the user stories and design vision.