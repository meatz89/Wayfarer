# Code Review Checklist: Backend/Frontend Separation

Use this checklist when reviewing pull requests to ensure the Backend/Frontend Separation principle is maintained. This principle is **MANDATORY** and violations must be fixed before merging.

---

## Quick Summary

**REJECT PR if backend is making any presentation decisions:**
- Selecting CSS classes
- Choosing icon names
- Generating display text
- Creating message tokens with presentation metadata
- Routing based on display type
- Applying styling logic

**APPROVE PR if presentation logic is entirely in frontend:**
- Domain enums flow from backend to frontend
- Frontend maps enums to visual representations
- Display text generated in Razor helpers
- CSS applied in Razor components
- Icons selected in frontend only

---

## Pre-Review: File Scope Analysis

Before diving into code, identify which files need review:

**ALWAYS REVIEW if changed:**
- `src/ViewModels/**/*.cs` - Check for presentation properties
- `src/Services/**/*.cs` - Check for presentation logic
- `src/Subsystems/**/*.cs` - Check for display decisions
- `src/Pages/Components/**/*.razor` - Verify presentation logic is here, not backend

**SELECTIVELY REVIEW if changed:**
- `src/GameState/**/*.cs` - Only if ViewModels modified
- `src/Content/**/*.cs` - Only if returning presentation data
- Razor components - Look for domain logic (should be none)

**SKIP REVIEW of:**
- Pure domain entity changes (Player, Location, etc.)
- Repository/Data access changes (unless ViewModel impacts)
- Configuration/DI changes

---

## Detailed Checklist: ViewModels

### ViewModel Properties

For each public property in a ViewModel, ask:

- **Is this a CSS class name?** → REJECT
  - FORBIDDEN: Properties like FocusClass, StatusCss with values like empty string, "warning", or "danger"
  - These represent styling decisions that belong in the frontend

- **Is this an icon name?** → REJECT
  - FORBIDDEN: Properties like Icon or IconName containing values like "coins" or "health-normal"
  - Icon selection is a presentation decision

- **Is this display text generated by backend?** → REJECT
  - FORBIDDEN: Properties like Description or ActionLabel set to generated user-friendly text
  - Backend should not generate display strings like "You're too tired" or "Friendly Chat"

- **Is this a code-generated formatted string?** → REJECT
  - FORBIDDEN: Properties like DisplayString or FormattedMessage with formatted output
  - Backend should not create strings like "Health: 50 | Stamina: 30"

- **Is this a domain enum?** → APPROVE
  - CORRECT: Properties holding enums like ConnectionState, ActionRestrictionReason
  - Domain enums represent game state, not presentation decisions

- **Is this a plain domain value?** → APPROVE
  - CORRECT: Properties like TotalWeight (int), IsAvailable (bool), NPCName (string)
  - Plain values representing actual game state are acceptable

### ViewModel Creation

Check where ViewModels are instantiated:

**FORBIDDEN Pattern: Backend Setting CSS Classes**
- ViewModels instantiated with CSS class properties set via conditional logic based on domain values
- Example: Setting FocusClass to "danger", "warning", or empty string based on weight thresholds
- FIX: Return domain values only; let frontend apply CSS based on those values

**FORBIDDEN Pattern: Backend Choosing Icons**
- ViewModels instantiated with Icon property set via switch expressions on action types
- Example: Mapping action types to icon names like "sword", "shaking-hands", "sparkles"
- FIX: Return domain enum; let frontend map enum to icon names

**FORBIDDEN Pattern: Backend Generating Display Text**
- ViewModels instantiated with DisplayText property set via switch expressions on conversation types
- Example: Mapping conversation type strings to friendly labels like "Friendly Chat", "Request Information"
- FIX: Return domain enum or type identifier; let frontend generate display text

**CORRECT Pattern: Domain Enum Only**
- ViewModels instantiated with only domain properties: enums, object references, boolean availability flags
- No display text, CSS classes, or icon names
- Frontend receives raw domain data and makes all presentation decisions

---

## Detailed Checklist: Service/Facade Code

### Display Logic in Services

Scan service methods for presentation decisions:

**FORBIDDEN Pattern: Switching on Display Type**
- Service code using switch expressions to map resource types to icon names
- Backend choosing which icon represents which resource type
- FIX: Return resource type enum; let frontend choose icons

**FORBIDDEN Pattern: Generating Display Strings**
- Service code generating user-friendly status strings like "Overloaded", "Heavy", "Light"
- Backend deciding what text to show based on calculations
- FIX: Return raw calculation values; let frontend generate display text

**FORBIDDEN Pattern: Conditional CSS Logic**
- Service code determining CSS class names based on stamina thresholds
- Backend applying styling logic like "danger", "warning" based on values
- FIX: Return actual values (current stamina, thresholds); let frontend apply CSS

**CORRECT Pattern: Domain Logic Only**
- Service methods returning ViewModels with only calculated domain values
- Properties like TotalWeight, MaxCapacity, CurrentStamina without any display metadata
- Frontend calculates ratios and applies presentation independently

### Message System Usage

Check how messages are created:

**FORBIDDEN Pattern: Icons in Messages**
- Message strings containing presentation tokens like "{icon:coins}"
- Backend embedding icon selection within message text
- FIX: Remove icon tokens; frontend renders icons separately from message text

**FORBIDDEN Pattern: Formatted Display Strings**
- Messages using string interpolation to create formatted display output
- Backend formatting like "Health: X | Stamina: Y" for visual presentation
- FIX: Create separate message entries or return structured data

**FORBIDDEN Pattern: Generated Friendly Text**
- Messages containing generated user-friendly descriptions
- Backend creating display text like "You've made good progress on this route!"
- FIX: Use simple factual statements about game events

**CORRECT Pattern: Domain Data Only**
- Messages containing game event descriptions with actual domain values
- Simple statements like "Travel to {destination} costs {coinCost} coins and {timeSegments} time"
- Factual descriptions like "Health changed by {change}" without formatting

### Backend-to-Frontend Communication

For methods returning ViewModels:

1. **Trace the return value** - Does it contain presentation data?
   - Check all properties in returned ViewModel for CSS classes, icons, or display text
   - Domain objects and collections are acceptable
   - User-friendly generated strings are not acceptable

2. **Check all property assignments** - Is any property set based on display logic?
   - Domain state properties like IsAvailable are acceptable
   - Properties like UnavailableReason need scrutiny: is it a domain reason code or display text?
   - CSS class properties are never acceptable

3. **Verify no conditional display logic** - Is backend choosing what to show?
   - Backend should not generate different description strings based on relationship status
   - Backend should return the relationship status enum itself
   - Frontend decides how to display that status to the player

---

## Detailed Checklist: Razor Components

### Frontend Helper Methods

Verify display logic is correctly placed in frontend:

**CORRECT Pattern: Enum to Text Mapping**
- Frontend helper methods mapping ConnectionState enum values to display strings
- Helper returns appropriate text like "Likes you", "Neutral", "Dislikes you" based on enum
- This mapping logic belongs in frontend

**CORRECT Pattern: Enum to Icon Mapping**
- Frontend helper methods mapping ConnectionState enum values to icon names
- Helper returns icon names like "hearts", "scales", "hazard-sign" based on enum
- Icon selection is a frontend responsibility

**CORRECT Pattern: Value to CSS Mapping**
- Frontend code calculating ratios from raw values and applying CSS classes
- Logic determining "danger", "warning", or normal styling based on weight/capacity ratio
- CSS selection based on domain values happens in frontend

**FORBIDDEN Pattern: Domain Logic in Frontend**
- Razor components containing game rules like stamina checks combined with modifier validation
- Components should not determine action availability based on complex game logic
- FIX: Backend calculates availability; frontend only displays the result

### Icon Usage

Verify Icon component usage:

**CORRECT Pattern:**
- Icon component receives Name and CssClass from frontend helper methods
- Helper methods map domain enum to icon name
- Helper methods map domain enum to CSS class for semantic coloring
- No icon metadata flows from backend

**FORBIDDEN Pattern:**
- Icon component receives Name from Model property (backend providing icon name)
- This indicates backend made presentation decision
- FIX: Backend returns domain enum; frontend helper selects icon

---

## Decision Tree: Is This Presentation Logic?

Use this tree to quickly determine if something is presentation logic (belongs in frontend):

**Does it decide HOW something looks?**
- If YES → Presentation logic (Frontend)
  - CSS class selection → Razor component
  - Icon name selection → Razor component
  - Color/style choice → CSS or Razor
  - Display text/wording → Razor helper method
  - Layout/organization → Razor component

- If NO → Could be domain logic (Backend)
  - Does it calculate game state or validity?
    - If YES → Domain logic (Backend service)
      - Can player afford action? → Backend
      - What's the cost? → Backend
      - Is resource sufficient? → Backend
      - Calculate next time block → Backend
    - If NO → Neither (Data only)
      - Property in ViewModel
        - Domain value (int, bool, enum) → OK
        - Presentation data (css, icon, text) → NOT OK

---

## Examples: Before and After

### Example 1: Travel Status Severity Indicator

**BEFORE (Violation):**
- TravelFacade.GetTravelStatus method returns ViewModel with calculated weight and max capacity
- VIOLATION: Backend calculates LoadStatus string based on weight ratios ("Overloaded", "Heavy", "Light")
- VIOLATION: Backend determines LoadClass CSS based on same ratios ("danger", "warning", empty string)
- Backend making both display text and styling decisions

**AFTER (Correct):**
- TravelFacade.GetTravelStatus returns only Weight and MaxCapacity values
- Frontend calculates ratio from these values
- Frontend determines status text based on ratio thresholds
- Frontend determines CSS class based on ratio thresholds
- Razor component renders with Icon component and calculated display values
- Backend provides WHAT, frontend decides HOW

### Example 2: NPC Interaction Options

**BEFORE (Violation):**
- LocationFacade creates InteractionOptionViewModel with TargetNPC object reference
- VIOLATION: DisplayText property set via switch on conversation type to friendly labels
- VIOLATION: IconName property set via switch on conversation type to icon identifiers
- Backend deciding both display wording and visual representation

**AFTER (Correct):**
- LocationFacade creates InteractionOptionViewModel with TargetNPC and ConversationType enum only
- Razor component defines helper method mapping conversation type to display text
- Razor component defines helper method mapping conversation type to icon name
- Button rendering uses helpers to get appropriate text and icon from domain enum
- Backend provides domain type, frontend translates to presentation

### Example 3: Action Availability Messages

**BEFORE (Violation):**
- ActionExecutor.CheckAvailability validates action and maps validation result to user messages
- VIOLATION: Switch expression generates friendly error messages like "You're too tired"
- VIOLATION: UnavailableMessage property in ViewModel contains generated display text
- Backend generating player-facing error messages

**AFTER (Correct):**
- Define ActionRestrictionReason enum with values like InsufficientStamina, InsufficientCoins
- ActionExecutor.CheckAvailability returns IsAvailable boolean and RestrictionReason enum
- Razor component defines helper method mapping restriction reason to user-friendly message
- Component checks IsAvailable and renders restriction message using helper
- Backend identifies WHY unavailable, frontend decides HOW to communicate it

---

## Common Violations and Fixes

### Violation: Display Enum or String Field

**COMMON VIOLATION:**
- ViewModel has string property for ActionType with values like "combat", "social", "exploration"
- Service instantiates ViewModel by setting ActionType string and then calling method to get display text
- String value used for both backend routing and frontend display decision

**FIX:**
- Define proper domain enum (ActionCategory) with Combat, Social, Exploration values
- ViewModel property uses enum type instead of string
- Service sets Category enum value only
- Frontend generates display text from enum

### Violation: Presentation Property Names

**COMMON VIOLATION:**
- Properties named DisplayStatus, DisplayText, DisplayName indicate presentation logic
- These names suggest backend is deciding how to display information

**FIX:**
- Rename properties to represent domain concepts: Status, ActionType, Name
- Consider whether property should be enum instead of string
- Property should describe WHAT it is in domain, not HOW it displays

### Violation: Conditional Display Properties

**VIOLATION:**
- ViewModel has FormattedAmount property with getter that formats numbers
- Getter contains logic to abbreviate large numbers with K/M suffixes
- Backend making formatting decision for display

**FIX:**
- ViewModel property returns plain int Amount value
- Frontend Razor component defines helper method for number formatting
- Helper applies abbreviation logic and returns formatted string
- ViewModel contains raw data, frontend applies formatting

---

## Approval Criteria

### PR APPROVED when:

- [ ] No ViewModels have CSS class properties
- [ ] No ViewModels have icon name properties
- [ ] No ViewModels have display text properties (unless domain-provided description)
- [ ] All ViewModels use domain enums for type information
- [ ] All ViewModels contain only domain values (int, bool, string describing domain entities)
- [ ] No backend service contains hardcoded display strings
- [ ] No backend service contains switch/case on display type
- [ ] Message creation contains domain data only
- [ ] Presentation logic moved to Razor components
- [ ] Icon selection in frontend only
- [ ] CSS class selection in frontend only

### PR REJECTED when:

- [ ] Found CSS class property in ViewModel
- [ ] Found icon name property in ViewModel
- [ ] Found hardcoded display text in service
- [ ] Found backend choosing between icons
- [ ] Found backend generating messages with tokens
- [ ] Found display formatting in backend
- [ ] Found conditional presentation logic in service

---

## Quick Checklist for Reviewer

**Backend/Frontend Separation Review**

**ViewModels:**
- No CSS properties (FocusClass, IconClass, StyleClass, etc.)
- No icon properties (Icon, IconName, etc.)
- No display text properties (Description with generated text)
- Only domain enums and values

**Services/Facades:**
- No switch on display type
- No CSS class selection
- No icon name selection
- No hardcoded display strings
- No message tokens with presentation

**Messages:**
- No icon tokens with curly braces
- No formatting for display (pipes, dashes)
- Only domain data

**Razor Components:**
- Helpers present for display mapping
- Icon selection in frontend
- CSS class selection in frontend
- No domain logic in components

**Overall:**
- Backend returns WHAT, frontend decides HOW
- Clear separation of concerns
- Frontend could be swapped without backend changes

---
