# Code Review Checklist: Backend/Frontend Separation

Use this checklist when reviewing pull requests to ensure the Backend/Frontend Separation principle is maintained. This principle is **MANDATORY** and violations must be fixed before merging.

---

## Quick Summary

**REJECT PR if backend is making any presentation decisions:**
- Selecting CSS classes
- Choosing icon names
- Generating display text
- Creating message tokens with presentation metadata
- Routing based on display type
- Applying styling logic

**APPROVE PR if presentation logic is entirely in frontend:**
- Domain enums flow from backend to frontend
- Frontend maps enums to visual representations
- Display text generated in Razor helpers
- CSS applied in Razor components
- Icons selected in frontend only

---

## Pre-Review: File Scope Analysis

Before diving into code, identify which files need review:

**ALWAYS REVIEW if changed:**
- `src/ViewModels/**/*.cs` - Check for presentation properties
- `src/Services/**/*.cs` - Check for presentation logic
- `src/Subsystems/**/*.cs` - Check for display decisions
- `src/Pages/Components/**/*.razor` - Verify presentation logic is here, not backend

**SELECTIVELY REVIEW if changed:**
- `src/GameState/**/*.cs` - Only if ViewModels modified
- `src/Content/**/*.cs` - Only if returning presentation data
- Razor components - Look for domain logic (should be none)

**SKIP REVIEW of:**
- Pure domain entity changes (Player, Location, etc.)
- Repository/Data access changes (unless ViewModel impacts)
- Configuration/DI changes

---

## Detailed Checklist: ViewModels

### ViewModel Properties

For each public property in a ViewModel, ask:

- **Is this a CSS class name?** → REJECT
  ```csharp
  // REJECT
  public string FocusClass { get; set; } // "", "warning", "danger"
  public string StatusCss { get; set; }
  ```

- **Is this an icon name?** → REJECT
  ```csharp
  // REJECT
  public string Icon { get; set; } // "coins", "health-normal"
  public string IconName { get; set; }
  ```

- **Is this display text generated by backend?** → REJECT
  ```csharp
  // REJECT
  public string Description { get; set; } // Set to "You're too tired"
  public string ActionLabel { get; set; } // Set to "Friendly Chat"
  ```

- **Is this a code-generated formatted string?** → REJECT
  ```csharp
  // REJECT
  public string DisplayString { get; set; } // "Health: 50 | Stamina: 30"
  public string FormattedMessage { get; set; }
  ```

- **Is this a domain enum?** → APPROVE
  ```csharp
  // APPROVE
  public ConnectionState RelationshipState { get; set; }
  public ActionRestrictionReason RestrictionReason { get; set; }
  ```

- **Is this a plain domain value?** → APPROVE
  ```csharp
  // APPROVE
  public int TotalWeight { get; set; }
  public bool IsAvailable { get; set; }
  public string NPCName { get; set; } // Domain entity name, not generated display
  ```

### ViewModel Creation

Check where ViewModels are instantiated:

**Pattern 1: Backend Setting CSS Classes**
```csharp
// REJECT THIS
return new TravelStatusViewModel
{
    FocusClass = weight > 50 ? "danger" : weight > 25 ? "warning" : ""
};
```

**Pattern 2: Backend Choosing Icons**
```csharp
// REJECT THIS
return new ActionViewModel
{
    Icon = actionType switch
    {
        ActionType.Combat => "sword",
        ActionType.Social => "shaking-hands",
        _ => "sparkles"
    }
};
```

**Pattern 3: Backend Generating Display Text**
```csharp
// REJECT THIS
return new InteractionViewModel
{
    DisplayText = conversationType switch
    {
        "friendly" => "Friendly Chat",
        "request" => "Request Information",
        _ => "Talk"
    }
};
```

**Pattern 4: Correct - Domain Enum Only**
```csharp
// APPROVE THIS
return new InteractionViewModel
{
    ConversationType = conversationType, // Enum, not text
    TargetNPC = npc, // Object reference, NOT NPCId
    IsAvailable = CanInteract(npc)
};
```

---

## Detailed Checklist: Service/Facade Code

### Display Logic in Services

Scan service methods for presentation decisions:

**Pattern 1: Switching on Display Type**
```csharp
// REJECT - Backend making display decisions
string iconName = resourceType switch
{
    ResourceType.Coins => "coins",
    ResourceType.Health => "health-normal",
    _ => "sparkles"
};
```

**Pattern 2: Generating Display Strings**
```csharp
// REJECT - Backend generating what to show
string status = weight > limit ? "Overloaded" : weight > limit * 0.8 ? "Heavy" : "Light";

return new StatusViewModel { DisplayStatus = status };
```

**Pattern 3: Conditional CSS Logic**
```csharp
// REJECT - Backend applying styling logic
string cssClass = stamina < 10 ? "danger" : stamina < 30 ? "warning" : "";
```

**Pattern 4: Correct - Domain Logic Only**
```csharp
// APPROVE - Backend returns domain values
return new StatusViewModel
{
    TotalWeight = player.GetCarriedWeight(),
    MaxCapacity = player.GetCapacity(),
    CurrentStamina = player.Stamina
    // Frontend decides presentation
};
```

### Message System Usage

Check how messages are created:

**Pattern 1: Icons in Messages**
```csharp
// REJECT - Presentation token in message
_messageSystem.AddSystemMessage("{icon:coins} Spent {0} coins", amount);
```

**Pattern 2: Formatted Display Strings**
```csharp
// REJECT - Formatting for display
_messageSystem.AddSystemMessage($"Health: {health} | Stamina: {stamina}");
```

**Pattern 3: Generated Friendly Text**
```csharp
// REJECT - Display text in message
_messageSystem.AddSystemMessage("You've made good progress on this route!");
```

**Pattern 4: Correct - Domain Data Only**
```csharp
// APPROVE - Just game events, no presentation
_messageSystem.AddSystemMessage($"Travel to {destination} costs {coinCost} coins and {timeSegments} time");

// APPROVE - Simple descriptions without formatting
_messageSystem.AddSystemMessage($"Health changed by {change}");
```

### Backend-to-Frontend Communication

For methods returning ViewModels:

1. **Trace the return value** - Does it contain presentation data?
   ```csharp
   public LocationActionsViewModel GetLocationActions()
   {
       return new LocationActionsViewModel
       {
           Actions = actions, // OK - list of domain objects
           // NOT OK - "Your stamina is low" would be presentation
       };
   }
   ```

2. **Check all property assignments** - Is any property set based on display logic?
   ```csharp
   viewModel.IsAvailable = true; // OK - domain state
   viewModel.UnavailableReason = "Need level 5"; // MAYBE - domain reason or display text?
   viewModel.CssClass = "unavailable"; // NOT OK - presentation
   ```

3. **Verify no conditional display logic** - Is backend choosing what to show?
   ```csharp
   // NOT OK - Backend decided to show this specific text
   if (npc.RelationshipStatus == RelationshipStatus.Friendly)
   {
       viewModel.Description = "This person likes you";
   }

   // OK - Frontend decides the text
   viewModel.RelationshipStatus = npc.RelationshipStatus;
   ```

---

## Detailed Checklist: Razor Components

### Frontend Helper Methods

Verify display logic is correctly placed in frontend:

**Pattern 1: Correct - Enum to Text Mapping**
```csharp
// APPROVE - Frontend helper for display
private string GetStatusText(ConnectionState state) => state switch
{
    ConnectionState.Friendly => "Likes you",
    ConnectionState.Neutral => "Neutral",
    ConnectionState.Hostile => "Dislikes you",
    _ => "Unknown"
};
```

**Pattern 2: Correct - Enum to Icon Mapping**
```csharp
// APPROVE - Frontend selecting icons
private string GetStatusIcon(ConnectionState state) => state switch
{
    ConnectionState.Friendly => "hearts",
    ConnectionState.Neutral => "scales",
    ConnectionState.Hostile => "hazard-sign",
    _ => "question"
};
```

**Pattern 3: Correct - Value to CSS Mapping**
```csharp
// APPROVE - Frontend deciding CSS based on values
@{
    double ratio = (double)Model.Weight / Model.MaxCapacity;
    string css = ratio > 0.8 ? "danger" : ratio > 0.6 ? "warning" : "";
}
```

**Pattern 4: NOT OK - Domain Logic in Frontend**
```csharp
// REJECT - Game logic in component
@{
    if (Model.Stamina < 10 && !player.HasModifier("resistance"))
    {
        <span>Cannot travel</span>
    }
}
```

### Icon Usage

Verify Icon component usage:

**Correct Pattern:**
```razor
<Icon Name="@GetIconName(Model.Type)" CssClass="@GetIconClass(Model.Type)" />

@code {
    private string GetIconName(ResourceType type) => type switch { ... };
    private string GetIconClass(ResourceType type) => type switch { ... };
}
```

**NOT OK Pattern:**
```razor
<Icon Name="@Model.IconName" /> <!-- Frontend receiving icon from backend -->
```

---

## Decision Tree: Is This Presentation Logic?

Use this tree to quickly determine if something is presentation logic (belongs in frontend):

```
Does it decide HOW something looks?
├─ YES → Presentation logic (Frontend)
│   ├─ CSS class selection → Razor component
│   ├─ Icon name selection → Razor component
│   ├─ Color/style choice → CSS or Razor
│   ├─ Display text/wording → Razor helper method
│   └─ Layout/organization → Razor component
│
└─ NO → Could be domain logic (Backend)
    └─ Does it calculate game state or validity?
        ├─ YES → Domain logic (Backend service)
        │   ├─ Can player afford action? → Backend
        │   ├─ What's the cost? → Backend
        │   ├─ Is resource sufficient? → Backend
        │   └─ Calculate next time block → Backend
        │
        └─ NO → Neither (Data only)
            └─ Property in ViewModel
               ├─ Domain value (int, bool, enum) → OK
               └─ Presentation data (css, icon, text) → NOT OK
```

---

## Examples: Before and After

### Example 1: Travel Status Severity Indicator

**BEFORE (Violation):**
```csharp
// In TravelFacade
public TravelStatusViewModel GetTravelStatus()
{
    int weight = player.CarriedWeight;
    int max = player.Capacity;

    return new TravelStatusViewModel
    {
        Weight = weight,
        MaxCapacity = max,
        LoadStatus = weight > max * 0.8 ? "Overloaded" :
                     weight > max * 0.6 ? "Heavy" : "Light",
        LoadClass = weight > max * 0.8 ? "danger" :
                    weight > max * 0.6 ? "warning" : ""
    };
}
```

**AFTER (Correct):**
```csharp
// In TravelFacade
public TravelStatusViewModel GetTravelStatus()
{
    int weight = player.CarriedWeight;
    int max = player.Capacity;

    return new TravelStatusViewModel
    {
        Weight = weight,
        MaxCapacity = max
        // Frontend decides everything else
    };
}

// In Razor component or helper
@{
    double ratio = (double)Model.Weight / Model.MaxCapacity;
    string status = ratio > 0.8 ? "Overloaded" :
                    ratio > 0.6 ? "Heavy" : "Light";
    string css = ratio > 0.8 ? "danger" :
                 ratio > 0.6 ? "warning" : "";
}

<div class="travel-status @css">
    <Icon Name="backpack" CssClass="resource-item" />
    @status: @Model.Weight / @Model.MaxCapacity kg
</div>
```

### Example 2: NPC Interaction Options

**BEFORE (Violation):**
```csharp
// In LocationFacade
var interaction = new InteractionOptionViewModel
{
    TargetNPC = npc, // Object reference, NOT NPCId
    DisplayText = conversationType switch  // VIOLATION - Hardcoded text
    {
        "friendly_chat" => "Friendly Chat",
        "request" => "Request Information",
        "delivery" => "Deliver Letter",
        _ => "Talk"
    },
    IconName = conversationType switch  // VIOLATION - Icon selection
    {
        "friendly_chat" => "shaking-hands",
        "request" => "magnifying-glass",
        "delivery" => "mail",
        _ => "question"
    }
};
```

**AFTER (Correct):**
```csharp
// In LocationFacade
var interaction = new InteractionOptionViewModel
{
    TargetNPC = npc, // Object reference, NOT NPCId
    ConversationType = conversationType  // Domain enum, no display logic
};

// In Razor component
@{
    string GetConversationText(string type) => type switch
    {
        "friendly_chat" => "Friendly Chat",
        "request" => "Request Information",
        "delivery" => "Deliver Letter",
        _ => "Talk"
    };

    string GetConversationIcon(string type) => type switch
    {
        "friendly_chat" => "shaking-hands",
        "request" => "magnifying-glass",
        "delivery" => "mail",
        _ => "question"
    };
}

<button class="interaction-option">
    <Icon Name="@GetConversationIcon(Model.ConversationType)" CssClass="icon-neutral" />
    @GetConversationText(Model.ConversationType)
</button>
```

### Example 3: Action Availability Messages

**BEFORE (Violation):**
```csharp
// In ActionExecutor
public ActionAvailabilityViewModel CheckAvailability(Action action)
{
    string reason = ValidateAction(action) switch
    {
        ValidationResult.InsufficientStamina => "You're too tired",
        ValidationResult.InsufficientCoins => "You can't afford this",
        ValidationResult.RequiredItemMissing => "You don't have the required item",
        ValidationResult.TutorialRestriction => "This action is blocked during tutorial",
        _ => "This action is unavailable"
    };

    return new ActionAvailabilityViewModel
    {
        IsAvailable = false,
        UnavailableMessage = reason  // VIOLATION - Display text from backend
    };
}
```

**AFTER (Correct):**
```csharp
// Domain enum
public enum ActionRestrictionReason
{
    InsufficientStamina,
    InsufficientCoins,
    RequiredItemMissing,
    TutorialRestriction,
    None
}

// In ActionExecutor
public ActionAvailabilityViewModel CheckAvailability(Action action)
{
    ActionRestrictionReason reason = ValidateAction(action);

    return new ActionAvailabilityViewModel
    {
        IsAvailable = reason == ActionRestrictionReason.None,
        RestrictionReason = reason  // Domain enum, not text
    };
}

// In Razor component
@{
    string GetRestrictionMessage(ActionRestrictionReason reason) => reason switch
    {
        ActionRestrictionReason.InsufficientStamina => "You're too tired for this action",
        ActionRestrictionReason.InsufficientCoins => "You can't afford this",
        ActionRestrictionReason.RequiredItemMissing => "You don't have the required item",
        ActionRestrictionReason.TutorialRestriction => "This action is blocked during the tutorial",
        ActionRestrictionReason.None => "",
        _ => "This action is unavailable"
    };
}

@if (!Model.IsAvailable)
{
    <div class="action-restriction">
        <Icon Name="padlock" CssClass="icon-negative" />
        @GetRestrictionMessage(Model.RestrictionReason)
    </div>
}
```

---

## Common Violations and Fixes

### Violation: Display Enum or String Field

```csharp
// COMMON VIOLATION
public class ActionViewModel
{
    public string ActionType { get; set; } // "combat", "social", "exploration"
}

// In service
var action = new ActionViewModel
{
    ActionType = "combat",  // String value for backend routing
    DisplayText = GetDisplayText("combat")  // Then generating display
};

// FIX: Use domain enum instead
public enum ActionCategory
{
    Combat,
    Social,
    Exploration
}

public class ActionViewModel
{
    public ActionCategory Category { get; set; }
}

var action = new ActionViewModel
{
    Category = ActionCategory.Combat
    // Frontend generates display text
};
```

### Violation: Presentation Property Names

```csharp
// COMMON VIOLATION - "Display" in property name often indicates presentation logic
public string DisplayStatus { get; set; }
public string DisplayText { get; set; }
public string DisplayName { get; set; }

// BETTER - Name properties by domain, not presentation intent
public string Status { get; set; }
public string ActionType { get; set; }  // Use enum instead
public string Name { get; set; }  // Should be just NPCName, LocationName, etc.
```

### Violation: Conditional Display Properties

```csharp
// VIOLATION - Calculating display text in backend
public class ResourceViewModel
{
    public string FormattedAmount
    {
        get
        {
            return Amount > 1000000 ? $"{Amount / 1000000}M" :
                   Amount > 1000 ? $"{Amount / 1000}K" :
                   Amount.ToString();
        }
    }
}

// BETTER - Return plain value, let frontend format
public class ResourceViewModel
{
    public int Amount { get; set; }
}

// In Razor
@{
    string FormatAmount(int amount) =>
        amount > 1000000 ? $"{amount / 1000000}M" :
        amount > 1000 ? $"{amount / 1000}K" :
        amount.ToString();
}

Coins: @FormatAmount(Model.Amount)
```

---

## Approval Criteria

### PR APPROVED when:

- [ ] No ViewModels have CSS class properties
- [ ] No ViewModels have icon name properties
- [ ] No ViewModels have display text properties (unless domain-provided description)
- [ ] All ViewModels use domain enums for type information
- [ ] All ViewModels contain only domain values (int, bool, string describing domain entities)
- [ ] No backend service contains hardcoded display strings
- [ ] No backend service contains switch/case on display type
- [ ] Message creation contains domain data only
- [ ] Presentation logic moved to Razor components
- [ ] Icon selection in frontend only
- [ ] CSS class selection in frontend only

### PR REJECTED when:

- [ ] Found CSS class property in ViewModel
- [ ] Found icon name property in ViewModel
- [ ] Found hardcoded display text in service
- [ ] Found backend choosing between icons
- [ ] Found backend generating messages with tokens
- [ ] Found display formatting in backend
- [ ] Found conditional presentation logic in service

---

## Quick Checklist for Reviewer

```markdown
## Backend/Frontend Separation Review

### ViewModels
- [ ] No CSS properties (FocusClass, IconClass, StyleClass, etc.)
- [ ] No icon properties (Icon, IconName, etc.)
- [ ] No display text properties (Description with generated text)
- [ ] Only domain enums and values

### Services/Facades
- [ ] No switch on display type
- [ ] No CSS class selection
- [ ] No icon name selection
- [ ] No hardcoded display strings
- [ ] No message tokens with presentation

### Messages
- [ ] No {icon:...} tokens
- [ ] No formatting for display (pipes, dashes)
- [ ] Only domain data

### Razor Components
- [ ] Helpers present for display mapping
- [ ] Icon selection in frontend
- [ ] CSS class selection in frontend
- [ ] No domain logic in components

### Overall
- [ ] Backend returns WHAT, frontend decides HOW
- [ ] Clear separation of concerns
- [ ] Frontend could be swapped without backend changes
```

---
